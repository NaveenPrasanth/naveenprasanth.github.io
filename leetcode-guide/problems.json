[
  {
    "id": "problem_1",
    "number": 1,
    "title": "TwoSum",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 11: Sliding Window - Character Frequency Matching",
    "url": "https://leetcode.com/problems/twosum/",
    "difficulty": "easy",
    "content": "# TwoSum\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [TwoSum](https://leetcode.com/problems/twosum/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 11: Sliding Window - Character Frequency Matching",
    "description": "Study TwoSum using the Pattern 11: Sliding Window - Character Frequency Matching approach.",
    "has_content": false
  },
  {
    "id": "problem_2",
    "number": 2,
    "title": "Add Two Numbers",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 71: Linked List - Addition of Numbers",
    "url": "https://leetcode.com/problems/add-two-numbers/",
    "difficulty": "easy",
    "content": "# Add Two Numbers\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Add Two Numbers](https://leetcode.com/problems/add-two-numbers/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 71: Linked List - Addition of Numbers",
    "description": "Study Add Two Numbers using the Pattern 71: Linked List - Addition of Numbers approach.",
    "has_content": false
  },
  {
    "id": "problem_3",
    "number": 3,
    "title": "Longest Substring Without Repeating Characters",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/longest-substring-without-repeating-characters/",
    "difficulty": "easy",
    "content": "# Longest Substring Without Repeating Characters\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Longest Substring Without Repeating Characters using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_4",
    "number": 4,
    "title": "Median of Two Sorted Arrays",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 57: Binary Search - Median of Two Sorted Arrays",
    "url": "https://leetcode.com/problems/median-of-two-sorted-arrays/",
    "difficulty": "easy",
    "content": "# Median of Two Sorted Arrays\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Median of Two Sorted Arrays](https://leetcode.com/problems/median-of-two-sorted-arrays/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 57: Binary Search - Median of Two Sorted Arrays",
    "description": "Study Median of Two Sorted Arrays using the Pattern 57: Binary Search - Median of Two Sorted Arrays approach.",
    "has_content": false
  },
  {
    "id": "problem_5",
    "number": 5,
    "title": "Longest Palindromic Substring",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 6: Two Pointers - Expanding From Center (Palindromes)",
    "url": "https://leetcode.com/problems/longest-palindromic-substring/",
    "difficulty": "easy",
    "content": "Here is the detailed, educational entry for the \"Longest Palindromic Substring\" problem, formatted for your algorithms study guide.\n\n---\n\n### **5. Longest Palindromic Substring**\n**Link to Problem:** [https://leetcode.com/problems/longest-palindromic-substring/](https://leetcode.com/problems/longest-palindromic-substring/)\n\n#### **1. Problem Statement**\nGiven a string `s`, the task is to find and return the longest substring within `s` that is also a palindrome. A palindrome is a sequence that reads the same backward as forward.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to check every possible substring of `s`. We can generate all substrings, check if each one is a palindrome, and keep track of the longest one we've found so far.\n\nThe logic is as follows:\n1.  Use a loop with index `i` to determine the starting character of a potential substring.\n2.  Use a nested loop with index `j` to determine the ending character.\n3.  For each substring from `i` to `j`, create a helper function to verify if it's a palindrome.\n4.  Maintain two variables, one for the maximum length found and one for the longest palindrome string itself. Update them whenever a longer palindrome is discovered.\n\n**Python Code:**\n```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        \n        def is_palindrome(sub: str) -> bool:\n            # A simple way to check for a palindrome is to see if the\n            # string is equal to its reverse.\n            return sub == sub[::-1]\n\n        n = len(s)\n        if n < 2:\n            return s\n            \n        max_len = 1\n        longest_pal = s[0]\n\n        # First loop sets the starting point of the substring.\n        for i in range(n):\n            # Second loop sets the ending point.\n            for j in range(i, n):\n                substring = s[i:j+1]\n                # If we find a new palindrome that is longer than our current max...\n                if len(substring) > max_len and is_palindrome(substring):\n                    max_len = len(substring)\n                    longest_pal = substring\n                    \n        return longest_pal\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(n³)**\n    We have two nested loops to generate all substrings, which takes O(n²) time. For each of these O(n²) substrings, we call `is_palindrome`. In the worst case, checking a substring of length `k` takes O(k) time (due to slicing and comparison). Since `k` can be up to `n`, the total complexity is O(n² * n) = O(n³).\n\n*   **Space Complexity: O(n)**\n    The space complexity is dominated by the slicing operation `s[i:j+1]`, which can create a new string of up to length `n`.\n\n#### **3. Optimized Approach: Two Pointers - Expanding From Center**\n**Intuition:**\nThe brute-force method is inefficient because it repeatedly checks overlapping substrings. A more clever approach is to realize that every palindrome has a center. This center can either be a single character (for odd-length palindromes like \"r-a-c-e-c-a-r\") or the space between two identical characters (for even-length palindromes like \"a-b-b-a\").\n\nInstead of checking every substring, we can iterate through every possible center and expand outwards with two pointers to find the longest palindrome centered there. There are `n` possible single-character centers and `n-1` possible two-character centers, for a total of `2n - 1` potential centers.\n\nLet's walk through `s = \"babad\"`:\n1.  **Center at `i = 0` ('b'):**\n    *   Odd case: `(left=0, right=0)`. `s[0] == s[0]`. Palindrome is \"b\". Can't expand further.\n2.  **Center at `i = 1` ('a'):**\n    *   Odd case: `(left=1, right=1)`. Palindrome is \"a\". Expand outwards: `left=0, right=2`. `s[0]` ('b') == `s[2]` ('b'). It's a match! The palindrome is now \"bab\". Expand again: `left=-1, right=3`. Pointers are out of bounds. The longest palindrome from this center is \"bab\".\n    *   Even case: `(left=1, right=2)`. `s[1]` ('a') != `s[2]` ('b'). No even palindrome here.\n3.  **Center at `i = 2` ('b'):**\n    *   Odd case: `(left=2, right=2)`. Palindrome is \"b\". Expand: `left=1, right=3`. `s[1]` ('a') == `s[3]` ('a'). Match! Palindrome is \"aba\".\n    *   ... and so on.\n\nWe keep track of the longest palindrome found across all center expansions.\n\n**Python Code:**\n```python\nclass Solution:\n    def longestPalindrome(self, s: str) -> str:\n        if not s or len(s) < 1:\n            return \"\"\n\n        # We'll store the start and end indices of the longest palindrome found so far.\n        start = 0\n        end = 0\n\n        # Iterate through each character of the string to treat it as a potential center.\n        for i in range(len(s)):\n            # Case 1: Odd length palindrome (e.g., \"racecar\")\n            # The center is the character at index `i`.\n            len1 = self.expand_from_center(s, i, i)\n            \n            # Case 2: Even length palindrome (e.g., \"aabbaa\")\n            # The center is between the characters at `i` and `i+1`.\n            len2 = self.expand_from_center(s, i, i + 1)\n            \n            # Find the maximum length from the two cases.\n            max_len = max(len1, len2)\n            \n            # If we found a new longest palindrome, update our start and end indices.\n            if max_len > (end - start):\n                # We calculate the start index from the center and the length.\n                start = i - (max_len - 1) // 2\n                end = i + max_len // 2\n\n        # Return the longest palindromic substring using the final start and end indices.\n        return s[start : end + 1]\n\n    def expand_from_center(self, s: str, left: int, right: int) -> int:\n        # These two pointers start at the center and expand outwards.\n        while left >= 0 and right < len(s) and s[left] == s[right]:\n            left -= 1\n            right += 1\n        \n        # The length of the palindrome is right - left - 1.\n        # Why -1? Because after the loop ends, `left` and `right` are one\n        # position _beyond_ the boundaries of the palindrome.\n        return right - left - 1\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(n²)**\n    The main loop iterates through `n` characters. For each character, the `expand_from_center` function can, in the worst-case scenario (a string of all identical characters), expand `n/2` times. This results in a time complexity of O(n * n) = O(n²), a significant improvement over the O(n³) brute-force approach.\n\n*   **Space Complexity: O(1)**\n    We are not using any extra data structures that scale with the input size. We only use a few variables (`start`, `end`, `left`, `right`, etc.) to keep track of indices, resulting in constant space.\n\n#### **4. Pattern Connection**\nThis problem is a classic example of the **Two Pointers - Expanding From Center** pattern. The key signal for this pattern is the search for a **symmetrical** or **palindromic** property within a sequence.\n\nInstead of the brute-force method of generating all substrings and then checking their properties, this pattern reframes the problem by focusing on the core property itself—the center of the palindrome. By iterating through all possible centers and using two pointers (`left` and `right`) to expand outwards, we systematically and efficiently check only for valid palindromes.\n\nThis approach is fundamentally more efficient because it avoids redundant checks. Each character pair is compared only once per center expansion. This pattern beautifully leverages the inherent symmetry of palindromes, turning a potential O(n³) problem into a much more manageable O(n²) solution with O(1) space, making it a powerful tool for your algorithmic arsenal.",
    "description": "Study Longest Palindromic Substring using the Pattern 6: Two Pointers - Expanding From Center (Palindromes) approach.",
    "has_content": true
  },
  {
    "id": "problem_8",
    "number": 8,
    "title": "String to Integer (atoi)",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 85: String - String to Integer (atoi)",
    "url": "https://leetcode.com/problems/string-to-integer-atoi/",
    "difficulty": "easy",
    "content": "# String to Integer (atoi)\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [String to Integer (atoi)](https://leetcode.com/problems/string-to-integer-atoi/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 85: String - String to Integer (atoi)",
    "description": "Study String to Integer (atoi) using the Pattern 85: String - String to Integer (atoi) approach.",
    "has_content": false
  },
  {
    "id": "problem_9",
    "number": 9,
    "title": "Palindrome Number",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 82: String - Palindrome Check (Two Pointers / Reverse)",
    "url": "https://leetcode.com/problems/palindrome-number/",
    "difficulty": "easy",
    "content": "---\n### **9. Palindrome Number**\n**Link to Problem:** [https://leetcode.com/problems/palindrome-number/](https://leetcode.com/problems/palindrome-number/)\n\n#### **1. Problem Statement**\nGiven an integer `x`, the task is to determine if it is a palindrome. An integer is a palindrome if it reads the same forwards and backwards. The function should return `true` if it's a palindrome and `false` otherwise.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most direct way to check for palindromic properties is to convert the number into a format that allows for easy comparison from both ends. A string is the natural choice. We can convert the integer to a string and then use two pointers, one at the beginning and one at the end, moving them towards the center. If the characters at the pointers ever mismatch, we know it's not a palindrome. If the pointers meet or cross without finding any mismatches, the number is a palindrome.\n\n**Python Code:**\n```python\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        # A negative number reads differently forwards and backwards (e.g., -121 vs 121-).\n        # Therefore, no negative number can be a palindrome.\n        if x < 0:\n            return False\n\n        # Convert the integer to a string to easily access its \"digits\" by index.\n        s = str(x)\n        \n        # Initialize two pointers, one at the very beginning and one at the very end.\n        left, right = 0, len(s) - 1\n        \n        # Loop until the pointers meet or cross each other.\n        while left < right:\n            # If the characters at the current pointers do not match, it's not a palindrome.\n            if s[left] != s[right]:\n                return False\n            \n            # Move the pointers one step closer to the center.\n            left += 1\n            right -= 1\n            \n        # If the loop completes without returning false, the number is a palindrome.\n        return True\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**, where N is the number of digits in the integer `x`. Converting the integer to a string takes O(N) time. The `while` loop runs approximately N/2 times, which is also O(N). The dominant factor is O(N).\n*   **Space Complexity: O(N)**. We create a string representation of the number, which requires storage space proportional to the number of digits.\n\n### **3. Optimized Approach: Two Pointers - Expanding From Center (Palindromes)**\n**Intuition:**\nThe brute-force solution is simple, but the problem includes a follow-up: \"Could you solve it without converting the integer to a string?\". This hints that we should use a mathematical approach that avoids the O(N) space cost of string conversion.\n\nThe core idea is to reverse the *second half* of the number and compare it to the *first half*. If they are identical, the number is a palindrome. We can do this arithmetically by repeatedly \"popping\" the last digit of the original number and \"pushing\" it onto a new `reverted_number`.\n\nLet's walk through an example with `x = 1221`:\n1.  Initialize `reverted_number = 0`. `x = 1221`.\n2.  **Loop 1:**\n    *   `reverted_number` = `0 * 10 + 1` -> `1`\n    *   `x` = `1221 // 10` -> `122`\n    *   Condition `x > reverted_number` (122 > 1) is true.\n3.  **Loop 2:**\n    *   `reverted_number` = `1 * 10 + 2` -> `12`\n    *   `x` = `122 // 10` -> `12`\n    *   Condition `x > reverted_number` (12 > 12) is false. The loop terminates.\n\nAt the end, we compare `x` (the remaining first half) with `reverted_number` (the reversed second half). Here, `x` (12) is equal to `reverted_number` (12), so it's a palindrome. For an odd-length number like `12321`, the loop stops when `x = 12` and `reverted_number = 123`. The middle digit (3) doesn't matter for the palindrome check, so we can discard it by comparing `x` with `reverted_number // 10`.\n\nThis approach conceptually mirrors a two-pointer technique: `x` acts as a pointer shrinking from the right, while `reverted_number` acts as another pointer building the reversed sequence.\n\n**Python Code:**\n```python\nclass Solution:\n    def isPalindrome(self, x: int) -> bool:\n        # Edge Cases:\n        # 1. Negative numbers are not palindromes.\n        # 2. If the last digit is 0, the first digit must also be 0 for it to be a palindrome.\n        #    The only number that satisfies this is 0 itself.\n        if x < 0 or (x % 10 == 0 and x != 0):\n            return False\n\n        reverted_number = 0\n        \n        # We only need to revert the second half of the number.\n        # The loop stops when we've processed half the digits, which is when x <= reverted_number.\n        while x > reverted_number:\n            # Get the last digit of x and add it to the end of reverted_number.\n            last_digit = x % 10\n            reverted_number = reverted_number * 10 + last_digit\n            \n            # Remove the last digit from x.\n            x //= 10\n\n        # After the loop, x is the first half and reverted_number is the second half.\n        # Check for both even and odd length numbers:\n        # - Even (e.g., 1221): loop stops when x=12, reverted_number=12. We need x == reverted_number.\n        # - Odd (e.g., 12321): loop stops when x=12, reverted_number=123. The middle digit is on reverted_number.\n        #   We can discard it with integer division: reverted_number // 10. We need x == reverted_number // 10.\n        return x == reverted_number or x == reverted_number // 10\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(log₁₀(N))**, where N is the value of the integer. We divide the input number by 10 in each iteration, so the number of loop iterations is proportional to the number of digits in `x`, which is mathematically `log₁₀(N)`. This is a significant improvement over the O(N) string conversion approach.\n*   **Space Complexity: O(1)**. We only use a few variables to store integer values, regardless of the size of the input `x`. This satisfies the \"no extra space\" follow-up.\n\n#### **4. Pattern Connection**\nThis problem is a classic, non-obvious application of the palindrome checking logic that underpins patterns like **Expanding From Center**. While we don't use literal array indices as pointers, the core principle is the same: **verifying symmetry by comparing two halves of a sequence.**\n\nThe key signals that this pattern is relevant are:\n1.  The problem explicitly asks to check for a **palindromic property** (reading the same forwards and backwards).\n2.  The \"no string conversion\" constraint forces a mathematical solution that must **simulate the comparison of the first and second halves** of the number.\n\nThe optimized solution cleverly treats the number itself as the sequence. The variable `x` represents the shrinking first half, while `reverted_number` is the growing, reversed second half. The `while` loop runs until these two conceptual \"halves\" meet in the middle. This process of building one half to match the other is a numerical equivalent of the pointer-based comparison used on strings and arrays, making it a foundational example of how sequence-based patterns can be adapted to a purely arithmetic domain.",
    "description": "Study Palindrome Number using the Pattern 82: String - Palindrome Check (Two Pointers / Reverse) approach.",
    "has_content": true
  },
  {
    "id": "problem_11",
    "number": 11,
    "title": "Container With Most Water",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)",
    "url": "https://leetcode.com/problems/container-with-most-water/",
    "difficulty": "easy",
    "content": "---\n### **11. Container With Most Water**\n**Link to Problem:** [https://leetcode.com/problems/container-with-most-water/](https://leetcode.com/problems/container-with-most-water/)\n\n#### **1. Problem Statement**\nGiven an array of non-negative integers `height`, where each integer represents the height of a vertical line at a specific coordinate, the goal is to find the two lines that, along with the x-axis, create a container with the largest possible water capacity. The output should be this maximum area.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to consider every possible pair of vertical lines and calculate the area of the container they form. We can use a nested loop structure: the outer loop picks the first line (`i`), and the inner loop iterates through all subsequent lines (`j`) to form a pair. For each pair, we calculate the area and update a variable that tracks the maximum area found so far.\n\nThe area for any pair of lines `i` and `j` is determined by the shorter of the two lines (as water would spill over the shorter side) and the distance between them.\n`Area = width * height = (j - i) * min(height[i], height[j])`\n\n**Python Code:**\n```python\nfrom typing import List\n\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n        max_area = 0\n        n = len(height)\n\n        # The outer loop fixes the left line of the container.\n        for i in range(n):\n            # The inner loop tries every possible right line for the fixed left line.\n            for j in range(i + 1, n):\n                # The width is the distance between the two lines.\n                width = j - i\n                \n                # The height of the container is limited by the shorter of the two lines.\n                container_height = min(height[i], height[j])\n                \n                # Calculate the area for the current pair of lines.\n                current_area = width * container_height\n                \n                # Update the maximum area found so far.\n                max_area = max(max_area, current_area)\n                \n        return max_area\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: `O(N^2)`**\n    This is due to the nested loops. For an array of size `N`, the outer loop runs `N` times, and the inner loop runs approximately `N` times for each outer iteration, leading to a quadratic time complexity.\n\n*   **Space Complexity: `O(1)`**\n    The algorithm uses a constant amount of extra space, as we only need a few variables to store the max area and loop indices.\n\n### **3. Optimized Approach: Two Pointers - Converging**\n**Intuition:**\nThe brute-force approach is inefficient because it considers many pairs that are guaranteed to be suboptimal. We can do much better by being strategic. The key insight is that the area is constrained by both the width and the height. To maximize the area, we want to maximize both.\n\nThis leads to the **Two Pointers** pattern. We can start with the widest possible container by placing one pointer (`left`) at the beginning of the array and another (`right`) at the very end. This configuration has the maximum possible width.\n\nNow, how do we find a potentially larger area? We can't increase the width any further, so our only hope is to find a taller pair of lines. The current container's height is limited by the shorter of `height[left]` and `height[right]`.\n\nLet's say `height[left]` is shorter than `height[right]`. If we move the `right` pointer inward, the width will decrease, and the new height will still be limited by `height[left]`. The new area will *definitively* be smaller. Therefore, there is no benefit in moving the pointer of the taller line.\n\nThe only logical move is to move the pointer of the *shorter* line inward. By doing this, we sacrifice a small amount of width, but we gain the *possibility* of finding a much taller line, which could lead to a larger overall area. We repeat this process—calculate the area, and move the shorter pointer inward—until the two pointers meet.\n\n**Example:** `height = [1, 8, 6, 2, 5, 4, 8, 3, 7]`\n\n1.  `left = 0`, `right = 8`. `h[l]=1`, `h[r]=7`. Width is 8.\n    Area = `8 * min(1, 7) = 8`. Max area is 8.\n    `h[l]` is shorter, so move `left` pointer: `left++`.\n2.  `left = 1`, `right = 8`. `h[l]=8`, `h[r]=7`. Width is 7.\n    Area = `7 * min(8, 7) = 49`. Max area is 49.\n    `h[r]` is shorter, so move `right` pointer: `right--`.\n3.  `left = 1`, `right = 7`. `h[l]=8`, `h[r]=3`. Width is 6.\n    Area = `6 * min(8, 3) = 18`. Max area is still 49.\n    `h[r]` is shorter, so move `right` pointer: `right--`.\n4.  ...and so on, until `left` and `right` cross.\n\n**Python Code:**\n```python\nfrom typing import List\n\nclass Solution:\n    def maxArea(self, height: List[int]) -> int:\n        max_area = 0\n        # Initialize two pointers at opposite ends of the array.\n        left, right = 0, len(height) - 1\n        \n        # Loop until the pointers converge.\n        while left < right:\n            # Calculate the width of the current container.\n            width = right - left\n            \n            # The height is limited by the shorter of the two lines.\n            container_height = min(height[left], height[right])\n            \n            # Calculate the area and update the maximum.\n            current_area = width * container_height\n            max_area = max(max_area, current_area)\n            \n            # This is the core logic of the pattern.\n            # We move the pointer that points to the shorter line.\n            # This is because the shorter line is the limiting factor, and moving it\n            # gives us a chance to find a taller line, which could increase the area.\n            if height[left] < height[right]:\n                left += 1  # Move the left pointer inward.\n            else:\n                right -= 1 # Move the right pointer inward.\n                \n        return max_area\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: `O(N)`**\n    This is a significant improvement. The `left` pointer only moves from left to right, and the `right` pointer only moves from right to left. In each step of the `while` loop, one of the pointers moves. This means we will traverse the array only once, resulting in linear time complexity.\n\n*   **Space Complexity: `O(1)`**\n    Similar to the brute-force approach, we only use a constant amount of extra space for the pointers and the max area variable.\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - Converging** pattern. While often associated with sorted arrays (like finding a target sum), its core principle is applicable here in a more creative way.\n\nThe key signals that point to this pattern are:\n\n1.  **Seeking a Pairwise Optimal Value:** The problem asks for the best *pair* of lines out of many possibilities to maximize a value (area).\n2.  **Value Depends on Distance:** The area calculation depends not only on the values at the pointers (`height[i]`, `height[j]`) but also on the distance between them (`j - i`).\n3.  **A \"Greedy\" Pruning Strategy:** The crucial characteristic is the ability to make a \"greedy\" decision to discard a large part of the search space. By starting at the maximum width, we can definitively say that to get a larger area, we *must* find a taller height. The only way to potentially achieve this is by moving the pointer of the current *shorter* line. This allows us to eliminate the shorter line from all future considerations, efficiently \"converging\" towards the optimal solution in a single pass.",
    "description": "Study Container With Most Water using the Pattern 1: Two Pointers - Converging (Sorted Array Target Sum) approach.",
    "has_content": true
  },
  {
    "id": "problem_13",
    "number": 13,
    "title": "Roman to Integer",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 84: String - Roman to Integer Conversion",
    "url": "https://leetcode.com/problems/roman-to-integer/",
    "difficulty": "easy",
    "content": "# Roman to Integer\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Roman to Integer](https://leetcode.com/problems/roman-to-integer/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 84: String - Roman to Integer Conversion",
    "description": "Study Roman to Integer using the Pattern 84: String - Roman to Integer Conversion approach.",
    "has_content": false
  },
  {
    "id": "problem_15",
    "number": 15,
    "title": "3Sum",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)",
    "url": "https://leetcode.com/problems/3sum/",
    "difficulty": "easy",
    "content": "---\n### **15. 3Sum**\n**Link to Problem:** [https://leetcode.com/problems/3sum/](https://leetcode.com/problems/3sum/)\n\n#### **1. Problem Statement**\nGiven an integer array `nums`, the task is to find all unique triplets `[nums[i], nums[j], nums[k]]` such that `i`, `j`, and `k` are distinct indices and the sum of the three elements is equal to zero. The final output should not contain any duplicate triplets.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to check every possible combination of three distinct numbers in the array. We can use three nested loops to iterate through all possible triplets. The first loop picks the first number, the second loop picks a second number after the first, and the third loop picks a third number after the second. Inside the innermost loop, we check if their sum is zero.\n\nA key challenge is handling duplicate triplets (e.g., `[-1, 0, 1]` is the same as `[0, 1, -1]`). To solve this, we can sort each valid triplet before storing it. Using a `set` to store the sorted triplets ensures that we only keep the unique ones.\n\n**Python Code:**\n```python\ndef threeSum_brute_force(nums: list[int]) -> list[list[int]]:\n    n = len(nums)\n    if n < 3:\n        return []\n    \n    # A set is used to automatically handle duplicate triplets.\n    # We store tuples because lists are not hashable.\n    result_set = set()\n\n    # Three nested loops to check every possible combination of three numbers.\n    for i in range(n - 2):\n        for j in range(i + 1, n - 1):\n            for k in range(j + 1, n):\n                # Check if the sum is zero\n                if nums[i] + nums[j] + nums[k] == 0:\n                    # Sort the triplet to handle permutations as duplicates\n                    # e.g., [-1, 0, 1] and [1, 0, -1] should be treated as the same.\n                    triplet = tuple(sorted([nums[i], nums[j], nums[k]]))\n                    result_set.add(triplet)\n    \n    # Convert the set of tuples back to a list of lists.\n    return [list(triplet) for triplet in result_set]\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N^3)**\n    This is due to the three nested loops, each iterating through the array. For an array of size N, the number of triplet combinations is roughly N * N * N.\n\n*   **Space Complexity: O(K)**\n    Where K is the number of unique triplets found. In the worst case, the `result_set` could store a significant number of triplets, potentially proportional to O(N^2) in some edge cases.\n\n### **3. Optimized Approach: Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)**\n**Intuition:**\nThe O(N^3) complexity of the brute-force approach is too slow for typical constraints. We can improve this by reducing the problem to a familiar, simpler one. If we fix one number, `nums[i]`, our equation `a + b + c = 0` becomes `b + c = -a`. This is now the classic \"2Sum\" problem: find two numbers in the rest of the array that sum up to a specific target (`-nums[i]`).\n\nThe key to solving the 2Sum subproblem efficiently is to first **sort the array**. Once the array is sorted, we can use the **Converging Two Pointers** pattern.\n\nHere's the step-by-step logic:\n1.  **Sort the Input Array:** Sorting is crucial. It allows us to easily skip duplicate values and use the two-pointer technique.\n2.  **Iterate with One Pointer:** Loop through the sorted array with a single index `i`. This `nums[i]` will be the first element of our potential triplet.\n3.  **Handle Duplicates:** If `nums[i]` is the same as `nums[i-1]`, we've already processed all possible triplets starting with this value, so we can skip it to avoid duplicate results.\n4.  **Set Up Two Pointers:** For each `nums[i]`, we define our target as `target = -nums[i]`. We then initialize a `left` pointer to `i + 1` and a `right` pointer to the end of the array (`n - 1`).\n5.  **Converge Pointers:** We move the `left` and `right` pointers inward until they meet:\n    *   If `nums[left] + nums[right] == target`, we have found a valid triplet: `[nums[i], nums[left], nums[right]]`. We add it to our results. Then, to avoid duplicates, we move the `left` pointer forward past any identical values and the `right` pointer backward past any identical values.\n    *   If `nums[left] + nums[right] < target`, the sum is too small. To increase the sum, we must move the `left` pointer to the right (`left += 1`).\n    *   If `nums[left] + nums[right] > target`, the sum is too large. To decrease the sum, we must move the `right` pointer to the left (`right -= 1`).\n\n**Example:** `nums = [-1, 0, 1, 2, -1, -4]`\n1.  **Sort:** `nums = [-4, -1, -1, 0, 1, 2]`\n2.  **Outer loop `i = 0`**, `nums[i] = -4`. Target = 4.\n    *   `left=1`, `right=5`. `nums[left]+nums[right] = -1+2 = 1`. Too small. `left++`.\n    *   `left=2`, `right=5`. `nums[left]+nums[right] = -1+2 = 1`. Too small. `left++`.\n    *   ...pointers converge, no solution found.\n3.  **Outer loop `i = 1`**, `nums[i] = -1`. Target = 1.\n    *   `left=2`, `right=5`. `nums[left]+nums[right] = -1+2 = 1`. **Found!** Result: `[[-1, -1, 2]]`.\n    *   Move pointers past duplicates. `left` becomes 3, `right` becomes 4.\n    *   `left=3`, `right=4`. `nums[left]+nums[right] = 0+1 = 1`. **Found!** Result: `[[-1, -1, 2], [-1, 0, 1]]`.\n    *   Move pointers. They now cross. End inner loop.\n4.  **Outer loop `i = 2`**, `nums[i] = -1`. This is a duplicate of `nums[i-1]`, so we `continue`.\n5.  ...and so on.\n\n**Python Code:**\n```python\ndef threeSum(nums: list[int]) -> list[list[int]]:\n    n = len(nums)\n    result = []\n    \n    # Sorting the array is the key to using the two-pointer approach.\n    nums.sort()\n    \n    # Outer loop fixes the first element of the triplet.\n    for i in range(n - 2):\n        # Optimization: If the current number is positive, the sum can't be zero\n        # since the array is sorted and all subsequent numbers will also be positive.\n        if nums[i] > 0:\n            break\n            \n        # Skip duplicate values for the first element to avoid duplicate triplets.\n        if i > 0 and nums[i] == nums[i - 1]:\n            continue\n            \n        # Set up the two pointers for the rest of the array.\n        left, right = i + 1, n - 1\n        \n        # This is the core of the Two Pointers pattern.\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum == 0:\n                # Found a valid triplet.\n                result.append([nums[i], nums[left], nums[right]])\n                \n                # --- Handle Duplicates for the other two elements ---\n                # Move left pointer forward as long as it's a duplicate.\n                while left < right and nums[left] == nums[left + 1]:\n                    left += 1\n                # Move right pointer backward as long as it's a duplicate.\n                while left < right and nums[right] == nums[right - 1]:\n                    right -= 1\n                    \n                # Move pointers to the next unique elements.\n                left += 1\n                right -= 1\n            elif current_sum < 0:\n                # The sum is too small, so we need a larger number.\n                # Move the left pointer inward.\n                left += 1\n            else: # current_sum > 0\n                # The sum is too big, so we need a smaller number.\n                # Move the right pointer inward.\n                right -= 1\n                \n    return result\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N^2)**\n    The initial sort takes O(N log N). The main loop runs N times. Inside it, the two-pointer `while` loop traverses the remaining part of the array, which takes O(N) time in the worst case for each `i`. This gives us O(N log N + N^2), which simplifies to O(N^2) as it's the dominant term.\n\n*   **Space Complexity: O(log N) to O(N)**\n    This depends on the implementation of the sorting algorithm used. In Python, Timsort uses O(N) auxiliary space in the worst case. If we ignore the space required for the output list `result`, the space complexity is determined by the sort.\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - Converging** pattern, elevated by nesting it within a primary loop. The signals that point to this pattern are:\n\n1.  **Sorted Array:** The pattern relies fundamentally on the array being sorted. The need to find combinations often implies that sorting can structure the search space, which is the first hint.\n2.  **Target Sum:** The problem asks for a combination of elements (a triplet) that sum to a specific target (zero). This \"find a sum\" requirement is a classic use case for two pointers.\n3.  **Efficient Search:** The brute-force O(N^3) is clearly inefficient. After sorting and fixing one element `a`, the converging pointers (`left` starting from the beginning and `right` from the end) provide an O(N) method to search for the remaining pair `b` and `c`. The logic is simple and powerful: if the current sum is too small, only increasing the `left` pointer can help; if it's too large, only decreasing the `right` pointer can help. This systematic elimination of the search space is the hallmark of the pattern.\n\nBy recognizing that `3Sum` can be broken down into `N` instances of the `2Sum on a Sorted Array` problem, you can immediately identify it as a prime candidate for the Two Pointers pattern.",
    "description": "Study 3Sum using the Pattern 1: Two Pointers - Converging (Sorted Array Target Sum) approach.",
    "has_content": true
  },
  {
    "id": "problem_16",
    "number": 16,
    "title": "3Sum Closest",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)",
    "url": "https://leetcode.com/problems/3sum-closest/",
    "difficulty": "easy",
    "content": "---\n### **16. 3Sum Closest**\n**Link to Problem:** [https://leetcode.com/problems/3sum-closest/](https://leetcode.com/problems/3sum-closest/)\n\n#### **1. Problem Statement**\nGiven an array of integers `nums` and an integer `target`, the task is to find three integers in `nums` whose sum is closest to the `target`. You must return the sum of these three integers. It is guaranteed that each input will have exactly one solution.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to test every possible combination of three distinct numbers from the array. We can use three nested loops to iterate through all unique triplets. For each triplet, we calculate its sum and compare its absolute difference from the `target` with the smallest difference found so far. If the current triplet's sum is closer, we update our result.\n\n**Python Code:**\n```python\nimport math\n\nclass Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -> int:\n        # Initialize with a very large difference to ensure the first sum is always closer.\n        min_diff = math.inf\n        closest_sum = 0\n        n = len(nums)\n\n        # The first loop selects the first number of the triplet.\n        for i in range(n - 2):\n            # The second loop selects the second number, starting after the first.\n            for j in range(i + 1, n - 1):\n                # The third loop selects the third number, starting after the second.\n                for k in range(j + 1, n):\n                    current_sum = nums[i] + nums[j] + nums[k]\n                    current_diff = abs(target - current_sum)\n\n                    # If this triplet's sum is closer to the target, update our result.\n                    if current_diff < min_diff:\n                        min_diff = current_diff\n                        closest_sum = current_sum\n        \n        return closest_sum\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N³)**\n    This is due to the three nested loops, each of which can iterate up to N times, where N is the number of elements in `nums`. This approach is very slow for large inputs.\n\n*   **Space Complexity: O(1)**\n    We only use a few variables (`min_diff`, `closest_sum`, loop counters) for storage, regardless of the input size.\n\n#### **3. Optimized Approach: [Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)]**\n**Intuition:**\nThe brute-force O(N³) complexity is inefficient. We can significantly improve this by first sorting the array. Sorting allows us to use a more methodical approach to finding the other two numbers once we've fixed one.\n\nThis problem can be reduced to a \"2Sum Closest\" problem. We iterate through the array with a single loop, fixing one number at a time (`nums[i]`). For each `nums[i]`, our goal is to find two other numbers in the rest of the array (`nums[i+1:]`) whose sum, combined with `nums[i]`, is as close to the `target` as possible.\n\nThis is where the **Converging Two Pointers** pattern excels. For each `nums[i]`, we set up two pointers in the remaining part of the array: a `left` pointer at `i + 1` and a `right` pointer at the end of the array. We then calculate the sum of the triplet `(nums[i], nums[left], nums[right])`.\n\nBased on this sum, we can intelligently move the pointers:\n*   If `current_sum` < `target`, we need a larger sum. Since the array is sorted, we move the `left` pointer one step to the right to include a larger number.\n*   If `current_sum` > `target`, we need a smaller sum. We move the `right` pointer one step to the left to include a smaller number.\n*   If `current_sum` == `target`, we've found a sum with a difference of 0, which is the best possible result. We can return this sum immediately.\n\nWe repeat this process, converging the `left` and `right` pointers, until they cross.\n\n**Example:** `nums = [-1, 2, 1, -4]`, `target = 1`\n1.  **Sort `nums`:** `[-4, -1, 1, 2]`\n2.  Initialize `closest_sum` with the sum of the first three elements: `(-4) + (-1) + 1 = -4`. The initial minimum difference is `abs(1 - (-4)) = 5`.\n3.  **Outer loop `i = 0` (`nums[i] = -4`):**\n    *   `left = 1`, `right = 3`. Triplet: `(-4, -1, 2)`. Sum = `-3`.\n    *   Difference `abs(1 - (-3)) = 4`. This is better than 5, so `closest_sum` becomes `-3`.\n    *   Sum `-3` < `target` 1, so we need a larger sum. Increment `left`.\n    *   `left = 2`, `right = 3`. Triplet: `(-4, 1, 2)`. Sum = `-1`.\n    *   Difference `abs(1 - (-1)) = 2`. This is better than 4, so `closest_sum` becomes `-1`.\n    *   Sum `-1` < `target` 1, so increment `left`. Now `left` equals `right`, ending the inner loop.\n4.  **Outer loop `i = 1` (`nums[i] = -1`):**\n    *   `left = 2`, `right = 3`. Triplet: `(-1, 1, 2)`. Sum = `2`.\n    *   Difference `abs(1 - 2) = 1`. This is better than 2, so `closest_sum` becomes `2`.\n    *   Sum `2` > `target` 1, so we need a smaller sum. Decrement `right`. Now `left` equals `right`, ending the inner loop.\n5.  The outer loop finishes. The final `closest_sum` is **2**.\n\n**Python Code:**\n```python\nimport math\n\nclass Solution:\n    def threeSumClosest(self, nums: list[int], target: int) -> int:\n        # Sorting is crucial for the two-pointer approach.\n        nums.sort()\n        \n        min_diff = math.inf\n        closest_sum = 0\n        n = len(nums)\n\n        # Main loop to fix the first element of the triplet.\n        for i in range(n - 2):\n            # Initialize two pointers for the rest of the array.\n            left = i + 1\n            right = n - 1\n\n            # The two pointers converge towards each other.\n            while left < right:\n                current_sum = nums[i] + nums[left] + nums[right]\n                \n                # Check if the current sum is closer to the target.\n                current_diff = abs(target - current_sum)\n                if current_diff < min_diff:\n                    min_diff = current_diff\n                    closest_sum = current_sum\n                \n                # --- Core logic of the Two Pointers pattern ---\n                # Move pointers based on the comparison with the target.\n                if current_sum < target:\n                    # If the sum is too small, move the left pointer to a larger value.\n                    left += 1\n                elif current_sum > target:\n                    # If the sum is too large, move the right pointer to a smaller value.\n                    right -= 1\n                else:\n                    # If the sum is exactly the target, we've found the best possible answer.\n                    return target\n        \n        return closest_sum\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N²)**\n    The initial sort costs O(N log N). The main logic consists of a `for` loop that runs N times, and inside it, a `while` loop with two pointers that traverse the rest of the array. This inner traversal takes O(N) time. Therefore, the total time complexity is O(N log N + N²), which simplifies to O(N²).\n\n*   **Space Complexity: O(log N) to O(N)**\n    This depends on the space complexity of the sorting algorithm used by the Python environment. Timsort, Python's default, can take up to O(N) space in the worst case. If we disregard the space for sorting, the algorithm itself uses O(1) extra space.\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - Converging** pattern for several key reasons:\n\n1.  **Sorted Array Prerequisite:** The pattern's effectiveness hinges on the array being sorted. Sorting allows us to make a directional decision: if our sum is too small, we *know* we must move the left pointer rightward to a larger number. This sorted property is the primary signal to consider a two-pointer approach.\n\n2.  **Finding a Combination with a Target Property:** The core task is to find a triplet (a specific combination of elements) that satisfies a condition related to a `target`. The two-pointer pattern is highly efficient for searching for pairs or triplets that meet sum-related criteria in a sorted array.\n\n3.  **Reduction of Search Space:** By fixing one element with an outer loop, the problem is simplified to finding the best *pair* in a sub-array. The two pointers, starting at opposite ends and converging, systematically and efficiently eliminate possibilities. Instead of a brute-force O(N²) check for the pair, this pattern finds the best pair in just O(N) time, leading to the overall O(N²) solution for the 3Sum problem.\n\nWhenever you encounter a problem that involves finding triplets, quadruplets, or pairs in an array that sum up to a target value, and constraints allow for an O(N²) or O(N³) solution, your first thought should be to **sort the array and apply the two-pointers pattern**. This problem extends the classic \"2Sum\" pattern by wrapping it in an outer loop, a very common and powerful technique.",
    "description": "Study 3Sum Closest using the Pattern 1: Two Pointers - Converging (Sorted Array Target Sum) approach.",
    "has_content": true
  },
  {
    "id": "problem_17",
    "number": 17,
    "title": "Letter Combinations of a Phone Number",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 41: Backtracking - Subsets (Include/Exclude)",
    "url": "https://leetcode.com/problems/letter-combinations-of-a-phone-number/",
    "difficulty": "easy",
    "content": "# Letter Combinations of a Phone Number\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Letter Combinations of a Phone Number](https://leetcode.com/problems/letter-combinations-of-a-phone-number/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 41: Backtracking - Subsets (Include/Exclude)",
    "description": "Study Letter Combinations of a Phone Number using the Pattern 41: Backtracking - Subsets (Include/Exclude) approach.",
    "has_content": false
  },
  {
    "id": "problem_18",
    "number": 18,
    "title": "4Sum",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)",
    "url": "https://leetcode.com/problems/4sum/",
    "difficulty": "easy",
    "content": "---\n### **18. 4Sum**\n**Link to Problem:** [https://leetcode.com/problems/4sum/](https://leetcode.com/problems/4sum/)\n\n#### **1. Problem Statement**\nGiven an array `nums` of `n` integers and a target integer `target`, the task is to find all unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that their sum equals the `target`. The solution set must not contain duplicate quadruplets.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to test every possible combination of four distinct numbers from the array. We can achieve this by using four nested loops, where each loop iterates through the array to pick one number. The outer loop picks the first number, the second loop picks the second number from the remaining part of the array, and so on.\n\nInside the innermost loop, we check if the sum of the four selected numbers equals the `target`. A major challenge is handling duplicate quadruplets in the output. For example, if the input is `[2, 2, 2, 2, 2]` and the target is 8, `[2, 2, 2, 2]` is the only unique answer. To solve this, we can sort each valid quadruplet before adding it to a `set` data structure, which automatically handles uniqueness.\n\n**Python Code:**\n```python\ndef fourSum_brute_force(nums: list[int], target: int) -> list[list[int]]:\n    n = len(nums)\n    if n < 4:\n        return []\n    \n    # Use a set of tuples to automatically handle uniqueness of quadruplets.\n    result_set = set()\n    \n    # Four nested loops to check every combination of four numbers.\n    for i in range(n):\n        for j in range(i + 1, n):\n            for k in range(j + 1, n):\n                for l in range(k + 1, n):\n                    # If the sum of the four numbers equals the target...\n                    if nums[i] + nums[j] + nums[k] + nums[l] == target:\n                        # ...create a quadruplet, sort it to handle permutation duplicates\n                        # (e.g., [1, 2] and [2, 1] become the same),\n                        # and add it to the set as a tuple.\n                        quadruplet = sorted([nums[i], nums[j], nums[k], nums[l]])\n                        result_set.add(tuple(quadruplet))\n                        \n    # Convert the set of tuples back to a list of lists.\n    return [list(q) for q in result_set]\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N⁴)**\n    This is due to the four nested loops, each iterating up to `N` times, where `N` is the number of elements in `nums`. The sorting and set insertion inside the loop take negligible time compared to the nested loops.\n\n*   **Space Complexity: O(M)**\n    Where `M` is the number of unique quadruplets found. The space is used to store the `result_set`. In the worst case, the number of quadruplets can be large.\n\n---\n### **3. Optimized Approach: [Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)]**\n**Intuition:**\nThe O(N⁴) complexity of the brute-force approach is too slow for larger inputs. We can significantly improve this by reducing the problem's dimensionality. The core idea is to generalize the solution for 2Sum and 3Sum. We can fix two numbers with two outer loops and then use the **Two Pointers - Converging** pattern to find the remaining two numbers.\n\nHere's the step-by-step logic:\n1.  **Sort the Array:** First, sort the input array `nums`. This is a critical prerequisite for the two-pointer pattern to work and also makes it much easier to handle duplicates.\n2.  **Outer Loops (Fixing Two Numbers):** Iterate through the array with a first loop for the first number (`i`) and a nested second loop for the second number (`j`).\n3.  **Reduce to 2Sum:** For each pair `(nums[i], nums[j])`, our problem becomes finding two other numbers in the rest of the array that sum up to `new_target = target - nums[i] - nums[j]`. This is now a classic 2Sum problem on a sorted subarray.\n4.  **Converging Pointers:** We apply the two-pointer pattern on the subarray starting from `j + 1`.\n    *   Initialize a `left` pointer to `j + 1`.\n    *   Initialize a `right` pointer to the end of the array, `n - 1`.\n    *   While `left < right`, calculate `current_sum = nums[left] + nums[right]`.\n        *   If `current_sum == new_target`, we've found a valid quadruplet: `[nums[i], nums[j], nums[left], nums[right]]`. We add it to our results.\n        *   If `current_sum < new_target`, we need a larger sum. We move the `left` pointer one step to the right (`left += 1`) to include a larger number.\n        *   If `current_sum > new_target`, we need a smaller sum. We move the `right` pointer one step to the left (`right -= 1`) to include a smaller number.\n5.  **Skip Duplicates:** Since the array is sorted, duplicates are grouped together.\n    *   To avoid duplicate quadruplets, if we find a valid solution, we must advance the `left` and `right` pointers past all identical subsequent elements.\n    *   Similarly, in the outer loops, we must skip subsequent identical elements for `i` and `j` to avoid processing the same starting pairs.\n\n**Example Walkthrough:**\n`nums = [1, 0, -1, 0, -2, 2]`, `target = 0`\n1.  **Sort:** `nums` becomes `[-2, -1, 0, 0, 1, 2]`.\n2.  **Outer loop `i = 0`**, `nums[i] = -2`.\n3.  **Inner loop `j = 1`**, `nums[j] = -1`. `new_target = 0 - (-2) - (-1) = 3`.\n    *   We now need to find two numbers that sum to 3 in `[0, 0, 1, 2]`.\n    *   `left = 2` (`nums[left] = 0`), `right = 5` (`nums[right] = 2`).\n    *   `current_sum = 0 + 2 = 2`. Since `2 < 3`, we need a larger sum. `left++`.\n    *   `left = 3` (`nums[left] = 0`), `right = 5` (`nums[right] = 2`).\n    *   `current_sum = 0 + 2 = 2`. Since `2 < 3`, `left++`.\n    *   `left = 4` (`nums[left] = 1`), `right = 5` (`nums[right] = 2`).\n    *   `current_sum = 1 + 2 = 3`. This matches `new_target`. We found a quadruplet: `[-2, -1, 1, 2]`. Add to results.\n    *   Increment `left` and decrement `right`. The pointers cross, so this inner 2Sum loop ends.\n4.  The loops for `i` and `j` continue, skipping duplicates along the way, until all combinations are explored.\n\n**Python Code:**\n```python\ndef fourSum(nums: list[int], target: int) -> list[list[int]]:\n    n = len(nums)\n    if n < 4:\n        return []\n    \n    # Step 1: Sort the array. This is crucial for the two-pointer approach and for skipping duplicates.\n    nums.sort()\n    \n    result = []\n    \n    # Step 2: Outer loop to fix the first number of the quadruplet.\n    for i in range(n - 3):\n        # Skip duplicates for the first number.\n        if i > 0 and nums[i] == nums[i-1]:\n            continue\n            \n        # Step 3: Inner loop to fix the second number.\n        for j in range(i + 1, n - 2):\n            # Skip duplicates for the second number.\n            if j > i + 1 and nums[j] == nums[j-1]:\n                continue\n            \n            # Step 4: Reduce to a 2Sum problem and apply the converging two-pointer pattern.\n            left = j + 1\n            right = n - 1\n            \n            while left < right:\n                current_sum = nums[i] + nums[j] + nums[left] + nums[right]\n                \n                if current_sum == target:\n                    # Found a valid quadruplet.\n                    result.append([nums[i], nums[j], nums[left], nums[right]])\n                    \n                    # Pointer moves inward to search for the next unique pair.\n                    left += 1\n                    right -= 1\n                    \n                    # Step 5: Skip any duplicates for the third and fourth numbers.\n                    while left < right and nums[left] == nums[left - 1]:\n                        left += 1\n                    while left < right and nums[right] == nums[right + 1]:\n                        right -= 1\n                        \n                elif current_sum < target:\n                    # The sum is too small, we need a larger number.\n                    # The left pointer moves inward (to the right).\n                    left += 1\n                else: # current_sum > target\n                    # The sum is too large, we need a smaller number.\n                    # The right pointer moves inward (to the left).\n                    right -= 1\n                    \n    return result\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N³)**\n    The initial sort takes O(N log N). The main work is done in the nested loops. The outer loop runs `N` times, the second loop runs `N` times, and the inner `while` loop (the two-pointer part) runs in O(N) time. This results in a total complexity of O(N * N * N) = O(N³). The O(N³) term dominates the initial sort.\n\n*   **Space Complexity: O(log N) to O(N)**\n    This depends on the space used by the sorting algorithm. Python's Timsort can use up to O(N) space in the worst case. If we ignore the space required for the output list, the auxiliary space complexity is determined by the sort.\n\n---\n#### **4. Pattern Connection**\nThis problem is a classic extension of the `K-Sum` problem category and perfectly demonstrates how to chain simpler patterns to solve a more complex problem. The key to solving `4Sum` efficiently lies in reducing it to a `2Sum` problem, which is the canonical use case for the **Two Pointers - Converging** pattern.\n\nThe signals that point to this pattern are:\n1.  **Target Sum:** The problem asks for a combination of elements that sum up to a specific target value.\n2.  **Sorted Array:** The pattern requires a sorted array to work. While the input isn't sorted, sorting it is a valid and necessary first step that enables the linear-time two-pointer scan.\n3.  **High-Complexity Brute Force:** A brute-force solution with many nested loops (O(N⁴)) is too slow, signaling the need for a more optimized approach like reducing the problem's dimensionality.\n\nBy fixing the first two numbers, we create a subproblem: \"find two numbers in a sorted subarray that sum to a value.\" This is the exact scenario where the converging two-pointer technique shines. It systematically explores all possible pairs in the subarray in a single O(N) pass by starting at opposite ends and moving inwards, efficiently closing the search window based on whether the current sum is too small or too large. Mastering this K-Sum to 2-Sum reduction is fundamental to solving many similar problems.",
    "description": "Study 4Sum using the Pattern 1: Two Pointers - Converging (Sorted Array Target Sum) approach.",
    "has_content": true
  },
  {
    "id": "problem_19",
    "number": 19,
    "title": "Remove Nth Node From End of List",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 3: Two Pointers - Fixed Separation (Nth Node from End)",
    "url": "https://leetcode.com/problems/remove-nth-node-from-end-of-list/",
    "difficulty": "easy",
    "content": "---\n### **19. Remove Nth Node From End of List**\n**Link to Problem:** [https://leetcode.com/problems/remove-nth-node-from-end-of-list/](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)\n\n#### **1. Problem Statement**\nGiven the `head` of a singly linked list and an integer `n`, the task is to remove the node that is `n` positions away from the end of the list. The function should then return the head of the potentially modified linked list.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most direct way to solve this is to realize that \"nth from the end\" is equivalent to \"(Length - n + 1)th from the beginning\". This insight suggests a two-pass algorithm:\n\n1.  **First Pass:** Traverse the entire linked list once to calculate its total length, let's call it `L`.\n2.  **Second Pass:** Calculate the position of the node to remove from the start: `target_pos = L - n`. To remove this node, we actually need to stop at the node *before* it. So, we traverse the list again from the `head`, stopping `target_pos - 1` times to reach the predecessor of the node we want to delete.\n3.  **Deletion:** Once at the predecessor node, we update its `next` pointer to skip over the target node, effectively removing it from the list.\n\nA small but important edge case is removing the head of the list itself (when `L == n`). Using a \"dummy\" or \"sentinel\" node that points to the original head simplifies this logic, as it ensures every node to be deleted has a predecessor.\n\n**Python Code:**\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        # A dummy node helps handle the edge case of removing the actual head node.\n        dummy = ListNode(0, head)\n        \n        # --- First Pass: Calculate the length of the list ---\n        length = 0\n        current = head\n        while current:\n            length += 1\n            current = current.next\n            \n        # --- Calculate position of the predecessor node ---\n        # The node to remove is at position (length - n) from the start (0-indexed).\n        # We need to traverse to the node *before* it.\n        # So we start at the dummy and traverse (length - n) times.\n        prev = dummy\n        for _ in range(length - n):\n            prev = prev.next\n            \n        # --- Second Pass: Remove the target node ---\n        # prev is now the node just before the one we want to remove.\n        # We bypass the target node by linking prev directly to the target's next node.\n        if prev and prev.next:\n            prev.next = prev.next.next\n            \n        # The dummy's next pointer points to the potentially new head of the list.\n        return dummy.next\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(L)`, where `L` is the number of nodes in the list. We traverse the list twice: once to find the length (`L` steps) and once to find the predecessor node (`L-n` steps). This simplifies to `O(2L)`, which is `O(L)`.\n*   **Space Complexity:** `O(1)`. We only use a few extra pointers (`dummy`, `current`, `prev`), so the space used is constant.\n\n### **3. Optimized Approach: [Pattern 3: Two Pointers - Fixed Separation (Nth Node from End)]**\n**Intuition:**\nThe brute-force approach requires two passes because we don't know where the end of the list is relative to a given node. The Two Pointers pattern allows us to solve this in a single pass. The key idea is to create a \"fixed separation\" or \"gap\" between two pointers.\n\n1.  Initialize two pointers, `slow` and `fast`. For easier deletion, we'll start `slow` at a `dummy` node pointing to the head, and `fast` at the actual `head`.\n2.  **Create the Gap:** First, we move the `fast` pointer `n` steps ahead into the list. Now, `fast` is `n` nodes ahead of `slow` (if we count the `dummy` node). This establishes our fixed separation.\n3.  **Move in Tandem:** Next, we advance both `slow` and `fast` one step at a time. They move in parallel, maintaining their fixed separation.\n4.  **Find the Target:** We continue this until the `fast` pointer reaches the end of the list (i.e., it becomes `None`). Because of the initial `n`-node gap, when `fast` is at the end, `slow` will be positioned exactly at the node *before* the nth node from the end.\n5.  **Deletion:** We can now perform the deletion easily: `slow.next = slow.next.next`.\n\n**Example:** `head = [1,2,3,4,5]`, `n = 2`. We want to remove `4`.\n\n*   `dummy -> 1 -> 2 -> 3 -> 4 -> 5`\n*   `slow` starts at `dummy`, `fast` starts at `1`.\n*   Move `fast` `n=2` steps: `fast` is now at `3`.\n*   Move both until `fast` is `None`:\n    *   `slow` -> `1`, `fast` -> `4`\n    *   `slow` -> `2`, `fast` -> `5`\n    *   `slow` -> `3`, `fast` -> `None`\n*   `fast` is `None`. `slow` is at `3`. The node to remove is `slow.next` (which is `4`). Perfect.\n*   We set `3.next = 5`. The list becomes `[1,2,3,5]`.\n\n**Python Code:**\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def removeNthFromEnd(self, head: Optional[ListNode], n: int) -> Optional[ListNode]:\n        # A dummy node handles the edge case of removing the head node.\n        dummy = ListNode(0, head)\n        slow = dummy\n        fast = head  # Start fast at the actual head\n        \n        # --- Phase 1: Create a fixed separation between slow and fast ---\n        # Move the fast pointer n steps ahead.\n        # This creates a gap of 'n' nodes between fast and where slow originally pointed (head).\n        for _ in range(n):\n            fast = fast.next\n            \n        # --- Phase 2: Move both pointers in tandem until fast reaches the end ---\n        # While fast is not None, both pointers advance one step.\n        # When 'fast' reaches the end (None), 'slow' will be perfectly\n        # positioned just before the node we need to remove.\n        while fast:\n            slow = slow.next\n            fast = fast.next\n            \n        # --- Phase 3: Remove the target node ---\n        # 'slow' is now at the node just before the nth node from the end.\n        # We bypass the target by updating the 'next' pointer.\n        slow.next = slow.next.next\n        \n        # The dummy's 'next' still points to the head of the modified list.\n        return dummy.next\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(L)`. The pointers traverse the list only once. The `fast` pointer goes from `head` to `None`, and `slow` follows for a portion of that journey. This is a single-pass solution.\n*   **Space Complexity:** `O(1)`. We only use a constant number of extra variables (`dummy`, `slow`, `fast`).\n\n#### **4. Pattern Connection**\nThis problem is a canonical example of the **Two Pointers - Fixed Separation** pattern. This pattern is signaled whenever a problem requires you to find a node or element that is a fixed distance `k` away from another element or, as in this case, from the end of a sequence, especially when you can't easily index from the end (like in a singly linked list).\n\nThe brute-force method's need for a preliminary pass to find the total length is the key inefficiency this pattern resolves. Instead of calculating the length `L` to determine the target position `L - n`, the pattern cleverly creates a physical gap of `n` nodes between two pointers. By moving these pointers in unison, this \"gap\" acts as a moving measurement tool. When the leading pointer (`fast`) reaches a known landmark (the end of the list), the trailing pointer's (`slow`) position is determined by that gap, landing it exactly where it needs to be to solve the problem in a single, efficient pass.",
    "description": "Study Remove Nth Node From End of List using the Pattern 3: Two Pointers - Fixed Separation (Nth Node from End) approach.",
    "has_content": true
  },
  {
    "id": "problem_20",
    "number": 20,
    "title": "Valid Parentheses",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 58: Stack - Valid Parentheses Matching",
    "url": "https://leetcode.com/problems/valid-parentheses/",
    "difficulty": "easy",
    "content": "# Valid Parentheses\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Valid Parentheses](https://leetcode.com/problems/valid-parentheses/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 58: Stack - Valid Parentheses Matching",
    "description": "Study Valid Parentheses using the Pattern 58: Stack - Valid Parentheses Matching approach.",
    "has_content": false
  },
  {
    "id": "problem_21",
    "number": 21,
    "title": "Merge Two Sorted Lists",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 70: Linked List - Merging Two Sorted Lists",
    "url": "https://leetcode.com/problems/merge-two-sorted-lists/",
    "difficulty": "easy",
    "content": "# Merge Two Sorted Lists\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Merge Two Sorted Lists](https://leetcode.com/problems/merge-two-sorted-lists/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 70: Linked List - Merging Two Sorted Lists",
    "description": "Study Merge Two Sorted Lists using the Pattern 70: Linked List - Merging Two Sorted Lists approach.",
    "has_content": false
  },
  {
    "id": "problem_22",
    "number": 22,
    "title": "Generate Parentheses",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 44: Backtracking - Parentheses Generation",
    "url": "https://leetcode.com/problems/generate-parentheses/",
    "difficulty": "easy",
    "content": "# Generate Parentheses\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Generate Parentheses](https://leetcode.com/problems/generate-parentheses/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 44: Backtracking - Parentheses Generation",
    "description": "Study Generate Parentheses using the Pattern 44: Backtracking - Parentheses Generation approach.",
    "has_content": false
  },
  {
    "id": "problem_23",
    "number": 23,
    "title": "Merge k Sorted Lists",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 39: Heap - K-way Merge",
    "url": "https://leetcode.com/problems/merge-k-sorted-lists/",
    "difficulty": "easy",
    "content": "# Merge k Sorted Lists\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Merge k Sorted Lists](https://leetcode.com/problems/merge-k-sorted-lists/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 39: Heap - K-way Merge",
    "description": "Study Merge k Sorted Lists using the Pattern 39: Heap - K-way Merge approach.",
    "has_content": false
  },
  {
    "id": "problem_24",
    "number": 24,
    "title": "Swap Nodes in Pairs",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 73: Linked List - Reordering / Partitioning",
    "url": "https://leetcode.com/problems/swap-nodes-in-pairs/",
    "difficulty": "easy",
    "content": "# Swap Nodes in Pairs\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Swap Nodes in Pairs](https://leetcode.com/problems/swap-nodes-in-pairs/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 73: Linked List - Reordering / Partitioning",
    "description": "Study Swap Nodes in Pairs using the Pattern 73: Linked List - Reordering / Partitioning approach.",
    "has_content": false
  },
  {
    "id": "problem_25",
    "number": 25,
    "title": "Reverse Nodes in k-Group",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 69: Linked List - In-place Reversal",
    "url": "https://leetcode.com/problems/reverse-nodes-in-k-group/",
    "difficulty": "easy",
    "content": "# Reverse Nodes in k-Group\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Reverse Nodes in k-Group](https://leetcode.com/problems/reverse-nodes-in-k-group/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 69: Linked List - In-place Reversal",
    "description": "Study Reverse Nodes in k-Group using the Pattern 69: Linked List - In-place Reversal approach.",
    "has_content": false
  },
  {
    "id": "problem_26",
    "number": 26,
    "title": "Remove Duplicates from Sorted Array",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 4: Two Pointers - In-place Array Modification",
    "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array/",
    "difficulty": "easy",
    "content": "---\n### **26. Remove Duplicates from Sorted Array**\n**Link to Problem:** [https://leetcode.com/problems/remove-duplicates-from-sorted-array/](https://leetcode.com/problems/remove-duplicates-from-sorted-array/)\n\n#### **1. Problem Statement**\nGiven an integer array `nums` that is sorted in non-decreasing order, the task is to remove the duplicate elements *in-place*. This means each unique element should appear only once, and the relative order of the unique elements must be preserved. The function should return `k`, the number of unique elements, and the first `k` elements of the `nums` array should be modified to contain these unique elements.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nA common first thought for removing duplicates is to use a data structure that inherently stores only unique items, like a `set`. We could iterate through the input array, add all elements to a set to automatically handle duplicates, and then overwrite the original array with the unique elements from the set. However, since the problem requires the order to be preserved and the array is already sorted, a simpler approach is to create a new list, iterate through the input, and only add an element to our new list if it's different from the last element we added. Finally, we'd copy this new list back into the original `nums` array.\n\nThis approach is straightforward but violates the problem's core constraint of performing the operation **in-place** with O(1) extra memory.\n\n**Python Code:**\n```python\ndef removeDuplicates_brute_force(nums: list[int]) -> int:\n    # This approach is not truly in-place and uses O(N) extra space,\n    # making it a good example of what not to do when faced with this constraint.\n    if not nums:\n        return 0\n\n    # Use a new list to store unique elements while preserving order.\n    unique_elements = []\n    unique_elements.append(nums[0]) # The first element is always unique to start.\n\n    for i in range(1, len(nums)):\n        # If the current element is different from the last one added, it's unique.\n        if nums[i] != unique_elements[-1]:\n            unique_elements.append(nums[i])\n\n    # Now, copy the unique elements back into the original array.\n    # This is required to modify the input array as requested by the problem.\n    for i in range(len(unique_elements)):\n        nums[i] = unique_elements[i]\n        \n    return len(unique_elements)\n\n# Example:\n# nums = [0, 0, 1, 1, 1, 2, 2]\n# unique_elements becomes [0, 1, 2]\n# nums is modified to [0, 1, 2, 1, 1, 2, 2]\n# The function returns 3. The caller only considers nums[:3].\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    This is because we iterate through the input array once to build our `unique_elements` list (O(N)) and then iterate through the `unique_elements` list to modify the original `nums` array (O(k), where k ≤ N). This results in a total time complexity of O(N).\n\n*   **Space Complexity: O(N)**\n    The primary drawback is the `unique_elements` list, which in the worst case (an array with all unique elements) will grow to the same size as the input array `nums`. This violates the O(1) extra space constraint.\n\n### **3. Optimized Approach: Two Pointers - In-place Array Modification**\n**Intuition:**\nTo solve this efficiently and in-place, we can use the **Two Pointer** technique. The key insight is that since the array is sorted, all duplicate elements will be grouped together. We can use this property to overwrite the duplicates with the next unique elements we find.\n\nWe'll define two pointers:\n1.  **`slow` (or `write_pointer`)**: This pointer keeps track of the position where the next unique element should be placed. It starts at index 1 because the first element `nums[0]` is always considered unique and stays in its place.\n2.  **`fast` (or `read_pointer`)**: This pointer scans the array from the second element (`index = 1`) onwards to find new, unique elements.\n\nThe algorithm works as follows: The `fast` pointer iterates through the array. At each step, we compare `nums[fast]` with the previous element `nums[fast - 1]`.\n*   If `nums[fast]` is **the same** as `nums[fast - 1]`, it's a duplicate. We do nothing but increment the `fast` pointer to move on.\n*   If `nums[fast]` is **different** from `nums[fast - 1]`, it's a unique element. We then copy its value to the position indicated by our `slow` pointer (`nums[slow] = nums[fast]`) and then increment the `slow` pointer to prepare for the next unique element.\n\nLet's walk through an example: `nums = [0, 0, 1, 1, 2]`\n- **Initial State:** `slow = 1`, `fast = 1`\n- **`fast = 1`**: `nums[1]` (0) is equal to `nums[0]` (0). Duplicate. `fast` increments.\n  - `nums` is `[0, 0, 1, 1, 2]`, `slow = 1`\n- **`fast = 2`**: `nums[2]` (1) is not equal to `nums[1]` (0). Unique!\n  - Copy `nums[fast]` to `nums[slow]`: `nums[1] = 1`.\n  - Increment `slow` to 2.\n  - `nums` is `[0, 1, 1, 1, 2]`, `slow = 2`\n- **`fast = 3`**: `nums[3]` (1) is equal to `nums[2]` (1). Duplicate. `fast` increments.\n  - `nums` is `[0, 1, 1, 1, 2]`, `slow = 2`\n- **`fast = 4`**: `nums[4]` (2) is not equal to `nums[3]` (1). Unique!\n  - Copy `nums[fast]` to `nums[slow]`: `nums[2] = 2`.\n  - Increment `slow` to 3.\n  - `nums` is `[0, 1, 2, 1, 2]`, `slow = 3`\n\nThe loop finishes. The final value of `slow` is 3, which is the number of unique elements. The first `slow` elements of `nums` are `[0, 1, 2]`.\n\n**Python Code:**\n```python\ndef removeDuplicates(nums: list[int]) -> int:\n    # If the list is empty, there are no unique elements.\n    if not nums:\n        return 0\n\n    # 'slow' pointer indicates the next position to write a unique element.\n    # It starts at 1 because nums[0] is always in its correct place.\n    slow = 1\n\n    # 'fast' pointer iterates through the array to find unique elements.\n    for fast in range(1, len(nums)):\n        # Check if the current element is a new unique element.\n        # Since the array is sorted, a new unique element is one that is\n        # different from its immediate predecessor.\n        if nums[fast] != nums[fast - 1]:\n            # If it's unique, we place it at the 'slow' pointer's position.\n            nums[slow] = nums[fast]\n            \n            # Move the slow pointer forward to mark the new end of the unique subarray.\n            slow += 1\n            \n    # 'slow' now holds the count of unique elements, which is the new length.\n    return slow\n\n# Example:\n# nums = [0, 0, 1, 1, 1, 2, 2, 3, 3, 4]\n# removeDuplicates(nums) returns 5\n# nums becomes [0, 1, 2, 3, 4, 2, 2, 3, 3, 4] (the content beyond index 4 doesn't matter)\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    This is because the `fast` pointer traverses the array from the second element to the end exactly once. The `slow` pointer also moves forward but never exceeds the `fast` pointer. This gives us a single pass through the array.\n\n*   **Space Complexity: O(1)**\n    The algorithm is performed entirely in-place. We only use two integer variables (`slow` and `fast`) for the pointers, which is constant extra space regardless of the input array's size.\n\n#### **4. Pattern Connection**\nThis problem is a classic example of the **Two Pointers - In-place Array Modification** pattern. The pattern is signaled by several key problem characteristics:\n\n1.  **Input is a Sorted Array:** The sorted nature is the most critical clue. It ensures that duplicate elements are adjacent, allowing a linear scan to be effective. If the array were unsorted, we couldn't simply compare an element to its predecessor to check for uniqueness.\n2.  **In-place Modification Required:** The problem explicitly forbids using extra space proportional to the input size (O(1) space complexity). This immediately pushes you to think about how to overwrite parts of the array itself.\n3.  **Partitioning Logic:** The core task involves conceptually partitioning the array into two sections: the beginning part with the processed, unique elements, and the remaining part with elements yet to be considered. The `slow` pointer acts as the boundary for this partition, while the `fast` pointer ventures into the unprocessed section to find the next item to bring into the \"clean\" partition.\n\nThis pattern, often called the \"slow and fast runner\" technique, is fundamental for problems where you need to process an array and produce a result in the same array, effectively removing or rearranging elements based on some condition.",
    "description": "Study Remove Duplicates from Sorted Array using the Pattern 4: Two Pointers - In-place Array Modification approach.",
    "has_content": true
  },
  {
    "id": "problem_27",
    "number": 27,
    "title": "Remove Element",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 4: Two Pointers - In-place Array Modification",
    "url": "https://leetcode.com/problems/remove-element/",
    "difficulty": "easy",
    "content": "---\n### **27. Remove Element**\n**Link to Problem:** [https://leetcode.com/problems/remove-element/](https://leetcode.com/problems/remove-element/)\n\n#### **1. Problem Statement**\nGiven an integer array `nums` and an integer `val`, the task is to remove all occurrences of `val` from `nums` **in-place**. The function should return `k`, which is the number of elements remaining in the array after removal. The first `k` elements of the `nums` array must contain the final result, and the order of these `k` elements can be different from their original order.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to iterate through the array and whenever we find an element that needs to be removed, we shift all subsequent elements one position to the left to \"overwrite\" it. This effectively removes the element and shortens the logical size of the array. We need to be careful when managing our loop index and the array's changing size.\n\n**Python Code:**\n```python\ndef removeElement_brute_force(nums: list[int], val: int) -> int:\n    # 'i' is our main iterator, and 'n' is the effective size of the array.\n    i = 0\n    n = len(nums)\n    \n    while i < n:\n        # If we find the element to remove...\n        if nums[i] == val:\n            # ...we shift every element after it one position to the left.\n            # This is an expensive operation.\n            for j in range(i + 1, n):\n                nums[j - 1] = nums[j]\n            \n            # Since we've shifted the array, the effective size decreases by one.\n            n -= 1\n            \n            # We do NOT increment 'i' here, because the new element at nums[i]\n            # needs to be checked as well. It could also be 'val'.\n        else:\n            # If the current element is not 'val', it's fine. Move to the next one.\n            i += 1\n            \n    # 'n' now holds the count of elements that are not 'val'.\n    return n\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N^2)**\n    This is because in the worst-case scenario (an array where every element is `val`), the outer `while` loop runs up to `N` times. For each of these iterations, the inner `for` loop (the shifting operation) also runs up to `N` times, leading to a quadratic time complexity.\n\n*   **Space Complexity: O(1)**\n    The modification is done in-place, and we only use a few variables (`i`, `n`, `j`) for storage, which does not scale with the input size.\n\n#### **3. Optimized Approach: Two Pointers - In-place Array Modification**\n**Intuition:**\nThe brute-force approach is slow due to the costly O(N) shifting operation performed for every element we remove. We can eliminate this shifting by using a **two-pointer** technique.\n\nThe core idea is to partition the array into two sections:\n1.  The beginning of the array (from `0` to `k-1`) will store the elements we want to keep.\n2.  The rest of the array can be considered a \"scratchpad\" or ignored.\n\nWe'll use two pointers:\n*   A \"slow\" pointer, let's call it `k` (or `write_pointer`), which keeps track of the next position to place an element we want to keep. It starts at index 0.\n*   A \"fast\" pointer, let's call it `i` (or `read_pointer`), which iterates through the entire array to inspect every element.\n\nThe `fast` pointer (`i`) moves from left to right. When `nums[i]` is an element we want to **keep** (i.e., `nums[i] != val`), we copy its value to the `slow` pointer's position (`nums[k] = nums[i]`) and then advance the slow pointer (`k += 1`). If `nums[i]` is an element we want to **remove** (i.e., `nums[i] == val`), we simply ignore it and only advance the `fast` pointer.\n\nLet's walk through an example: `nums = [0, 1, 2, 2, 3, 0, 4, 2]`, `val = 2`.\n\n1.  Initialize `k = 0`.\n2.  `i = 0`, `nums[0] = 0`. Not `val`. Copy `nums[0]` to `nums[k]`. `nums` becomes `[0, ...]`. Increment `k` to 1.\n3.  `i = 1`, `nums[1] = 1`. Not `val`. Copy `nums[1]` to `nums[k]`. `nums` becomes `[0, 1, ...]`. Increment `k` to 2.\n4.  `i = 2`, `nums[2] = 2`. This is `val`. Ignore it. `k` remains 2.\n5.  `i = 3`, `nums[3] = 2`. This is `val`. Ignore it. `k` remains 2.\n6.  `i = 4`, `nums[4] = 3`. Not `val`. Copy `nums[4]` to `nums[k]`. `nums` becomes `[0, 1, 3, ...]`. Increment `k` to 3.\n7.  `i = 5`, `nums[5] = 0`. Not `val`. Copy `nums[5]` to `nums[k]`. `nums` becomes `[0, 1, 3, 0, ...]`. Increment `k` to 4.\n8.  `i = 6`, `nums[6] = 4`. Not `val`. Copy `nums[6]` to `nums[k]`. `nums` becomes `[0, 1, 3, 0, 4, ...]`. Increment `k` to 5.\n9.  `i = 7`, `nums[7] = 2`. This is `val`. Ignore it. `k` remains 5.\n\nThe loop finishes. We return `k = 5`. The first 5 elements of `nums` are now `[0, 1, 3, 0, 4]`.\n\n**Python Code:**\n```python\ndef removeElement(nums: list[int], val: int) -> int:\n    # 'k' is the slow-runner. It marks the boundary of the processed, valid part of the array.\n    # Everything to the left of 'k' is an element we want to keep.\n    k = 0\n    \n    # 'i' is the fast-runner. It iterates through the entire array to inspect each element.\n    for i in range(len(nums)):\n        # If the element at the fast-runner is NOT the one we want to remove...\n        if nums[i] != val:\n            # ...we copy it to the position of the slow-runner.\n            # This overwrites any 'val' elements that were there or simply rewrites\n            # the same element if no 'val's have been found yet.\n            nums[k] = nums[i]\n            \n            # We then advance the slow-runner to expand our \"valid\" subarray.\n            k += 1\n            \n    # At the end, 'k' is the count of elements that are not 'val', \n    # and the first 'k' elements of the array contain the result.\n    return k\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    This is a significant improvement. Both the `k` (slow) and `i` (fast) pointers traverse the array only once from beginning to end. Each element is read once, and a subset of elements are written to once.\n\n*   **Space Complexity: O(1)**\n    The algorithm operates directly on the input array (`in-place`) without allocating any additional data structures, so the space complexity is constant.\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - In-place Array Modification** pattern. The signals that point to this pattern are:\n\n1.  **In-place Requirement:** The problem explicitly states that the array must be modified *in-place*, which immediately suggests patterns that avoid creating new arrays.\n2.  **Partitioning Task:** The core task is to segregate the array elements into two groups: those that are equal to `val` and those that are not. The pattern uses the slow pointer `k` to effectively create a boundary between the \"kept\" elements and the \"discarded\" elements.\n3.  **Single Pass Efficiency:** The goal is to solve the problem efficiently, ideally in a single pass. The fast/slow pointer setup allows us to process the array and build the result simultaneously in one O(N) pass, avoiding the inefficient O(N^2) shifting of the brute-force method.\n\nIn this pattern, the \"slow\" pointer builds the final result at the start of the array, while the \"fast\" pointer explores ahead, finding the next valid piece of data to add to the result. This \"read-ahead and write-behind\" dynamic is the defining characteristic of using two pointers for in-place array restructuring.",
    "description": "Study Remove Element using the Pattern 4: Two Pointers - In-place Array Modification approach.",
    "has_content": true
  },
  {
    "id": "problem_28",
    "number": 28,
    "title": "Find the Index of the First Occurrence in a String",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 87: String Matching - Naive / KMP / Rabin-Karp",
    "url": "https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/",
    "difficulty": "easy",
    "content": "# Find the Index of the First Occurrence in a String\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find the Index of the First Occurrence in a String](https://leetcode.com/problems/find-the-index-of-the-first-occurrence-in-a-string/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 87: String Matching - Naive / KMP / Rabin-Karp",
    "description": "Study Find the Index of the First Occurrence in a String using the Pattern 87: String Matching - Naive / KMP / Rabin-Karp approach.",
    "has_content": false
  },
  {
    "id": "problem_31",
    "number": 31,
    "title": "Next Permutation",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 42: Backtracking - Permutations",
    "url": "https://leetcode.com/problems/next-permutation/",
    "difficulty": "easy",
    "content": "# Next Permutation\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Next Permutation](https://leetcode.com/problems/next-permutation/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 42: Backtracking - Permutations",
    "description": "Study Next Permutation using the Pattern 42: Backtracking - Permutations approach.",
    "has_content": false
  },
  {
    "id": "problem_32",
    "number": 32,
    "title": "Longest Valid Parentheses",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 58: Stack - Valid Parentheses Matching",
    "url": "https://leetcode.com/problems/longest-valid-parentheses/",
    "difficulty": "easy",
    "content": "# Longest Valid Parentheses\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Longest Valid Parentheses](https://leetcode.com/problems/longest-valid-parentheses/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 58: Stack - Valid Parentheses Matching",
    "description": "Study Longest Valid Parentheses using the Pattern 58: Stack - Valid Parentheses Matching approach.",
    "has_content": false
  },
  {
    "id": "problem_33",
    "number": 33,
    "title": "Search in Rotated Sorted Array",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "url": "https://leetcode.com/problems/search-in-rotated-sorted-array/",
    "difficulty": "easy",
    "content": "# Search in Rotated Sorted Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Search in Rotated Sorted Array](https://leetcode.com/problems/search-in-rotated-sorted-array/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "description": "Study Search in Rotated Sorted Array using the Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array approach.",
    "has_content": false
  },
  {
    "id": "problem_34",
    "number": 34,
    "title": "Find First and Last Position of Element in Sorted Array",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 56: Binary Search - Find First/Last Occurrence",
    "url": "https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/",
    "difficulty": "easy",
    "content": "# Find First and Last Position of Element in Sorted Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find First and Last Position of Element in Sorted Array](https://leetcode.com/problems/find-first-and-last-position-of-element-in-sorted-array/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 56: Binary Search - Find First/Last Occurrence",
    "description": "Study Find First and Last Position of Element in Sorted Array using the Pattern 56: Binary Search - Find First/Last Occurrence approach.",
    "has_content": false
  },
  {
    "id": "problem_35",
    "number": 35,
    "title": "Search Insert Position",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 53: Binary Search - On Sorted Array/List",
    "url": "https://leetcode.com/problems/search-insert-position/",
    "difficulty": "easy",
    "content": "# Search Insert Position\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Search Insert Position](https://leetcode.com/problems/search-insert-position/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 53: Binary Search - On Sorted Array/List",
    "description": "Study Search Insert Position using the Pattern 53: Binary Search - On Sorted Array/List approach.",
    "has_content": false
  },
  {
    "id": "problem_37",
    "number": 37,
    "title": "Sudoku Solver",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 46: Backtracking - N-Queens / Constraint Satisfaction",
    "url": "https://leetcode.com/problems/sudoku-solver/",
    "difficulty": "easy",
    "content": "# Sudoku Solver\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Sudoku Solver](https://leetcode.com/problems/sudoku-solver/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 46: Backtracking - N-Queens / Constraint Satisfaction",
    "description": "Study Sudoku Solver using the Pattern 46: Backtracking - N-Queens / Constraint Satisfaction approach.",
    "has_content": false
  },
  {
    "id": "problem_39",
    "number": 39,
    "title": "Combination Sum",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 43: Backtracking - Combination Sum",
    "url": "https://leetcode.com/problems/combination-sum/",
    "difficulty": "easy",
    "content": "# Combination Sum\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Combination Sum](https://leetcode.com/problems/combination-sum/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 43: Backtracking - Combination Sum",
    "description": "Study Combination Sum using the Pattern 43: Backtracking - Combination Sum approach.",
    "has_content": false
  },
  {
    "id": "problem_40",
    "number": 40,
    "title": "Combination Sum II",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 43: Backtracking - Combination Sum",
    "url": "https://leetcode.com/problems/combination-sum-ii/",
    "difficulty": "easy",
    "content": "# Combination Sum II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Combination Sum II](https://leetcode.com/problems/combination-sum-ii/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 43: Backtracking - Combination Sum",
    "description": "Study Combination Sum II using the Pattern 43: Backtracking - Combination Sum approach.",
    "has_content": false
  },
  {
    "id": "problem_41",
    "number": 41,
    "title": "First Missing Positive",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 80: Array - Cyclic Sort",
    "url": "https://leetcode.com/problems/first-missing-positive/",
    "difficulty": "easy",
    "content": "# First Missing Positive\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [First Missing Positive](https://leetcode.com/problems/first-missing-positive/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 80: Array - Cyclic Sort",
    "description": "Study First Missing Positive using the Pattern 80: Array - Cyclic Sort approach.",
    "has_content": false
  },
  {
    "id": "problem_43",
    "number": 43,
    "title": "Multiply Strings",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 86: String - Multiply Strings (Manual Simulation)",
    "url": "https://leetcode.com/problems/multiply-strings/",
    "difficulty": "easy",
    "content": "# Multiply Strings\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Multiply Strings](https://leetcode.com/problems/multiply-strings/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 86: String - Multiply Strings (Manual Simulation)",
    "description": "Study Multiply Strings using the Pattern 86: String - Multiply Strings (Manual Simulation) approach.",
    "has_content": false
  },
  {
    "id": "problem_45",
    "number": 45,
    "title": "Jump Game II",
    "category": "VIII. Greedy Patterns",
    "pattern": "Pattern 49: Greedy - Jump Game Reachability/Minimization",
    "url": "https://leetcode.com/problems/jump-game-ii/",
    "difficulty": "easy",
    "content": "# Jump Game II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Jump Game II](https://leetcode.com/problems/jump-game-ii/)\n\n**Category:** VIII. Greedy Patterns\n**Pattern:** Pattern 49: Greedy - Jump Game Reachability/Minimization",
    "description": "Study Jump Game II using the Pattern 49: Greedy - Jump Game Reachability/Minimization approach.",
    "has_content": false
  },
  {
    "id": "problem_46",
    "number": 46,
    "title": "Permutations",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 42: Backtracking - Permutations",
    "url": "https://leetcode.com/problems/permutations/",
    "difficulty": "easy",
    "content": "# Permutations\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Permutations](https://leetcode.com/problems/permutations/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 42: Backtracking - Permutations",
    "description": "Study Permutations using the Pattern 42: Backtracking - Permutations approach.",
    "has_content": false
  },
  {
    "id": "problem_48",
    "number": 48,
    "title": "Rotate Image",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 74: Array/Matrix - In-place Rotation",
    "url": "https://leetcode.com/problems/rotate-image/",
    "difficulty": "easy",
    "content": "# Rotate Image\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Rotate Image](https://leetcode.com/problems/rotate-image/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 74: Array/Matrix - In-place Rotation",
    "description": "Study Rotate Image using the Pattern 74: Array/Matrix - In-place Rotation approach.",
    "has_content": false
  },
  {
    "id": "problem_49",
    "number": 49,
    "title": "Group Anagrams",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 83: String - Anagram Check (Frequency Count/Sort)",
    "url": "https://leetcode.com/problems/group-anagrams/",
    "difficulty": "easy",
    "content": "# Group Anagrams\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Group Anagrams](https://leetcode.com/problems/group-anagrams/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 83: String - Anagram Check (Frequency Count/Sort)",
    "description": "Study Group Anagrams using the Pattern 83: String - Anagram Check (Frequency Count/Sort) approach.",
    "has_content": false
  },
  {
    "id": "problem_51",
    "number": 51,
    "title": "N-Queens",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 46: Backtracking - N-Queens / Constraint Satisfaction",
    "url": "https://leetcode.com/problems/n-queens/",
    "difficulty": "easy",
    "content": "# N-Queens\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [N-Queens](https://leetcode.com/problems/n-queens/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 46: Backtracking - N-Queens / Constraint Satisfaction",
    "description": "Study N-Queens using the Pattern 46: Backtracking - N-Queens / Constraint Satisfaction approach.",
    "has_content": false
  },
  {
    "id": "problem_53",
    "number": 53,
    "title": "Maximum Subarray",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray)",
    "url": "https://leetcode.com/problems/maximum-subarray/",
    "difficulty": "easy",
    "content": "# Maximum Subarray\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray)",
    "description": "Study Maximum Subarray using the Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray) approach.",
    "has_content": false
  },
  {
    "id": "problem_54",
    "number": 54,
    "title": "Spiral Matrix",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 75: Array/Matrix - Spiral Traversal",
    "url": "https://leetcode.com/problems/spiral-matrix/",
    "difficulty": "easy",
    "content": "# Spiral Matrix\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Spiral Matrix](https://leetcode.com/problems/spiral-matrix/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 75: Array/Matrix - Spiral Traversal",
    "description": "Study Spiral Matrix using the Pattern 75: Array/Matrix - Spiral Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_55",
    "number": 55,
    "title": "Jump Game",
    "category": "VIII. Greedy Patterns",
    "pattern": "Pattern 49: Greedy - Jump Game Reachability/Minimization",
    "url": "https://leetcode.com/problems/jump-game/",
    "difficulty": "easy",
    "content": "# Jump Game\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Jump Game](https://leetcode.com/problems/jump-game/)\n\n**Category:** VIII. Greedy Patterns\n**Pattern:** Pattern 49: Greedy - Jump Game Reachability/Minimization",
    "description": "Study Jump Game using the Pattern 49: Greedy - Jump Game Reachability/Minimization approach.",
    "has_content": false
  },
  {
    "id": "problem_56",
    "number": 56,
    "title": "Merge Intervals",
    "category": "VIII. Greedy Patterns",
    "pattern": "Pattern 48: Greedy - Interval Merging/Scheduling",
    "url": "https://leetcode.com/problems/merge-intervals/",
    "difficulty": "easy",
    "content": "# Merge Intervals\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Merge Intervals](https://leetcode.com/problems/merge-intervals/)\n\n**Category:** VIII. Greedy Patterns\n**Pattern:** Pattern 48: Greedy - Interval Merging/Scheduling",
    "description": "Study Merge Intervals using the Pattern 48: Greedy - Interval Merging/Scheduling approach.",
    "has_content": false
  },
  {
    "id": "problem_57",
    "number": 57,
    "title": "Insert Interval",
    "category": "VIII. Greedy Patterns",
    "pattern": "Pattern 48: Greedy - Interval Merging/Scheduling",
    "url": "https://leetcode.com/problems/insert-interval/",
    "difficulty": "easy",
    "content": "# Insert Interval\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Insert Interval](https://leetcode.com/problems/insert-interval/)\n\n**Category:** VIII. Greedy Patterns\n**Pattern:** Pattern 48: Greedy - Interval Merging/Scheduling",
    "description": "Study Insert Interval using the Pattern 48: Greedy - Interval Merging/Scheduling approach.",
    "has_content": false
  },
  {
    "id": "problem_60",
    "number": 60,
    "title": "Permutation Sequence",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 42: Backtracking - Permutations",
    "url": "https://leetcode.com/problems/permutation-sequence/",
    "difficulty": "easy",
    "content": "# Permutation Sequence\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Permutation Sequence](https://leetcode.com/problems/permutation-sequence/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 42: Backtracking - Permutations",
    "description": "Study Permutation Sequence using the Pattern 42: Backtracking - Permutations approach.",
    "has_content": false
  },
  {
    "id": "problem_61",
    "number": 61,
    "title": "Rotate List",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 73: Linked List - Reordering / Partitioning",
    "url": "https://leetcode.com/problems/rotate-list/",
    "difficulty": "easy",
    "content": "# Rotate List\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Rotate List](https://leetcode.com/problems/rotate-list/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 73: Linked List - Reordering / Partitioning",
    "description": "Study Rotate List using the Pattern 73: Linked List - Reordering / Partitioning approach.",
    "has_content": false
  },
  {
    "id": "problem_62",
    "number": 62,
    "title": "Unique Paths",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "url": "https://leetcode.com/problems/unique-paths/",
    "difficulty": "easy",
    "content": "# Unique Paths\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Unique Paths](https://leetcode.com/problems/unique-paths/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "description": "Study Unique Paths using the Pattern 33: DP - 2D Array (Unique Paths on Grid) approach.",
    "has_content": false
  },
  {
    "id": "problem_63",
    "number": 63,
    "title": "Unique Paths II",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "url": "https://leetcode.com/problems/unique-paths-ii/",
    "difficulty": "easy",
    "content": "# Unique Paths II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Unique Paths II](https://leetcode.com/problems/unique-paths-ii/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "description": "Study Unique Paths II using the Pattern 33: DP - 2D Array (Unique Paths on Grid) approach.",
    "has_content": false
  },
  {
    "id": "problem_64",
    "number": 64,
    "title": "Minimum Path Sum",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "url": "https://leetcode.com/problems/minimum-path-sum/",
    "difficulty": "easy",
    "content": "# Minimum Path Sum\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Path Sum](https://leetcode.com/problems/minimum-path-sum/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "description": "Study Minimum Path Sum using the Pattern 33: DP - 2D Array (Unique Paths on Grid) approach.",
    "has_content": false
  },
  {
    "id": "problem_66",
    "number": 66,
    "title": "Plus One",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 78: Array - Plus One (Handling Carry)",
    "url": "https://leetcode.com/problems/plus-one/",
    "difficulty": "easy",
    "content": "# Plus One\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Plus One](https://leetcode.com/problems/plus-one/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 78: Array - Plus One (Handling Carry)",
    "description": "Study Plus One using the Pattern 78: Array - Plus One (Handling Carry) approach.",
    "has_content": false
  },
  {
    "id": "problem_69",
    "number": 69,
    "title": "Sqrt(x)",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 53: Binary Search - On Sorted Array/List",
    "url": "https://leetcode.com/problems/sqrtx/",
    "difficulty": "easy",
    "content": "# Sqrt(x)\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Sqrt(x)](https://leetcode.com/problems/sqrtx/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 53: Binary Search - On Sorted Array/List",
    "description": "Study Sqrt(x) using the Pattern 53: Binary Search - On Sorted Array/List approach.",
    "has_content": false
  },
  {
    "id": "problem_70",
    "number": 70,
    "title": "Climbing Stairs",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 26: DP - 1D Array (Fibonacci Style)",
    "url": "https://leetcode.com/problems/climbing-stairs/",
    "difficulty": "easy",
    "content": "# Climbing Stairs\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Climbing Stairs](https://leetcode.com/problems/climbing-stairs/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 26: DP - 1D Array (Fibonacci Style)",
    "description": "Study Climbing Stairs using the Pattern 26: DP - 1D Array (Fibonacci Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_71",
    "number": 71,
    "title": "Simplify Path",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 61: Stack - Simulation / Backtracking Helper",
    "url": "https://leetcode.com/problems/simplify-path/",
    "difficulty": "easy",
    "content": "# Simplify Path\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Simplify Path](https://leetcode.com/problems/simplify-path/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 61: Stack - Simulation / Backtracking Helper",
    "description": "Study Simplify Path using the Pattern 61: Stack - Simulation / Backtracking Helper approach.",
    "has_content": false
  },
  {
    "id": "problem_72",
    "number": 72,
    "title": "Edit Distance",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 32: DP - 2D Array (Edit Distance / Levenshtein Distance)",
    "url": "https://leetcode.com/problems/edit-distance/",
    "difficulty": "easy",
    "content": "# Edit Distance\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Edit Distance](https://leetcode.com/problems/edit-distance/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 32: DP - 2D Array (Edit Distance / Levenshtein Distance)",
    "description": "Study Edit Distance using the Pattern 32: DP - 2D Array (Edit Distance / Levenshtein Distance) approach.",
    "has_content": false
  },
  {
    "id": "problem_73",
    "number": 73,
    "title": "Set Matrix Zeroes",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 76: Array/Matrix - Set Matrix Zeroes (In-place Marking)",
    "url": "https://leetcode.com/problems/set-matrix-zeroes/",
    "difficulty": "easy",
    "content": "# Set Matrix Zeroes\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Set Matrix Zeroes](https://leetcode.com/problems/set-matrix-zeroes/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 76: Array/Matrix - Set Matrix Zeroes (In-place Marking)",
    "description": "Study Set Matrix Zeroes using the Pattern 76: Array/Matrix - Set Matrix Zeroes (In-place Marking) approach.",
    "has_content": false
  },
  {
    "id": "problem_74",
    "number": 74,
    "title": "Search a 2D Matrix",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 53: Binary Search - On Sorted Array/List",
    "url": "https://leetcode.com/problems/search-a-2d-matrix/",
    "difficulty": "easy",
    "content": "# Search a 2D Matrix\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Search a 2D Matrix](https://leetcode.com/problems/search-a-2d-matrix/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 53: Binary Search - On Sorted Array/List",
    "description": "Study Search a 2D Matrix using the Pattern 53: Binary Search - On Sorted Array/List approach.",
    "has_content": false
  },
  {
    "id": "problem_75",
    "number": 75,
    "title": "Sort Colors",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 4: Two Pointers - In-place Array Modification",
    "url": "https://leetcode.com/problems/sort-colors/",
    "difficulty": "easy",
    "content": "---\n### **75. Sort Colors**\n**Link to Problem:** [https://leetcode.com/problems/sort-colors/](https://leetcode.com/problems/sort-colors/)\n\n#### **1. Problem Statement**\nGiven an array `nums` containing integers representing colors (0 for red, 1 for white, and 2 for blue), the task is to sort the array **in-place**. The final arrangement should have all 0s first, followed by all 1s, and then all 2s. You are not allowed to use the library's built-in sort function.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward approach is to count the occurrences of each color and then overwrite the original array with the correct number of 0s, 1s, and 2s. This is a variation of Counting Sort. The process involves two separate passes over the array: one for counting and one for writing.\n\n1.  **First Pass (Counting):** Iterate through the array and count the number of 0s, 1s, and 2s.\n2.  **Second Pass (Overwriting):** Use the counts to rebuild the array. Start from the beginning of the array, fill it with the counted number of 0s, then the 1s, and finally the 2s.\n\n**Python Code:**\n```python\ndef sortColors(nums: list[int]) -> None:\n    \"\"\"\n    Sorts the array using a two-pass counting sort algorithm.\n    \"\"\"\n    # Step 1: Count the occurrences of each color.\n    count_0 = 0\n    count_1 = 0\n    count_2 = 0\n    \n    for num in nums:\n        if num == 0:\n            count_0 += 1\n        elif num == 1:\n            count_1 += 1\n        else:\n            count_2 += 1\n            \n    # Step 2: Overwrite the original array based on the counts.\n    # We use an index `i` to keep track of our position in `nums`.\n    i = 0\n    \n    # Place all the 0s.\n    for _ in range(count_0):\n        nums[i] = 0\n        i += 1\n        \n    # Place all the 1s.\n    for _ in range(count_1):\n        nums[i] = 1\n        i += 1\n        \n    # Place all the 2s.\n    for _ in range(count_2):\n        nums[i] = 2\n        i += 1\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    This is because we iterate through the array twice. The first loop to count elements takes O(N) time, and the second phase to overwrite the array also takes O(N) time (N for 0s + N for 1s + N for 2s in total). Thus, the total complexity is O(N) + O(N) = O(N).\n\n*   **Space Complexity: O(1)**\n    We only use a few extra variables to store the counts, regardless of the size of the input array. This is constant extra space.\n\n### **3. Optimized Approach: [Pattern 4: Two Pointers - In-place Array Modification]**\n**Intuition:**\nWe can improve upon the two-pass approach by sorting the array in a **single pass** using three pointers. This algorithm is famously known as the **Dutch National Flag problem** solution, a classic example of in-place partitioning.\n\nThe core idea is to partition the array into three sections:\n1.  A section for `0`s at the beginning.\n2.  A section for `1`s in the middle.\n3.  A section for `2`s at the end.\n\nWe'll use three pointers to manage these sections:\n*   `low`: Points to the position where the next `0` should go. Everything to the left of `low` is guaranteed to be a `0`.\n*   `high`: Points to the position where the next `2` should go. Everything to the right of `high` is guaranteed to be a `2`.\n*   `mid`: The current element being considered. It iterates from the beginning to the end of the array.\n\nThe algorithm proceeds as follows, maintaining the invariant `low <= mid <= high`:\n- If `nums[mid]` is a `0`, it belongs in the `low` section. We swap `nums[low]` with `nums[mid]` and then increment both `low` and `mid`.\n- If `nums[mid]` is a `1`, it's in the correct potential position. We don't need to move it, so we just increment `mid`.\n- If `nums[mid]` is a `2`, it belongs in the `high` section. We swap `nums[high]` with `nums[mid]` and then decrement `high`. We **do not** increment `mid` because the new element at `nums[mid]` (which came from `nums[high]`) has not been processed yet and needs to be checked.\n\nLet's walk through an example: `nums = [2, 0, 1]`\n- **Initial:** `low = 0`, `mid = 0`, `high = 2`. `nums = [2, 0, 1]`\n- **`mid` is at index 0:** `nums[0]` is `2`. Swap `nums[mid]` with `nums[high]`.\n  - `nums` becomes `[1, 0, 2]`.\n  - Decrement `high`. `high` is now `1`. `mid` remains `0`.\n- **`mid` is at index 0:** `nums[0]` is `1`. It's a `1`, so just increment `mid`.\n  - `mid` is now `1`.\n- **`mid` is at index 1:** `nums[1]` is `0`. Swap `nums[mid]` with `nums[low]`.\n  - `nums` becomes `[0, 1, 2]`.\n  - Increment `low` and `mid`. `low` is now `1`, `mid` is now `2`.\n- **Loop condition:** `mid <= high` (i.e., `2 <= 1`) is now false. The loop terminates.\n- **Final:** `nums = [0, 1, 2]`. The array is sorted in a single pass.\n\n**Python Code:**\n```python\ndef sortColors(nums: list[int]) -> None:\n    \"\"\"\n    Sorts the array in-place using the Dutch National Flag algorithm (three pointers).\n    This is a classic example of the Two Pointers - In-place Array Modification pattern.\n    \"\"\"\n    # Pointers to define the boundaries of our three sections.\n    # `low` is the boundary for the '0' section.\n    # `high` is the boundary for the '2' section.\n    low, mid, high = 0, 0, len(nums) - 1\n    \n    # The main loop continues as long as `mid` has not surpassed `high`.\n    # The section between mid and high is the \"unprocessed\" zone.\n    while mid <= high:\n        # Case 1: The element at `mid` is a 0.\n        if nums[mid] == 0:\n            # Swap it with the element at the `low` boundary.\n            nums[low], nums[mid] = nums[mid], nums[low]\n            # Both `low` and `mid` pointers move one step to the right.\n            # We increment `low` because we've placed a 0 correctly.\n            # We increment `mid` because the element we swapped from `low` is\n            # guaranteed to be a 0 or 1, which `mid` can safely pass.\n            low += 1\n            mid += 1\n            \n        # Case 2: The element at `mid` is a 1.\n        elif nums[mid] == 1:\n            # The element is in its correct potential place, so we just move on.\n            mid += 1\n            \n        # Case 3: The element at `mid` is a 2.\n        else: # nums[mid] == 2\n            # Swap it with the element at the `high` boundary.\n            nums[high], nums[mid] = nums[mid], nums[high]\n            # The `high` pointer moves one step to the left, shrinking the\n            # \"unprocessed\" zone from the right.\n            high -= 1\n            # IMPORTANT: We do NOT increment `mid` here. The new element at `mid`\n            # came from the `high` position and we haven't processed it yet.\n            # It could be a 0, 1, or 2, and needs to be checked in the next iteration.\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    Although we have three pointers, the `mid` pointer iterates through the array from the beginning to the end. Each element is visited and processed at most a constant number of times. This results in a single-pass algorithm with linear time complexity.\n\n*   **Space Complexity: O(1)**\n    The sorting is performed entirely in-place. We only use three integer variables for our pointers, so the space required is constant and does not depend on the input size.\n\n### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - In-place Array Modification** pattern. The signals that point to this pattern are:\n\n1.  **In-place Requirement:** The problem explicitly forbids creating a new array and demands that the input array be modified directly. This is the strongest indicator for this pattern.\n2.  **Partitioning Task:** The core of the problem is not just sorting, but **partitioning** the array into distinct, contiguous sections (`0`s, `1`s, `2`s).\n3.  **Defined Boundaries:** The values (`0`, `2`) provide clear criteria for what belongs at the absolute start and absolute end of the array. Pointers (`low`, `high`) are perfect tools for managing the boundaries of these growing, sorted partitions.\n\nBy using pointers to track the boundaries of the sorted \"red\" and \"blue\" sections, we can iterate through the array once with a third pointer (`mid`), swapping elements into their correct partitions as we find them. This avoids the need for a second pass or extra storage, perfectly demonstrating the power and efficiency of the in-place modification pattern.",
    "description": "Study Sort Colors using the Pattern 4: Two Pointers - In-place Array Modification approach.",
    "has_content": true
  },
  {
    "id": "problem_76",
    "number": 76,
    "title": "Minimum Window Substring",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/minimum-window-substring/",
    "difficulty": "easy",
    "content": "# Minimum Window Substring\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Window Substring](https://leetcode.com/problems/minimum-window-substring/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Minimum Window Substring using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_77",
    "number": 77,
    "title": "Combinations",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 41: Backtracking - Subsets (Include/Exclude)",
    "url": "https://leetcode.com/problems/combinations/",
    "difficulty": "easy",
    "content": "# Combinations\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Combinations](https://leetcode.com/problems/combinations/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 41: Backtracking - Subsets (Include/Exclude)",
    "description": "Study Combinations using the Pattern 41: Backtracking - Subsets (Include/Exclude) approach.",
    "has_content": false
  },
  {
    "id": "problem_78",
    "number": 78,
    "title": "Subsets",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 41: Backtracking - Subsets (Include/Exclude)",
    "url": "https://leetcode.com/problems/subsets/",
    "difficulty": "easy",
    "content": "# Subsets\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Subsets](https://leetcode.com/problems/subsets/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 41: Backtracking - Subsets (Include/Exclude)",
    "description": "Study Subsets using the Pattern 41: Backtracking - Subsets (Include/Exclude) approach.",
    "has_content": false
  },
  {
    "id": "problem_79",
    "number": 79,
    "title": "Word Search",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 45: Backtracking - Word Search / Path Finding in Grid",
    "url": "https://leetcode.com/problems/word-search/",
    "difficulty": "easy",
    "content": "# Word Search\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Word Search](https://leetcode.com/problems/word-search/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 45: Backtracking - Word Search / Path Finding in Grid",
    "description": "Study Word Search using the Pattern 45: Backtracking - Word Search / Path Finding in Grid approach.",
    "has_content": false
  },
  {
    "id": "problem_80",
    "number": 80,
    "title": "Remove Duplicates from Sorted Array II",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 4: Two Pointers - In-place Array Modification",
    "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/",
    "difficulty": "easy",
    "content": "---\n### **80. Remove Duplicates from Sorted Array II**\n**Link to Problem:** [https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/](https://leetcode.com/problems/remove-duplicates-from-sorted-array-ii/)\n\n#### **1. Problem Statement**\nGiven a sorted integer array `nums`, the task is to modify the array in-place to remove duplicate elements so that each unique number appears at most twice. You must return `k`, the length of the modified array, while preserving the relative order of the elements. The elements beyond the `k`-th position do not matter.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this without the in-place constraint would be to build a new array. We could iterate through the input array and add elements to a separate `result` array, but only if they don't violate the \"at most twice\" rule. After iterating through the entire input, we would copy the contents of our `result` array back into the beginning of the original `nums` array.\n\nThis approach is simple to conceptualize but fails the O(1) extra memory constraint, which is a key part of the problem. It serves as a good baseline to understand the requirements before optimizing.\n\n**Python Code:**\n```python\ndef removeDuplicates_brute_force(nums: list[int]) -> int:\n    # This approach uses O(N) extra space, violating the problem's constraint.\n    # It's presented here to illustrate the basic logic before optimizing.\n    if len(nums) <= 2:\n        return len(nums)\n\n    # Use a new list to store the valid elements.\n    result = []\n    for num in nums:\n        # We can add the number if the result list is not yet full (size < 2),\n        # or if the current number is different from the number two positions back.\n        # This check elegantly ensures we don't add a third duplicate.\n        if len(result) < 2 or num != result[-2]:\n            result.append(num)\n\n    # Copy the valid elements from the result list back to the original nums array.\n    for i in range(len(result)):\n        nums[i] = result[i]\n\n    # The new length is the size of our result list.\n    return len(result)\n\n# Complexity Analysis:\n#\n# Time Complexity: O(N)\n# We iterate through the original array once to build the 'result' list (O(N)),\n# and then iterate through the 'result' list to copy elements back (O(k), where k <= N).\n# This results in a linear time complexity of O(N).\n#\n# Space Complexity: O(N)\n# We create a new 'result' list that can, in the worst case (no duplicates),\n# grow to the same size as the input array. This violates the O(1) space constraint.\n```\n\n### **3. Optimized Approach: Two Pointers - In-place Array Modification**\n**Intuition:**\nTo satisfy the O(1) space complexity, we must modify the array in-place. This is the perfect scenario for the **In-place Array Modification** two-pointer pattern.\n\nWe can think of the array as having two regions: the processed, valid section at the beginning, and the unprocessed section that we are iterating through.\n1.  **`write_ptr` (slow pointer):** This pointer (let's call it `k`) marks the end of the valid section. It indicates the next position where a valid number should be placed. It starts at `0`.\n2.  **`read_ptr` (fast pointer):** This pointer simply iterates through every element of the array from beginning to end to examine it.\n\nThe core idea is to iterate with the `read_ptr` and decide if the element it's pointing to should be kept. If it should, we copy it to the `write_ptr`'s position and advance the `write_ptr`.\n\nHow do we decide if a number `num` should be kept?\nA number is valid if it's one of the first two elements we're placing, or if it's different from the element *two positions before* the current `write_ptr`. The element at `nums[k-1]` is the one we just placed, and the one at `nums[k-2]` is the one before that. If our current `num` is the same as `nums[k-2]`, it would be the third instance, which is not allowed.\n\nLet's walk through `nums = [1, 1, 1, 2, 2, 3]`:\n-   Initialize `k = 0`.\n-   `num = 1`: `k` is 0, which is `< 2`. It's a valid element. So, `nums[0] = 1`, and `k` becomes `1`. Array state: `[1, ...]`.\n-   `num = 1`: `k` is 1, which is `< 2`. It's a valid element. So, `nums[1] = 1`, and `k` becomes `2`. Array state: `[1, 1, ...]`.\n-   `num = 1`: `k` is 2. We check the condition `num > nums[k-2]`. Is `1 > nums[2-2]` (i.e., `1 > nums[0]`)? No, `1` is not greater than `1`. We don't copy it. `k` remains `2`.\n-   `num = 2`: `k` is 2. We check `num > nums[k-2]`. Is `2 > nums[0]`? Yes, `2 > 1`. It's a valid element. So, `nums[2] = 2`, and `k` becomes `3`. Array state: `[1, 1, 2, ...]`.\n-   `num = 2`: `k` is 3. We check `num > nums[k-2]`. Is `2 > nums[3-2]` (i.e., `2 > nums[1]`)? Yes, `2 > 1`. It's a valid element. So, `nums[3] = 2`, and `k` becomes `4`. Array state: `[1, 1, 2, 2, ...]`.\n-   `num = 3`: `k` is 4. We check `num > nums[k-2]`. Is `3 > nums[4-2]` (i.e., `3 > nums[2]`)? Yes, `3 > 2`. It's a valid element. So, `nums[4] = 3`, and `k` becomes `5`. Array state: `[1, 1, 2, 2, 3, ...]`.\n\nThe loop finishes. We return `k=5`, and the first 5 elements of `nums` are correctly `[1, 1, 2, 2, 3]`.\n\n**Python Code:**\n```python\ndef removeDuplicates(nums: list[int]) -> int:\n    # 'k' will be the \"write pointer\". It tracks the index of the last valid element + 1.\n    # It essentially represents the length of the valid, modified part of the array.\n    k = 0\n    \n    # The 'for' loop implicitly uses a \"read pointer\" ('num') to scan the array.\n    for num in nums:\n        # The condition to keep an element is:\n        # 1. We are at the beginning of the array (k < 2), so we can accept up to two elements.\n        # OR\n        # 2. The current number 'num' is different from the number two positions\n        #    before the write pointer. nums[k-2] is the first of the potential duplicates.\n        #    If num is greater, it means it's a new number, so we should keep it.\n        if k < 2 or num > nums[k-2]:\n            # This is a valid element, so we place it at the 'k' position.\n            nums[k] = num\n            # We advance the write pointer to the next empty slot.\n            k += 1\n            \n    # 'k' now holds the length of the modified array.\n    return k\n\n# Complexity Analysis:\n#\n# Time Complexity: O(N)\n# We iterate through the array only once. Both the implicit 'read pointer' (from the loop)\n# and the explicit 'write pointer' ('k') traverse the array at most N times.\n#\n# Space Complexity: O(1)\n# The modification is done in-place. We only use a single extra variable 'k' for our pointer,\n# achieving the required constant space complexity.\n```\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - In-place Array Modification** pattern for several key reasons:\n\n1.  **In-Place Requirement:** The problem explicitly demands an `O(1)` space solution, which is the primary trigger for this pattern. We cannot create a new array, so we must overwrite the input array itself.\n2.  **Condensing/Filtering an Array:** The core task is to filter out unwanted elements (excess duplicates) and produce a condensed, valid result at the beginning of the same array.\n3.  **Sorted Input:** The sorted nature of the array is a crucial enabler. It guarantees that all duplicate elements are grouped together, which simplifies the logic. We only need to compare the current element with the one at `k-2` to know if we have seen too many duplicates.\n\nThe pattern manifests as a \"slow\" pointer (`k`) that maintains the boundary of the valid, processed prefix of the array, and a \"fast\" pointer (the loop variable `num`) that scans ahead for the next element to be kept. When the fast pointer finds a suitable element, it gets copied to the slow pointer's location. This \"read-ahead and write-behind\" mechanism is the defining characteristic of this two-pointer technique for in-place modifications.",
    "description": "Study Remove Duplicates from Sorted Array II using the Pattern 4: Two Pointers - In-place Array Modification approach.",
    "has_content": true
  },
  {
    "id": "problem_81",
    "number": 81,
    "title": "Search in Rotated Sorted Array II",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "url": "https://leetcode.com/problems/search-in-rotated-sorted-array-ii/",
    "difficulty": "easy",
    "content": "# Search in Rotated Sorted Array II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Search in Rotated Sorted Array II](https://leetcode.com/problems/search-in-rotated-sorted-array-ii/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "description": "Study Search in Rotated Sorted Array II using the Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array approach.",
    "has_content": false
  },
  {
    "id": "problem_82",
    "number": 82,
    "title": "Remove Duplicates from Sorted List II",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 69: Linked List - In-place Reversal",
    "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/",
    "difficulty": "easy",
    "content": "# Remove Duplicates from Sorted List II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Remove Duplicates from Sorted List II](https://leetcode.com/problems/remove-duplicates-from-sorted-list-ii/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 69: Linked List - In-place Reversal",
    "description": "Study Remove Duplicates from Sorted List II using the Pattern 69: Linked List - In-place Reversal approach.",
    "has_content": false
  },
  {
    "id": "problem_83",
    "number": 83,
    "title": "Remove Duplicates from Sorted List",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 69: Linked List - In-place Reversal",
    "url": "https://leetcode.com/problems/remove-duplicates-from-sorted-list/",
    "difficulty": "easy",
    "content": "# Remove Duplicates from Sorted List\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Remove Duplicates from Sorted List](https://leetcode.com/problems/remove-duplicates-from-sorted-list/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 69: Linked List - In-place Reversal",
    "description": "Study Remove Duplicates from Sorted List using the Pattern 69: Linked List - In-place Reversal approach.",
    "has_content": false
  },
  {
    "id": "problem_84",
    "number": 84,
    "title": "Largest Rectangle in Histogram",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 63: Stack - Largest Rectangle in Histogram",
    "url": "https://leetcode.com/problems/largest-rectangle-in-histogram/",
    "difficulty": "easy",
    "content": "# Largest Rectangle in Histogram\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Largest Rectangle in Histogram](https://leetcode.com/problems/largest-rectangle-in-histogram/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 63: Stack - Largest Rectangle in Histogram",
    "description": "Study Largest Rectangle in Histogram using the Pattern 63: Stack - Largest Rectangle in Histogram approach.",
    "has_content": false
  },
  {
    "id": "problem_85",
    "number": 85,
    "title": "Maximal Rectangle",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 63: Stack - Largest Rectangle in Histogram",
    "url": "https://leetcode.com/problems/maximal-rectangle/",
    "difficulty": "easy",
    "content": "# Maximal Rectangle\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximal Rectangle](https://leetcode.com/problems/maximal-rectangle/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 63: Stack - Largest Rectangle in Histogram",
    "description": "Study Maximal Rectangle using the Pattern 63: Stack - Largest Rectangle in Histogram approach.",
    "has_content": false
  },
  {
    "id": "problem_86",
    "number": 86,
    "title": "Partition List",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 73: Linked List - Reordering / Partitioning",
    "url": "https://leetcode.com/problems/partition-list/",
    "difficulty": "easy",
    "content": "# Partition List\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Partition List](https://leetcode.com/problems/partition-list/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 73: Linked List - Reordering / Partitioning",
    "description": "Study Partition List using the Pattern 73: Linked List - Reordering / Partitioning approach.",
    "has_content": false
  },
  {
    "id": "problem_88",
    "number": 88,
    "title": "Merge Sorted Array",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 79: Array - Merge Sorted Array (In-place from End)",
    "url": "https://leetcode.com/problems/merge-sorted-array/",
    "difficulty": "easy",
    "content": "# Merge Sorted Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Merge Sorted Array](https://leetcode.com/problems/merge-sorted-array/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 79: Array - Merge Sorted Array (In-place from End)",
    "description": "Study Merge Sorted Array using the Pattern 79: Array - Merge Sorted Array (In-place from End) approach.",
    "has_content": false
  },
  {
    "id": "problem_90",
    "number": 90,
    "title": "Subsets II",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 41: Backtracking - Subsets (Include/Exclude)",
    "url": "https://leetcode.com/problems/subsets-ii/",
    "difficulty": "easy",
    "content": "# Subsets II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Subsets II](https://leetcode.com/problems/subsets-ii/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 41: Backtracking - Subsets (Include/Exclude)",
    "description": "Study Subsets II using the Pattern 41: Backtracking - Subsets (Include/Exclude) approach.",
    "has_content": false
  },
  {
    "id": "problem_91",
    "number": 91,
    "title": "Decode Ways",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 26: DP - 1D Array (Fibonacci Style)",
    "url": "https://leetcode.com/problems/decode-ways/",
    "difficulty": "easy",
    "content": "# Decode Ways\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Decode Ways](https://leetcode.com/problems/decode-ways/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 26: DP - 1D Array (Fibonacci Style)",
    "description": "Study Decode Ways using the Pattern 26: DP - 1D Array (Fibonacci Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_92",
    "number": 92,
    "title": "Reverse Linked List II",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 69: Linked List - In-place Reversal",
    "url": "https://leetcode.com/problems/reverse-linked-list-ii/",
    "difficulty": "easy",
    "content": "# Reverse Linked List II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Reverse Linked List II](https://leetcode.com/problems/reverse-linked-list-ii/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 69: Linked List - In-place Reversal",
    "description": "Study Reverse Linked List II using the Pattern 69: Linked List - In-place Reversal approach.",
    "has_content": false
  },
  {
    "id": "problem_94",
    "number": 94,
    "title": "Binary Tree Inorder Traversal",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "url": "https://leetcode.com/problems/binary-tree-inorder-traversal/",
    "difficulty": "easy",
    "content": "# Binary Tree Inorder Traversal\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Binary Tree Inorder Traversal](https://leetcode.com/problems/binary-tree-inorder-traversal/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "description": "Study Binary Tree Inorder Traversal using the Pattern 14: Tree DFS - Recursive Inorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_95",
    "number": 95,
    "title": "Unique Binary Search Trees II",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 35: DP - Catalan Numbers",
    "url": "https://leetcode.com/problems/unique-binary-search-trees-ii/",
    "difficulty": "easy",
    "content": "# Unique Binary Search Trees II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Unique Binary Search Trees II](https://leetcode.com/problems/unique-binary-search-trees-ii/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 35: DP - Catalan Numbers",
    "description": "Study Unique Binary Search Trees II using the Pattern 35: DP - Catalan Numbers approach.",
    "has_content": false
  },
  {
    "id": "problem_96",
    "number": 96,
    "title": "Unique Binary Search Trees",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 35: DP - Catalan Numbers",
    "url": "https://leetcode.com/problems/unique-binary-search-trees/",
    "difficulty": "easy",
    "content": "# Unique Binary Search Trees\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Unique Binary Search Trees](https://leetcode.com/problems/unique-binary-search-trees/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 35: DP - Catalan Numbers",
    "description": "Study Unique Binary Search Trees using the Pattern 35: DP - Catalan Numbers approach.",
    "has_content": false
  },
  {
    "id": "problem_98",
    "number": 98,
    "title": "Validate Binary Search Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "url": "https://leetcode.com/problems/validate-binary-search-tree/",
    "difficulty": "easy",
    "content": "# Validate Binary Search Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Validate Binary Search Tree](https://leetcode.com/problems/validate-binary-search-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "description": "Study Validate Binary Search Tree using the Pattern 14: Tree DFS - Recursive Inorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_100",
    "number": 100,
    "title": "Same Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "url": "https://leetcode.com/problems/same-tree/",
    "difficulty": "medium",
    "content": "# Same Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Same Tree](https://leetcode.com/problems/same-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "description": "Study Same Tree using the Pattern 13: Tree DFS - Recursive Preorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_101",
    "number": 101,
    "title": "Symmetric Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "url": "https://leetcode.com/problems/symmetric-tree/",
    "difficulty": "medium",
    "content": "# Symmetric Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Symmetric Tree](https://leetcode.com/problems/symmetric-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "description": "Study Symmetric Tree using the Pattern 13: Tree DFS - Recursive Preorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_102",
    "number": 102,
    "title": "Binary Tree Level Order Traversal",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 12: Tree BFS - Level Order Traversal",
    "url": "https://leetcode.com/problems/binary-tree-level-order-traversal/",
    "difficulty": "medium",
    "content": "# Binary Tree Level Order Traversal\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Binary Tree Level Order Traversal](https://leetcode.com/problems/binary-tree-level-order-traversal/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 12: Tree BFS - Level Order Traversal",
    "description": "Study Binary Tree Level Order Traversal using the Pattern 12: Tree BFS - Level Order Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_103",
    "number": 103,
    "title": "Binary Tree Zigzag Level Order Traversal",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 12: Tree BFS - Level Order Traversal",
    "url": "https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/",
    "difficulty": "medium",
    "content": "# Binary Tree Zigzag Level Order Traversal\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 12: Tree BFS - Level Order Traversal",
    "description": "Study Binary Tree Zigzag Level Order Traversal using the Pattern 12: Tree BFS - Level Order Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_104",
    "number": 104,
    "title": "Maximum Depth of Binary Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "url": "https://leetcode.com/problems/maximum-depth-of-binary-tree/",
    "difficulty": "medium",
    "content": "# Maximum Depth of Binary Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Depth of Binary Tree](https://leetcode.com/problems/maximum-depth-of-binary-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "description": "Study Maximum Depth of Binary Tree using the Pattern 15: Tree DFS - Recursive Postorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_105",
    "number": 105,
    "title": "Construct Binary Tree from Preorder and Inorder Traversal",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "url": "https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/",
    "difficulty": "medium",
    "content": "# Construct Binary Tree from Preorder and Inorder Traversal\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Construct Binary Tree from Preorder and Inorder Traversal](https://leetcode.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "description": "Study Construct Binary Tree from Preorder and Inorder Traversal using the Pattern 13: Tree DFS - Recursive Preorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_110",
    "number": 110,
    "title": "Balanced Binary Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "url": "https://leetcode.com/problems/balanced-binary-tree/",
    "difficulty": "medium",
    "content": "# Balanced Binary Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Balanced Binary Tree](https://leetcode.com/problems/balanced-binary-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "description": "Study Balanced Binary Tree using the Pattern 15: Tree DFS - Recursive Postorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_114",
    "number": 114,
    "title": "Flatten Binary Tree to Linked List",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "url": "https://leetcode.com/problems/flatten-binary-tree-to-linked-list/",
    "difficulty": "medium",
    "content": "# Flatten Binary Tree to Linked List\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Flatten Binary Tree to Linked List](https://leetcode.com/problems/flatten-binary-tree-to-linked-list/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "description": "Study Flatten Binary Tree to Linked List using the Pattern 13: Tree DFS - Recursive Preorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_120",
    "number": 120,
    "title": "Triangle",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "url": "https://leetcode.com/problems/triangle/",
    "difficulty": "medium",
    "content": "# Triangle\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Triangle](https://leetcode.com/problems/triangle/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "description": "Study Triangle using the Pattern 33: DP - 2D Array (Unique Paths on Grid) approach.",
    "has_content": false
  },
  {
    "id": "problem_121",
    "number": 121,
    "title": "Best Time to Buy and Sell Stock",
    "category": "VIII. Greedy Patterns",
    "pattern": "Pattern 50: Greedy - Buy/Sell Stock",
    "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock/",
    "difficulty": "medium",
    "content": "# Best Time to Buy and Sell Stock\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Best Time to Buy and Sell Stock](https://leetcode.com/problems/best-time-to-buy-and-sell-stock/)\n\n**Category:** VIII. Greedy Patterns\n**Pattern:** Pattern 50: Greedy - Buy/Sell Stock",
    "description": "Study Best Time to Buy and Sell Stock using the Pattern 50: Greedy - Buy/Sell Stock approach.",
    "has_content": false
  },
  {
    "id": "problem_122",
    "number": 122,
    "title": "Best Time to Buy and Sell Stock II",
    "category": "VIII. Greedy Patterns",
    "pattern": "Pattern 50: Greedy - Buy/Sell Stock",
    "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/",
    "difficulty": "medium",
    "content": "# Best Time to Buy and Sell Stock II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Best Time to Buy and Sell Stock II](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-ii/)\n\n**Category:** VIII. Greedy Patterns\n**Pattern:** Pattern 50: Greedy - Buy/Sell Stock",
    "description": "Study Best Time to Buy and Sell Stock II using the Pattern 50: Greedy - Buy/Sell Stock approach.",
    "has_content": false
  },
  {
    "id": "problem_123",
    "number": 123,
    "title": "Best Time to Buy and Sell Stock III",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 37: DP - Stock problems",
    "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/",
    "difficulty": "medium",
    "content": "# Best Time to Buy and Sell Stock III\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Best Time to Buy and Sell Stock III](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iii/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 37: DP - Stock problems",
    "description": "Study Best Time to Buy and Sell Stock III using the Pattern 37: DP - Stock problems approach.",
    "has_content": false
  },
  {
    "id": "problem_124",
    "number": 124,
    "title": "Binary Tree Maximum Path Sum",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "url": "https://leetcode.com/problems/binary-tree-maximum-path-sum/",
    "difficulty": "medium",
    "content": "# Binary Tree Maximum Path Sum\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Binary Tree Maximum Path Sum](https://leetcode.com/problems/binary-tree-maximum-path-sum/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "description": "Study Binary Tree Maximum Path Sum using the Pattern 15: Tree DFS - Recursive Postorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_125",
    "number": 125,
    "title": "Valid Palindrome",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 82: String - Palindrome Check (Two Pointers / Reverse)",
    "url": "https://leetcode.com/problems/valid-palindrome/",
    "difficulty": "medium",
    "content": "# Valid Palindrome\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Valid Palindrome](https://leetcode.com/problems/valid-palindrome/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 82: String - Palindrome Check (Two Pointers / Reverse)",
    "description": "Study Valid Palindrome using the Pattern 82: String - Palindrome Check (Two Pointers / Reverse) approach.",
    "has_content": false
  },
  {
    "id": "problem_127",
    "number": 127,
    "title": "Word Ladder",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 19: Graph BFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/word-ladder/",
    "difficulty": "medium",
    "content": "# Word Ladder\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Word Ladder](https://leetcode.com/problems/word-ladder/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 19: Graph BFS - Connected Components / Island Counting",
    "description": "Study Word Ladder using the Pattern 19: Graph BFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_130",
    "number": 130,
    "title": "Surrounded Regions",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 18: Graph DFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/surrounded-regions/",
    "difficulty": "medium",
    "content": "# Surrounded Regions\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Surrounded Regions](https://leetcode.com/problems/surrounded-regions/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 18: Graph DFS - Connected Components / Island Counting",
    "description": "Study Surrounded Regions using the Pattern 18: Graph DFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_131",
    "number": 131,
    "title": "Palindrome Partitioning",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 47: Backtracking - Palindrome Partitioning",
    "url": "https://leetcode.com/problems/palindrome-partitioning/",
    "difficulty": "medium",
    "content": "---\n### **131. Palindrome Partitioning**\n**Link to Problem:** [https://leetcode.com/problems/palindrome-partitioning/](https://leetcode.com/problems/palindrome-partitioning/)\n\n#### **1. Problem Statement**\nGiven a string `s`, the task is to partition it into one or more substrings such that every substring in the partition is a palindrome. The goal is to return all possible palindrome partitionings of `s`.\n\nFor example, if the input is `s = \"aab\"`, the output should be `[[\"a\",\"a\",\"b\"],[\"aa\",\"b\"]]`, as these are the only two ways to split the string into palindromic parts.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nA true brute-force approach would be to first generate every single possible way to partition the string, without any regard for whether the parts are palindromes. For a string of length `N`, there are `2^(N-1)` possible partitions. After generating a complete partition (e.g., `[\"a\", \"ab\"]` for the string `\"aab\"`), we would then iterate through its parts and verify if each one is a palindrome. If all parts are palindromes, we add this partition to our results.\n\nThis approach is highly inefficient because we waste time generating and then checking many invalid partitions. For instance, once we generate the partition `[\"a\", \"ab\"]`, we check \"ab\" and find it's not a palindrome, invalidating the entire partition. A smarter method would avoid exploring this path in the first place. Due to its complexity and inefficiency, coding this exact approach is not practical. We will instead focus on a refined recursive method.\n\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(N * 2^N)`. The number of partitions is exponential. For each partition, we check every substring, leading to a very high time complexity.\n*   **Space Complexity:** `O(N * 2^N)`. Storing all possible partitions before filtering would require exponential space.\n\n---\n\n### **3. Optimized Approach: Backtracking with Efficient Palindrome Checking**\n**Intuition:**\nInstead of generating all partitions and then checking them, we can build a valid partition step-by-step and stop exploring a path as soon as it violates the palindrome condition. This \"build and prune\" strategy is the essence of **Backtracking**.\n\nWe can think of this as a depth-first search (DFS) through the decision tree of all possible partitions.\n\n1.  Start at the beginning of the string (index 0).\n2.  Iterate forward from the current starting position, creating substrings. For each substring, check if it's a palindrome.\n3.  If the substring `s[start:i+1]` *is* a palindrome, we consider it a valid first piece of our current partition. We add it to our `current_path` and then recursively call our function on the *rest* of the string (starting from `i+1`).\n4.  After the recursive call returns (meaning it has explored all possibilities from that point), we **backtrack**. We remove the substring we just added from `current_path`. This allows us to explore other options, such as creating a longer palindromic substring from the original `start` position.\n5.  The base case for our recursion is when our starting position has reached the end of the string. This means we have successfully found a complete, valid partition, which we add to our final results.\n\nFor the crucial sub-problem of checking if a string is a palindrome, we can use a simple and efficient **two-pointer** technique. One pointer starts at the beginning of the substring, and the other at the end. They move inward, and if they ever point to characters that don't match, we know it's not a palindrome.\n\n**Walkthrough with `s = \"aab\"`:**\n- `dfs(start=0, path=[])`\n  - `i=0`: Substring `s[0:1]` is \"a\". It's a palindrome.\n    - Add \"a\" to path. `path = [\"a\"]`.\n    - Recurse: `dfs(start=1, path=[\"a\"])`.\n      - `i=1`: Substring `s[1:2]` is \"a\". It's a palindrome.\n        - Add \"a\" to path. `path = [\"a\", \"a\"]`.\n        - Recurse: `dfs(start=2, path=[\"a\", \"a\"])`.\n          - `i=2`: Substring `s[2:3]` is \"b\". It's a palindrome.\n            - Add \"b\" to path. `path = [\"a\", \"a\", \"b\"]`.\n            - Recurse: `dfs(start=3, path=[\"a\", \"a\", \"b\"])`.\n              - Base Case: `start == len(s)`. Add `[\"a\", \"a\", \"b\"]` to results.\n              - Return.\n            - Backtrack: remove \"b\". `path = [\"a\", \"a\"]`.\n          - Loop finishes. Return.\n      - Backtrack: remove \"a\". `path = [\"a\"]`.\n      - `i=2`: Substring `s[1:3]` is \"ab\". Not a palindrome. Continue.\n      - Loop finishes. Return.\n    - Backtrack: remove \"a\". `path = []`.\n  - `i=1`: Substring `s[0:2]` is \"aa\". It's a palindrome.\n    - Add \"aa\" to path. `path = [\"aa\"]`.\n    - Recurse: `dfs(start=2, path=[\"aa\"])`.\n      - `i=2`: Substring `s[2:3]` is \"b\". It's a palindrome.\n        - Add \"b\" to path. `path = [\"aa\", \"b\"]`.\n        - Recurse: `dfs(start=3, path=[\"aa\", \"b\"])`.\n          - Base Case: `start == len(s)`. Add `[\"aa\", \"b\"]` to results.\n          - Return.\n        - Backtrack: remove \"b\". `path = [\"aa\"]`.\n      - Loop finishes. Return.\n    - Backtrack: remove \"aa\". `path = []`.\n  - `i=2`: Substring `s[0:3]` is \"aab\". Not a palindrome. Continue.\n- Final results: `[[\"a\", \"a\", \"b\"], [\"aa\", \"b\"]]`.\n\n**Python Code:**\n```python\nfrom typing import List\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        results = []\n        current_path = []\n\n        def is_palindrome(sub: str) -> bool:\n            # This helper function uses a classic two-pointer check (moving inwards).\n            left, right = 0, len(sub) - 1\n            while left < right:\n                if sub[left] != sub[right]:\n                    return False\n                # Pointers move inward\n                left += 1\n                right -= 1\n            return True\n\n        def dfs(start_index: int):\n            # Base case: If we've reached the end of the string, we have found a valid partition.\n            if start_index >= len(s):\n                # We add a copy of current_path, not the reference itself.\n                results.append(list(current_path))\n                return\n\n            # Explore all possible substrings starting from start_index\n            for i in range(start_index, len(s)):\n                substring = s[start_index : i + 1]\n                \n                # If the substring is a palindrome, we can explore this path further.\n                if is_palindrome(substring):\n                    # 1. Choose: Add the palindrome to our current path.\n                    current_path.append(substring)\n                    \n                    # 2. Explore: Recurse on the rest of the string.\n                    dfs(i + 1)\n                    \n                    # 3. Unchoose (Backtrack): Remove the last-added palindrome to explore other possibilities.\n                    current_path.pop()\n\n        # Start the backtracking process from the beginning of the string.\n        dfs(0)\n        return results\n\n```\n\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(N * 2^N)`. In the worst-case scenario (e.g., a string `s = \"aaaaa\"`), every possible substring is a palindrome. There are `2^(N-1)` ways to partition the string. For each valid partition, we perform O(N) work to build the path and check for palindromes.\n*   **Space Complexity:** `O(N)`. The primary space usage comes from the recursion stack. In the worst case (a partition of N single-character palindromes), the recursion depth will be `N`. The `current_path` also stores substrings, which can take up to O(N) space.\n\n---\n### **4. Pattern Connection**\nThis problem is a quintessential example of **Backtracking**, a general algorithmic technique for finding all (or some) solutions to a computational problem by incrementally building candidates and abandoning a candidate (\"backtracking\") as soon as it's determined that it cannot possibly be completed to a valid solution.\n\nHowever, the efficiency of this backtracking algorithm hinges on a fast sub-routine: verifying if a given substring is a palindrome. This is where the **Two Pointers** pattern becomes essential. The `is_palindrome` helper function is a perfect, clean implementation of this pattern.\n\nIt's important to distinguish between two common two-pointer palindrome techniques:\n1.  **Two Pointers Moving Inward (used here):** Ideal for *verifying* if a *known* substring is a palindrome. You start with pointers at both ends and move them toward the center.\n2.  **Two Pointers Expanding From Center (the pattern name):** Ideal for *finding or counting all* palindromic substrings within a larger string. You iterate through each character as a potential center and expand two pointers *outward*.\n\nWhile the main algorithm is Backtracking, it relies on the Two Pointers pattern as a critical building block. This problem demonstrates how fundamental patterns are often composed to solve more complex problems. Recognizing that the repeated \"is this a palindrome?\" check could be optimized with two pointers is a key insight for an efficient solution.",
    "description": "Study Palindrome Partitioning using the Pattern 47: Backtracking - Palindrome Partitioning approach.",
    "has_content": true
  },
  {
    "id": "problem_132",
    "number": 132,
    "title": "Palindrome Partitioning II",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 47: Backtracking - Palindrome Partitioning",
    "url": "https://leetcode.com/problems/palindrome-partitioning-ii/",
    "difficulty": "medium",
    "content": "---\n### **132. Palindrome Partitioning II**\n**Link to Problem:** [https://leetcode.com/problems/palindrome-partitioning-ii/](https://leetcode.com/problems/palindrome-partitioning-ii/)\n\n#### **1. Problem Statement**\nGiven a string `s`, the task is to partition `s` into one or more substrings, where each substring is a palindrome. The goal is to find the minimum number of cuts required to achieve such a partitioning.\n\nFor example, for the string \"aab\", a palindrome partitioning is [\"aa\", \"b\"], which can be achieved with one cut. This is the minimum possible, so the answer is 1.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward approach is to explore all possible ways to partition the string. We can use recursion (or backtracking) to generate every valid partition.\n\nLet's define a recursive function, say `findMinCuts(startIndex)`, that calculates the minimum cuts needed for the substring `s[startIndex:]`.\n1.  The base case: If `startIndex` is at or beyond the end of the string, no more cuts are needed, so we return 0.\n2.  In the recursive step, we iterate from `startIndex` to the end of the string. Let the current index be `i`.\n3.  For each `i`, we consider the substring `s[startIndex : i+1]`.\n4.  If this substring is a palindrome, it's a valid first piece of our partition. We've made one cut (conceptually, after this piece). We then recursively call `findMinCuts(i+1)` to find the minimum cuts for the rest of the string.\n5.  The total cuts for this choice would be `1 + findMinCuts(i+1)`.\n6.  We try this for all possible `i` and take the minimum value among all valid palindrome partitions.\n\nTo avoid recomputing results for the same `startIndex`, we can add memoization, but the fundamental complexity remains high due to the repeated palindrome checks within the recursion.\n\n**Python Code:**\n```python\nimport sys\n\ndef is_palindrome(s, start, end):\n    \"\"\"Helper to check if a substring is a palindrome.\"\"\"\n    while start < end:\n        if s[start] != s[end]:\n            return False\n        start += 1\n        end -= 1\n    return True\n\ndef minCut_brute_force(s: str) -> int:\n    \"\"\"\n    Brute-force recursive solution to find the minimum cuts.\n    Note: This will likely result in a \"Time Limit Exceeded\" error on LeetCode.\n    \"\"\"\n    memo = {}\n\n    def find_min_cuts(start_index):\n        # If we've reached the end, no more partitions are needed.\n        if start_index == len(s):\n            return -1 # Base case: no cuts needed for an empty suffix\n\n        if start_index in memo:\n            return memo[start_index]\n\n        min_cuts = sys.maxsize\n        # Iterate through all possible end points for the current partition\n        for i in range(start_index, len(s)):\n            # Check if the substring s[start_index...i] is a palindrome\n            if is_palindrome(s, start_index, i):\n                # If it is, we make a cut here and find the cuts for the rest of the string.\n                cuts_for_rest = find_min_cuts(i + 1)\n                min_cuts = min(min_cuts, 1 + cuts_for_rest)\n        \n        memo[start_index] = min_cuts\n        return min_cuts\n\n    # The function returns (total_partitions - 1), so initial call gets the answer.\n    return find_min_cuts(0)\n\n# Example:\n# print(minCut_brute_force(\"aab\")) -> 1\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** O(2^n * n). In the worst case (e.g., a string like \"abcdef\"), the recursion tree can branch out significantly. At each step, we iterate up to `n` times and perform a palindrome check that can take O(n) time. Even with memoization, the number of states is `n`, and each state computation involves a loop and palindrome checks, leading to at least an O(n^2) complexity if `is_palindrome` is O(1) (precomputed), but here it is O(n), so it's closer to O(n^3). The unmemoized version is exponential.\n*   **Space Complexity:** O(n) for the recursion stack depth and the memoization dictionary.\n\n---\n\n#### **3. Optimized Approach: Two Pointers - Expanding From Center (Palindromes)**\n**Intuition:**\nThe brute-force approach is slow because it re-evaluates which substrings are palindromes over and over. This problem has optimal substructure and overlapping subproblems, making it a perfect candidate for Dynamic Programming.\n\nLet `dp[i]` be the minimum number of cuts needed for the prefix `s[0...i]`. Our goal is to find `dp[n-1]`.\n\nThe DP state transition would be:\n`dp[i] = min(dp[j-1] + 1)` for all `0 <= j <= i` where the substring `s[j...i]` is a palindrome.\nIf `s[0...i]` itself is a palindrome, `dp[i] = 0`.\n\nThis still requires an efficient way to check `is_palindrome(s[j...i])`. A naive check would make the overall solution O(n^3). We can optimize this by finding all palindromes first.\n\nThis is where the **Expanding From Center** pattern comes in. It's the most efficient way to find all palindromic substrings. We can iterate through every possible center of a palindrome (there are `2n-1` such centers: `n` single-character centers and `n-1` inter-character centers) and expand outwards with two pointers.\n\nBy integrating this pattern directly into our DP calculation, we can update the `dp` array as we discover palindromes.\n\n**Algorithm:**\n1.  Initialize a `dp` array of size `n`, where `dp[i]` will store the min cuts for `s[0...i]`. A safe initial value is `dp[i] = i`, as the worst case is cutting after each character (e.g., \"abc\" -> \"a|b|c\", 2 cuts for index 2).\n2.  Iterate through the string with an index `i` from `0` to `n-1`. This `i` will serve as the **center** of potential palindromes.\n3.  **Odd Length Palindromes:**\n    *   Use two pointers, `l = i` and `r = i`.\n    *   Expand outwards: while `l >= 0`, `r < n`, and `s[l] == s[r]`.\n    *   For each palindrome `s[l...r]` we find, we know we can form a partition of `s[0...r]` by taking this palindrome as the last segment. The number of cuts would be `1 +` (the min cuts for the part before it, `s[0...l-1]`).\n    *   So, we update `dp[r] = min(dp[r], dp[l-1] + 1)`. If `l` is 0, it means the entire prefix `s[0...r]` is a palindrome, requiring 0 cuts.\n    *   Decrement `l` and increment `r`.\n4.  **Even Length Palindromes:**\n    *   Use two pointers, `l = i` and `r = i + 1`.\n    *   Perform the same expansion and DP update logic as above.\n5.  After iterating through all centers, `dp[n-1]` will hold the minimum cuts for the entire string.\n\n**Example Walkthrough (`s = \"aab\"`):**\n*   `n = 3`, `dp = [0, 1, 2]` (initial worst-case cuts)\n*   **`i = 0` (center):**\n    *   **Odd:** `l=0, r=0` (`\"a\"`). `s[0]==s[0]`. `l=0` so it's a prefix. `dp[0] = min(dp[0], 0) = 0`.\n    *   **Even:** `l=0, r=1` (`\"aa\"`). `s[0]==s[1]`. `l=0`. `dp[1] = min(dp[1], 0) = 0`.\n*   **`i = 1` (center):**\n    *   **Odd:** `l=1, r=1` (`\"a\"`). `s[1]==s[1]`. Palindrome is `s[1...1]`. Update `dp[1] = min(dp[1], dp[0]+1) = min(0, 0+1) = 0`.\n    *   **Even:** `l=1, r=2` (`\"ab\"`). `s[1]!=s[2]`. Stop.\n*   **`i = 2` (center):**\n    *   **Odd:** `l=2, r=2` (`\"b\"`). `s[2]==s[2]`. Palindrome is `s[2...2]`. Update `dp[2] = min(dp[2], dp[1]+1) = min(2, 0+1) = 1`.\n    *   **Even:** `l=2, r=3`. `r` is out of bounds. Stop.\n\nFinal `dp` array: `[0, 0, 1]`. The answer is `dp[2] = 1`.\n\n**Python Code:**\n```python\ndef minCut(s: str) -> int:\n    n = len(s)\n    if n <= 1:\n        return 0\n\n    # dp[i] will store the minimum cuts for the prefix s[0...i]\n    # Initialize with the worst-case: cutting after every character.\n    cuts = list(range(n))\n\n    # Iterate through each character of the string, treating it as a potential\n    # center of a palindrome.\n    for i in range(n):\n        # --- Pattern: Two Pointers - Expanding from Center ---\n\n        # Case 1: Odd length palindrome, centered at i\n        # The pointers start at the center and expand outwards.\n        l, r = i, i\n        while l >= 0 and r < n and s[l] == s[r]:\n            # The substring s[l...r] is a palindrome.\n            # We can form a partition for s[0...r] by taking this palindrome as the last piece.\n            # The number of cuts is 1 (for the cut before s[l]) + the minimum cuts for s[0...l-1].\n            # If l is 0, the entire prefix s[0...r] is a palindrome, so 0 cuts are needed.\n            \n            # This is the cost for the prefix before this palindrome\n            prev_cuts = cuts[l-1] if l > 0 else -1\n            \n            # The new potential min cuts for prefix s[0...r]\n            new_cuts = prev_cuts + 1\n            \n            # Update the minimum cuts for the prefix ending at r\n            cuts[r] = min(cuts[r], new_cuts)\n            \n            # Expand the window\n            l -= 1\n            r += 1\n\n        # Case 2: Even length palindrome, centered between i and i+1\n        # The pointers start at i and i+1 and expand outwards.\n        l, r = i, i + 1\n        while l >= 0 and r < n and s[l] == s[r]:\n            # Same logic as the odd case.\n            prev_cuts = cuts[l-1] if l > 0 else -1\n            new_cuts = prev_cuts + 1\n            cuts[r] = min(cuts[r], new_cuts)\n            \n            # Expand the window\n            l -= 1\n            r += 1\n\n    # The final answer is the minimum cuts for the entire string s[0...n-1]\n    return cuts[n-1]\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** O(n^2). The outer loop runs `n` times. Inside, the two `while` loops also expand outwards. Each palindromic substring is discovered exactly once. Since there can be O(n^2) palindromic substrings in a string, the total time complexity is dominated by the nested expansion, resulting in O(n^2).\n*   **Space Complexity:** O(n). We use a DP array of size `n` to store the minimum cuts for each prefix.\n\n---\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of a complex problem whose core can be greatly simplified by the **Two Pointers - Expanding From Center** pattern. While the overarching structure is one of Dynamic Programming, the critical sub-problem is to efficiently identify all palindromic substrings.\n\nThe key signals in the problem that point to this pattern are:\n1.  **The word \"Palindrome\":** Palindromes are inherently symmetrical around a center. This structural property is perfectly suited for an algorithm that starts at the center and expands.\n2.  **Need for all substrings:** The DP formulation requires checking *every* possible suffix `s[j...i]` to see if it's a palindrome. Instead of doing these checks one by one, the \"Expanding From Center\" approach proactively *finds* all palindromes and uses them to update the DP state. This flips the logic from \"checking\" to \"finding\", which is far more efficient.\n\nBy iterating through all `2n-1` potential centers, this two-pointer pattern guarantees that we discover every single palindromic substring in O(n^2) time. Integrating this efficient discovery mechanism into the DP framework allows us to solve the problem within the time limits, transforming an exponential or O(n^3) solution into an optimized O(n^2) one.",
    "description": "Study Palindrome Partitioning II using the Pattern 47: Backtracking - Palindrome Partitioning approach.",
    "has_content": true
  },
  {
    "id": "problem_133",
    "number": 133,
    "title": "Clone Graph",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 22: Graph - Deep Copy / Cloning",
    "url": "https://leetcode.com/problems/clone-graph/",
    "difficulty": "medium",
    "content": "# Clone Graph\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Clone Graph](https://leetcode.com/problems/clone-graph/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 22: Graph - Deep Copy / Cloning",
    "description": "Study Clone Graph using the Pattern 22: Graph - Deep Copy / Cloning approach.",
    "has_content": false
  },
  {
    "id": "problem_134",
    "number": 134,
    "title": "Gas Station",
    "category": "VIII. Greedy Patterns",
    "pattern": "Pattern 51: Greedy - Gas Station Circuit",
    "url": "https://leetcode.com/problems/gas-station/",
    "difficulty": "medium",
    "content": "# Gas Station\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Gas Station](https://leetcode.com/problems/gas-station/)\n\n**Category:** VIII. Greedy Patterns\n**Pattern:** Pattern 51: Greedy - Gas Station Circuit",
    "description": "Study Gas Station using the Pattern 51: Greedy - Gas Station Circuit approach.",
    "has_content": false
  },
  {
    "id": "problem_136",
    "number": 136,
    "title": "Single Number",
    "category": "XI. Bit Manipulation Patterns",
    "pattern": "Pattern 65: Bitwise XOR - Finding Single/Missing Number",
    "url": "https://leetcode.com/problems/single-number/",
    "difficulty": "medium",
    "content": "# Single Number\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Single Number](https://leetcode.com/problems/single-number/)\n\n**Category:** XI. Bit Manipulation Patterns\n**Pattern:** Pattern 65: Bitwise XOR - Finding Single/Missing Number",
    "description": "Study Single Number using the Pattern 65: Bitwise XOR - Finding Single/Missing Number approach.",
    "has_content": false
  },
  {
    "id": "problem_137",
    "number": 137,
    "title": "Single Number II",
    "category": "XI. Bit Manipulation Patterns",
    "pattern": "Pattern 65: Bitwise XOR - Finding Single/Missing Number",
    "url": "https://leetcode.com/problems/single-number-ii/",
    "difficulty": "medium",
    "content": "# Single Number II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Single Number II](https://leetcode.com/problems/single-number-ii/)\n\n**Category:** XI. Bit Manipulation Patterns\n**Pattern:** Pattern 65: Bitwise XOR - Finding Single/Missing Number",
    "description": "Study Single Number II using the Pattern 65: Bitwise XOR - Finding Single/Missing Number approach.",
    "has_content": false
  },
  {
    "id": "problem_138",
    "number": 138,
    "title": "Copy List with Random Pointer",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 22: Graph - Deep Copy / Cloning",
    "url": "https://leetcode.com/problems/copy-list-with-random-pointer/",
    "difficulty": "medium",
    "content": "# Copy List with Random Pointer\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Copy List with Random Pointer](https://leetcode.com/problems/copy-list-with-random-pointer/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 22: Graph - Deep Copy / Cloning",
    "description": "Study Copy List with Random Pointer using the Pattern 22: Graph - Deep Copy / Cloning approach.",
    "has_content": false
  },
  {
    "id": "problem_139",
    "number": 139,
    "title": "Word Break",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 30: DP - 1D Array (Word Break Style)",
    "url": "https://leetcode.com/problems/word-break/",
    "difficulty": "medium",
    "content": "# Word Break\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Word Break](https://leetcode.com/problems/word-break/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 30: DP - 1D Array (Word Break Style)",
    "description": "Study Word Break using the Pattern 30: DP - 1D Array (Word Break Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_140",
    "number": 140,
    "title": "Word Break II",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 30: DP - 1D Array (Word Break Style)",
    "url": "https://leetcode.com/problems/word-break-ii/",
    "difficulty": "medium",
    "content": "# Word Break II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Word Break II](https://leetcode.com/problems/word-break-ii/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 30: DP - 1D Array (Word Break Style)",
    "description": "Study Word Break II using the Pattern 30: DP - 1D Array (Word Break Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_141",
    "number": 141,
    "title": "Linked List Cycle",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 2: Two Pointers - Fast & Slow (Cycle Detection)",
    "url": "https://leetcode.com/problems/linked-list-cycle/",
    "difficulty": "medium",
    "content": "---\n### **141. Linked List Cycle**\n**Link to Problem:** [https://leetcode.com/problems/linked-list-cycle/](https://leetcode.com/problems/linked-list-cycle/)\n\n#### **1. Problem Statement**\nGiven the `head` of a singly linked list, the task is to determine if the list has a cycle. A cycle exists if some node in the list can be reached again by continuously following the `next` pointer. The function should return `True` if a cycle is present, and `False` otherwise.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to detect a cycle is to remember every node we've already visited. As we traverse the list from the head, we can store each node in a data structure that allows for quick lookups, like a hash set. If we ever encounter a node that is already in our set of visited nodes, we've confirmed a cycle. If we reach the end of the list (`None`) without seeing any duplicates, no cycle exists.\n\n**Python Code:**\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\ndef hasCycle_brute_force(head: ListNode) -> bool:\n    # Use a hash set to store nodes we have already seen.\n    # Sets provide O(1) average time complexity for add and check operations.\n    visited_nodes = set()\n    \n    current_node = head\n    # Traverse the list until we reach the end (current_node is None).\n    while current_node:\n        # If the current node is already in our set, we've found a cycle.\n        if current_node in visited_nodes:\n            return True\n        \n        # If not, add the current node to the set and move to the next one.\n        visited_nodes.add(current_node)\n        current_node = current_node.next\n        \n    # If the loop completes, it means we reached the end of the list, so no cycle exists.\n    return False\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** **O(N)**, where N is the number of nodes in the linked list. In the worst-case scenario (no cycle), we must visit every node once. Operations on the hash set (adding and checking for existence) take O(1) time on average.\n\n*   **Space Complexity:** **O(N)**. In the worst-case scenario (no cycle), the `visited_nodes` set will store a reference to every single node in the list.\n\n### **3. Optimized Approach: Two Pointers - Fast & Slow (Cycle Detection)**\n**Intuition:**\nThis classic problem can be solved far more efficiently without using any extra space by applying the **Fast & Slow Pointers** pattern, also known as **Floyd's Tortoise and Hare Algorithm**.\n\nImagine two runners on a circular track: a fast runner and a slow runner. If they both start at the same point, the fast runner will eventually lap the slow runner. We can apply this exact analogy to a linked list.\n\n1.  We initialize two pointers, `slow` and `fast`, both pointing to the `head` of the list.\n2.  We move the `slow` pointer one step at a time (`slow = slow.next`).\n3.  We move the `fast` pointer two steps at a time (`fast = fast.next.next`).\n\nIf the list has no cycle, the `fast` pointer will inevitably reach the end of the list (`None`) before the `slow` pointer. If the list *does* have a cycle, the `fast` pointer will enter the cycle first, and the `slow` pointer will follow. Once both pointers are inside the cycle, the `fast` pointer will start gaining on the `slow` pointer from behind and is guaranteed to eventually meet it at the same node.\n\n**Example Walkthrough:**\nList: `1 -> 2 -> 3 -> 4 -> 2` (Node 4 points back to Node 2)\n*   **Start:** `slow` is at 1, `fast` is at 1.\n*   **Step 1:** `slow` moves to 2. `fast` moves to 3.\n*   **Step 2:** `slow` moves to 3. `fast` moves to 2 (from 3 -> 4 -> 2).\n*   **Step 3:** `slow` moves to 4. `fast` moves to 4 (from 2 -> 3 -> 4).\n*   **Meet!** `slow` and `fast` are now at the same node (4). We return `True`.\n\n**Python Code:**\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, x):\n#         self.val = x\n#         self.next = None\n\ndef hasCycle(head: ListNode) -> bool:\n    # Handle edge cases: an empty list or a list with one node cannot have a cycle.\n    if not head or not head.next:\n        return False\n\n    # Initialize two pointers at different speeds.\n    # The slow pointer moves one step at a time.\n    slow = head\n    # The fast pointer moves two steps at a time.\n    fast = head.next\n\n    # Traverse the list. The loop continues as long as the pointers haven't met.\n    while slow != fast:\n        # If the fast pointer or its next node is None, it means we've reached\n        # the end of the list, so there is no cycle.\n        if not fast or not fast.next:\n            return False\n        \n        # --- Core mechanic of the pattern ---\n        # Move the pointers at their respective speeds.\n        slow = slow.next\n        fast = fast.next.next\n\n    # If the loop terminates because slow == fast, a cycle was found.\n    return True\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** **O(N)**. Although the `fast` pointer moves twice as fast, the algorithm is still linear with respect to the number of nodes. In the worst case, the slow pointer traverses each node in the non-cyclic part and some part of the cycle before meeting the fast pointer.\n\n*   **Space Complexity:** **O(1)**. This is the key advantage of the pattern. We only use two pointers (`slow` and `fast`) for our traversal, consuming constant extra space regardless of the list's size.\n\n#### **4. Pattern Connection**\nThis problem is the quintessential example of the **Fast & Slow Pointers** pattern. The pattern is signaled when you need to analyze a sequential data structure, like a linked list, to find a structural property without using extra memory.\n\nThe key characteristics that make this pattern a perfect fit are:\n1.  **A Traversal Problem:** The core task involves moving through a linked list.\n2.  **A Need for Constant Space:** The brute-force solution requires O(N) space, which is often a constraint we want to optimize away.\n3.  **Detecting a \"Lapping\" Condition:** A cycle is fundamentally a state where a traversal will eventually \"lap\" itself and repeat. By using pointers moving at different speeds, we can deterministically detect this lapping behavior. If one pointer ever catches up to the other, a cycle must exist.\n\nWhenever you encounter a linked list problem asking to find the middle, detect a cycle, or find the start of a cycle, your first thought should be the Fast & Slow Pointers pattern. It transforms a space-intensive hashing problem into an elegant, constant-space pointer manipulation solution.",
    "description": "Study Linked List Cycle using the Pattern 2: Two Pointers - Fast & Slow (Cycle Detection) approach.",
    "has_content": true
  },
  {
    "id": "problem_143",
    "number": 143,
    "title": "Reorder List",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 73: Linked List - Reordering / Partitioning",
    "url": "https://leetcode.com/problems/reorder-list/",
    "difficulty": "medium",
    "content": "# Reorder List\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Reorder List](https://leetcode.com/problems/reorder-list/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 73: Linked List - Reordering / Partitioning",
    "description": "Study Reorder List using the Pattern 73: Linked List - Reordering / Partitioning approach.",
    "has_content": false
  },
  {
    "id": "problem_145",
    "number": 145,
    "title": "Binary Tree Postorder Traversal",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "url": "https://leetcode.com/problems/binary-tree-postorder-traversal/",
    "difficulty": "medium",
    "content": "# Binary Tree Postorder Traversal\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Binary Tree Postorder Traversal](https://leetcode.com/problems/binary-tree-postorder-traversal/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "description": "Study Binary Tree Postorder Traversal using the Pattern 15: Tree DFS - Recursive Postorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_146",
    "number": 146,
    "title": "LRU Cache",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/lru-cache/",
    "difficulty": "medium",
    "content": "# LRU Cache\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [LRU Cache](https://leetcode.com/problems/lru-cache/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study LRU Cache using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_150",
    "number": 150,
    "title": "Evaluate Reverse Polish Notation",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 60: Stack - Expression Evaluation (RPN/Infix)",
    "url": "https://leetcode.com/problems/evaluate-reverse-polish-notation/",
    "difficulty": "medium",
    "content": "# Evaluate Reverse Polish Notation\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Evaluate Reverse Polish Notation](https://leetcode.com/problems/evaluate-reverse-polish-notation/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 60: Stack - Expression Evaluation (RPN/Infix)",
    "description": "Study Evaluate Reverse Polish Notation using the Pattern 60: Stack - Expression Evaluation (RPN/Infix) approach.",
    "has_content": false
  },
  {
    "id": "problem_151",
    "number": 151,
    "title": "Reverse Words in a String",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 7: Two Pointers - String Reversal",
    "url": "https://leetcode.com/problems/reverse-words-in-a-string/",
    "difficulty": "medium",
    "content": "---\n### **151. Reverse Words in a String**\n**Link to Problem:** [https://leetcode.com/problems/reverse-words-in-a-string/](https://leetcode.com/problems/reverse-words-in-a-string/)\n\n#### **1. Problem Statement**\nGiven an input string `s` that contains words separated by one or more spaces, the task is to reverse the order of these words. The returned string must have only a single space separating the words and should not contain any leading or trailing spaces.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward, high-level approach is to use built-in functions provided by the programming language. The idea is to treat the string as a collection of words, reverse that collection, and then join them back into a single string.\n\n1.  **Split:** Use a built-in `split` function to break the string into a list of words. This function conveniently handles various amounts of whitespace between words.\n2.  **Reverse:** Reverse the resulting list of words.\n3.  **Join:** Use a built-in `join` function to combine the words from the reversed list into a new string, using a single space as the separator.\n\nThis approach is simple and readable but relies on the language's internal implementation, which often uses extra memory to store the intermediate list of words.\n\n**Python Code:**\n```python\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        # 1. Use s.split() to handle all whitespace cases (leading, trailing, multiple).\n        # It splits the string by any whitespace and returns a list of the words.\n        # For example, \"  hello   world  \" becomes ['hello', 'world'].\n        words = s.split()\n        \n        # 2. Reverse the list of words. Python's slice notation [::-1] is a concise\n        # way to create a reversed copy of the list.\n        reversed_words_list = words[::-1]\n        \n        # 3. Join the words in the reversed list with a single space in between.\n        return \" \".join(reversed_words_list)\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**, where N is the number of characters in the string. The `split()` operation takes O(N) time to iterate through the string, and the `join()` operation takes O(N) time to construct the new string. Reversing the list of words takes O(W) where W is the number of words, which is less than or equal to N.\n*   **Space Complexity: O(N)**. The `split()` method creates a new list of words, which in the worst case (e.g., \"a b c d e\") can contain roughly N/2 elements, storing all characters of the original string. The final joined string also requires O(N) space.\n\n### **3. Optimized Approach: Two Pointers - String Reversal**\n**Intuition:**\nTo optimize, especially in terms of avoiding built-in functions that hide complexity and potentially use more space, we can use the **Two Pointers** pattern. Instead of splitting the string into a list first, we can build the result by iterating through the string from right to left.\n\nThe strategy is as follows:\n1.  Initialize an empty list, `result`, which will store the words in their new, reversed order.\n2.  Use a pointer `i` to scan the input string `s` from the end (`len(s) - 1`) towards the beginning.\n3.  As we scan, we skip any trailing spaces. When we encounter the first non-space character, we know it's the end of a word. Let's mark this position as `end`.\n4.  From `end`, we continue scanning leftwards with `i` to find the beginning of that same word (i.e., until we hit a space or the start of the string).\n5.  Once we find the start, we have identified a complete word. We slice this word from the original string and append it to our `result` list.\n6.  We repeat this process until the pointer `i` has scanned the entire string.\n7.  Finally, we join the words in the `result` list with a single space.\n\nLet's walk through an example: `s = \"the sky is blue\"`\n\n1.  `result = []`, `i` starts at index 12 (`e`).\n2.  `i` is at a character. `end` is 12.\n3.  Scan left: `i` moves past `e`, `u`, `l`, `b`. At `i=8` (` `), we stop. The word is `s[9:13]` which is \"blue\".\n4.  Append \"blue\" to `result`. Now `result = [\"blue\"]`.\n5.  `i` continues scanning left, skipping the space at index 8.\n6.  `i` is at index 7 (`s`). `end` is 7. Scan left: `i` moves past `s`, `i`. At `i=5` (` `), we stop. The word is `s[6:8]` which is \"is\".\n7.  Append \"is\" to `result`. Now `result = [\"blue\", \"is\"]`.\n8.  This continues until we have processed all words. `result` becomes `[\"blue\", \"is\", \"sky\", \"the\"]`.\n9.  Join `result`: `\"blue is sky the\"`.\n\n**Python Code:**\n```python\nclass Solution:\n    def reverseWords(self, s: str) -> str:\n        # A list to store the words in reversed order\n        reversed_words = []\n        \n        # The main pointer `i` scans from the end of the string\n        i = len(s) - 1\n        \n        while i >= 0:\n            # First, skip any trailing spaces for the current word we are looking for\n            if s[i] == ' ':\n                i -= 1\n                continue\n            \n            # Now `i` is at the last character of a word.\n            # We use another pointer, `end`, to mark this position.\n            end = i\n            \n            # Move `i` to the left to find the start of the current word\n            while i >= 0 and s[i] != ' ':\n                i -= 1\n                \n            # A word has been found between `i+1` and `end`.\n            # Slice the string to get the word and append it.\n            reversed_words.append(s[i + 1 : end + 1])\n            \n        # Join the collected words with a single space.\n        return \" \".join(reversed_words)\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**. Although there is a nested `while` loop, the pointer `i` traverses the string from right to left only once. Each character is visited a constant number of times in total across both loops. Therefore, the complexity remains linear.\n*   **Space Complexity: O(N)**. We use a list, `reversed_words`, to store the words we find. In the worst-case scenario where the string is composed of single-character words (e.g., \"a b c\"), the space required for the list and the final output string is proportional to the length of the input string `s`.\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers** pattern, specifically for string manipulation. The key signal for this pattern is the need to parse or process a sequence (a string in this case) by defining and manipulating sub-sequences (words).\n\nInstead of a brute-force split that creates an intermediate data structure for all words at once, the two-pointer approach processes the string on the fly. We use a primary scanning pointer (`i`) and a temporary marker pointer (`end`) to define the boundaries of each word (`i+1` to `end`). This \"sliding window\" or \"segment definition\" created by the pointers is the core of the pattern. It allows us to partition the problem efficiently, handling one segment (word) at a time without needing to pre-process the entire string into a list, showcasing a more memory-aware and fundamental algorithmic technique.",
    "description": "Study Reverse Words in a String using the Pattern 7: Two Pointers - String Reversal approach.",
    "has_content": true
  },
  {
    "id": "problem_152",
    "number": 152,
    "title": "Maximum Product Subarray",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 81: Array - Kadane's Variant for Maximum Product",
    "url": "https://leetcode.com/problems/maximum-product-subarray/",
    "difficulty": "medium",
    "content": "# Maximum Product Subarray\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 81: Array - Kadane's Variant for Maximum Product",
    "description": "Study Maximum Product Subarray using the Pattern 81: Array - Kadane's Variant for Maximum Product approach.",
    "has_content": false
  },
  {
    "id": "problem_153",
    "number": 153,
    "title": "Find Minimum in Rotated Sorted Array",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "url": "https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/",
    "difficulty": "medium",
    "content": "# Find Minimum in Rotated Sorted Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find Minimum in Rotated Sorted Array](https://leetcode.com/problems/find-minimum-in-rotated-sorted-array/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "description": "Study Find Minimum in Rotated Sorted Array using the Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array approach.",
    "has_content": false
  },
  {
    "id": "problem_155",
    "number": 155,
    "title": "Min Stack",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/min-stack/",
    "difficulty": "medium",
    "content": "# Min Stack\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Min Stack](https://leetcode.com/problems/min-stack/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Min Stack using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_160",
    "number": 160,
    "title": "Intersection of Two Linked Lists",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 72: Linked List - Intersection Detection",
    "url": "https://leetcode.com/problems/intersection-of-two-linked-lists/",
    "difficulty": "medium",
    "content": "# Intersection of Two Linked Lists\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Intersection of Two Linked Lists](https://leetcode.com/problems/intersection-of-two-linked-lists/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 72: Linked List - Intersection Detection",
    "description": "Study Intersection of Two Linked Lists using the Pattern 72: Linked List - Intersection Detection approach.",
    "has_content": false
  },
  {
    "id": "problem_162",
    "number": 162,
    "title": "Find Peak Element",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "url": "https://leetcode.com/problems/find-peak-element/",
    "difficulty": "medium",
    "content": "# Find Peak Element\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find Peak Element](https://leetcode.com/problems/find-peak-element/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "description": "Study Find Peak Element using the Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array approach.",
    "has_content": false
  },
  {
    "id": "problem_167",
    "number": 167,
    "title": "Two Sum II - Input Array Is Sorted",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)",
    "url": "https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/",
    "difficulty": "medium",
    "content": "---\n### **167. Two Sum II - Input Array Is Sorted**\n**Link to Problem:** [https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/](https://leetcode.com/problems/two-sum-ii-input-array-is-sorted/)\n\n#### **1. Problem Statement**\nGiven a 1-indexed array of integers `numbers` that is sorted in non-decreasing order, the task is to find two numbers within it that add up to a specific `target` number. The output should be an array containing the 1-based indices of these two numbers. You can assume there is exactly one solution.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to consider every possible pair of numbers in the array. We can use a nested loop structure. The outer loop selects the first number, and the inner loop iterates through the rest of the array to find a second number. For each pair, we check if their sum equals the target. If it does, we have found our answer.\n\n**Python Code:**\n```python\nclass Solution:\n    def twoSum(self, numbers: list[int], target: int) -> list[int]:\n        n = len(numbers)\n        \n        # The outer loop iterates through each element to serve as the first number of our pair.\n        for i in range(n):\n            # The inner loop iterates through the subsequent elements for the second number.\n            # We start from i + 1 to avoid using the same element twice and to avoid duplicate pairs.\n            for j in range(i + 1, n):\n                # Check if the sum of the current pair matches the target.\n                if numbers[i] + numbers[j] == target:\n                    # The problem asks for 1-based indices, so we add 1 to our 0-based indices.\n                    return [i + 1, j + 1]\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(n²)`\n    This is due to the nested loops. For each element in the array, we iterate through almost all the other elements, leading to a quadratic number of comparisons in the worst case.\n\n*   **Space Complexity:** `O(1)`\n    The space required is constant as we only use a few variables for loop counters and do not allocate any additional data structures whose size depends on the input.\n\n#### **3. Optimized Approach: Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)**\n**Intuition:**\nThe brute-force approach completely ignores a critical piece of information: **the input array is sorted**. This is a massive hint to use a more efficient approach. The \"Two Pointers - Converging\" pattern is tailor-made for this scenario.\n\nThe strategy is as follows:\n1.  Initialize two pointers: `left` at the beginning of the array (index 0) and `right` at the end of the array (index `len(numbers) - 1`).\n2.  Calculate the sum of the values at these two pointers: `current_sum = numbers[left] + numbers[right]`.\n3.  Compare `current_sum` with the `target`:\n    *   If `current_sum == target`, we've found our pair. We can return their 1-based indices.\n    *   If `current_sum < target`, our sum is too small. Since the array is sorted, the only way to increase the sum is to use a larger number. We achieve this by moving the `left` pointer one step to the right (`left += 1`).\n    *   If `current_sum > target`, our sum is too large. We need to decrease it by using a smaller number. We do this by moving the `right` pointer one step to the left (`right -= 1`).\n4.  We repeat this process, \"converging\" the pointers towards each other, until they meet or cross. This systematically eliminates possibilities without ever needing to check every pair.\n\n**Example Walkthrough:** `numbers = [2, 7, 11, 15]`, `target = 9`\n- **Start:** `left = 0` (value 2), `right = 3` (value 15).\n- **Step 1:** `current_sum = 2 + 15 = 17`.\n- **Logic:** `17 > 9` (target), so the sum is too big. We must decrease it.\n- **Action:** Move the `right` pointer inward: `right` is now `2`.\n- **Step 2:** `left = 0` (value 2), `right = 2` (value 11). `current_sum = 2 + 11 = 13`.\n- **Logic:** `13 > 9` (target), still too big.\n- **Action:** Move `right` pointer inward again: `right` is now `1`.\n- **Step 3:** `left = 0` (value 2), `right = 1` (value 7). `current_sum = 2 + 7 = 9`.\n- **Logic:** `9 == 9` (target). We found the solution!\n- **Result:** Return `[left + 1, right + 1]`, which is `[1, 2]`.\n\n**Python Code:**\n```python\nclass Solution:\n    def twoSum(self, numbers: list[int], target: int) -> list[int]:\n        # Initialize two pointers, one at the very beginning and one at the very end.\n        left, right = 0, len(numbers) - 1\n\n        # Loop until the two pointers cross each other.\n        # Since a solution is guaranteed, the loop will always find it before they cross.\n        while left < right:\n            # Calculate the sum of the values at the current pointer positions.\n            current_sum = numbers[left] + numbers[right]\n\n            if current_sum == target:\n                # Found the solution! Return the 1-based indices.\n                return [left + 1, right + 1]\n            elif current_sum < target:\n                # The sum is too small. To increase it, we must use a larger number.\n                # The only way to do this is to move the left pointer forward.\n                left += 1\n            else: # current_sum > target\n                # The sum is too large. To decrease it, we must use a smaller number.\n                # The only way to do this is to move the right pointer backward.\n                right -= 1\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(n)`\n    In the worst-case scenario, the `left` and `right` pointers will collectively scan the entire array once. Each step of the `while` loop moves one of the pointers closer to the other, so we perform at most `n` comparisons. This is a significant improvement over the `O(n²)` brute-force approach.\n\n*   **Space Complexity:** `O(1)`\n    Just like the brute-force method, we only use a fixed number of variables (`left`, `right`, `current_sum`). The memory usage is constant and independent of the input array's size.\n\n#### **4. Pattern Connection**\nThis problem is the canonical example of the **Two Pointers - Converging** pattern. The signals that point directly to this pattern are:\n\n1.  **A Sorted Array:** This is the most crucial prerequisite. The sorted property is what gives us the logic to move the pointers intelligently. If the current sum is too small, we know for a fact that moving the `left` pointer to the right is the only way to increase the sum. If the sum is too large, moving `right` to the left is the only way to decrease it. Without this sorted property, our logic would fail.\n2.  **Finding a Pair or a Target Value:** The goal is to find a *pair* of elements that satisfy a specific condition, usually related to their sum (e.g., equals `target`, is less than `target`, etc.).\n\nBy placing pointers at the two extremes and moving them inwards based on their sum, we efficiently narrow down the search space. Each comparison allows us to discard either the current `left` element or the current `right` element, along with all the pairs they could have formed with elements we've already passed. This linear-time traversal is the hallmark of the two-pointer technique on sorted arrays.",
    "description": "Study Two Sum II - Input Array Is Sorted using the Pattern 1: Two Pointers - Converging (Sorted Array Target Sum) approach.",
    "has_content": true
  },
  {
    "id": "problem_173",
    "number": 173,
    "title": "Binary Search Tree Iterator",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "url": "https://leetcode.com/problems/binary-search-tree-iterator/",
    "difficulty": "medium",
    "content": "# Binary Search Tree Iterator\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "description": "Study Binary Search Tree Iterator using the Pattern 14: Tree DFS - Recursive Inorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_188",
    "number": 188,
    "title": "Best Time to Buy and Sell Stock IV",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 37: DP - Stock problems",
    "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/",
    "difficulty": "medium",
    "content": "# Best Time to Buy and Sell Stock IV\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Best Time to Buy and Sell Stock IV](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-iv/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 37: DP - Stock problems",
    "description": "Study Best Time to Buy and Sell Stock IV using the Pattern 37: DP - Stock problems approach.",
    "has_content": false
  },
  {
    "id": "problem_189",
    "number": 189,
    "title": "Rotate Array",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 74: Array/Matrix - In-place Rotation",
    "url": "https://leetcode.com/problems/rotate-array/",
    "difficulty": "medium",
    "content": "# Rotate Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Rotate Array](https://leetcode.com/problems/rotate-array/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 74: Array/Matrix - In-place Rotation",
    "description": "Study Rotate Array using the Pattern 74: Array/Matrix - In-place Rotation approach.",
    "has_content": false
  },
  {
    "id": "problem_191",
    "number": 191,
    "title": "Number of 1 Bits",
    "category": "XI. Bit Manipulation Patterns",
    "pattern": "Pattern 66: Bitwise AND - Counting Set Bits (Hamming Weight)",
    "url": "https://leetcode.com/problems/number-of-1-bits/",
    "difficulty": "medium",
    "content": "# Number of 1 Bits\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Number of 1 Bits](https://leetcode.com/problems/number-of-1-bits/)\n\n**Category:** XI. Bit Manipulation Patterns\n**Pattern:** Pattern 66: Bitwise AND - Counting Set Bits (Hamming Weight)",
    "description": "Study Number of 1 Bits using the Pattern 66: Bitwise AND - Counting Set Bits (Hamming Weight) approach.",
    "has_content": false
  },
  {
    "id": "problem_198",
    "number": 198,
    "title": "House Robber",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 26: DP - 1D Array (Fibonacci Style)",
    "url": "https://leetcode.com/problems/house-robber/",
    "difficulty": "medium",
    "content": "# House Robber\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [House Robber](https://leetcode.com/problems/house-robber/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 26: DP - 1D Array (Fibonacci Style)",
    "description": "Study House Robber using the Pattern 26: DP - 1D Array (Fibonacci Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_199",
    "number": 199,
    "title": "Binary Tree Right Side View",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 12: Tree BFS - Level Order Traversal",
    "url": "https://leetcode.com/problems/binary-tree-right-side-view/",
    "difficulty": "medium",
    "content": "# Binary Tree Right Side View\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Binary Tree Right Side View](https://leetcode.com/problems/binary-tree-right-side-view/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 12: Tree BFS - Level Order Traversal",
    "description": "Study Binary Tree Right Side View using the Pattern 12: Tree BFS - Level Order Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_200",
    "number": 200,
    "title": "Number of Islands",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/number-of-islands/",
    "difficulty": "medium",
    "content": "# Number of Islands\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Number of Islands](https://leetcode.com/problems/number-of-islands/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study Number of Islands using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_202",
    "number": 202,
    "title": "Happy Number",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 2: Two Pointers - Fast & Slow (Cycle Detection)",
    "url": "https://leetcode.com/problems/happy-number/",
    "difficulty": "medium",
    "content": "---\n### **202. Happy Number**\n**Link to Problem:** [https://leetcode.com/problems/happy-number/](https://leetcode.com/problems/happy-number/)\n\n#### **1. Problem Statement**\nGiven a positive integer `n`, determine if it is a \"happy number.\" A number is happy if the process of repeatedly replacing it with the sum of the squares of its digits eventually leads to the number 1. If the process enters a repeating cycle that does not include 1, the number is not happy. The function should return `True` if `n` is happy, and `False` otherwise.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe core of this problem is detecting whether the sequence of numbers generated ever repeats itself. If we generate a number we've already seen, we have detected a cycle. The most straightforward way to keep track of the numbers we've already encountered is to use a hash set (or any data structure with fast lookups).\n\nThe process is as follows:\n1. Start with the given number `n`.\n2. In a loop, calculate the next number in the sequence (the sum of the squares of the digits).\n3. Before calculating the next number, check if the current number is already in our set of seen numbers.\n    * If it is, we've found a cycle. Since we haven't reached 1 yet, this must be an unhappy cycle, so we return `False`.\n    * If it isn't, we add the current number to our set and continue.\n4. The loop terminates if the number becomes 1 (a happy number) or if a cycle is detected.\n\n**Python Code:**\n```python\ndef isHappy(n: int) -> bool:\n    # A set to store numbers we have already seen in the sequence.\n    # This is crucial for detecting a cycle.\n    seen_numbers = set()\n\n    # The loop continues as long as n is not 1.\n    # If we encounter a number already in `seen_numbers`, we've found a cycle.\n    while n != 1 and n not in seen_numbers:\n        # Add the current number to our record before calculating the next one.\n        seen_numbers.add(n)\n        \n        # Calculate the sum of the squares of the digits.\n        sum_of_squares = 0\n        current_n = n\n        while current_n > 0:\n            digit = current_n % 10\n            sum_of_squares += digit * digit\n            current_n //= 10\n        \n        # Update n to be the next number in the sequence.\n        n = sum_of_squares\n        \n    # After the loop, if n is 1, it's a happy number.\n    # If the loop exited because n was found in `seen_numbers`, n will not be 1.\n    return n == 1\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(log n)**\n    The time complexity is not dependent on the number of integers we have to check, but rather the \"length\" of the sequence for a given `n`. The number of digits in `n` is approximately `log10(n)`. Calculating the sum of squares for a number `k` takes `O(log k)` time. The sequence of numbers does not grow infinitely; it is proven that any unhappy number will eventually enter the cycle `4 → 16 → 37 → 58 → 89 → 145 → 42 → 20 → 4`. Thus, the number of steps is bounded by a constant after the initial calculation, leading to an effective `O(log n)` complexity dominated by the initial, larger numbers.\n\n*   **Space Complexity: O(log n)**\n    The space complexity is determined by the `seen_numbers` set. In the worst case, we store a number of values proportional to the number of steps it takes to find a cycle. As with time complexity, this is related to the magnitude of the numbers processed, resulting in `O(log n)` space.\n\n---\n\n### **3. Optimized Approach: Two Pointers - Fast & Slow (Cycle Detection)**\n**Intuition:**\nThe hash set approach works, but it requires extra space. We can optimize this by realizing that the problem is fundamentally about **cycle detection in a sequence**. This is a classic use case for Floyd's Cycle-Finding Algorithm, also known as the \"Tortoise and the Hare\" or **Fast & Slow Pointer** algorithm.\n\nImagine the sequence of numbers (`n_0`, `n_1`, `n_2`, ...) as a linked list where each number is a node and the \"sum of squared digits\" function is the `next` pointer.\n- `n_1 = get_next(n_0)`\n- `n_2 = get_next(n_1)`\n\nWe can use two pointers to traverse this conceptual list:\n1.  A `slow` pointer that moves one step at a time (`slow = get_next(slow)`).\n2.  A `fast` pointer that moves two steps at a time (`fast = get_next(get_next(fast))`).\n\nIf there is no cycle, the `fast` pointer will reach the end (in our case, the number 1) first. If there *is* a cycle, the `fast` pointer will eventually enter the cycle and lap the `slow` pointer, meaning they will point to the same number at some point.\n\n**Example Walkthrough (n = 19):**\n- **Helper function:** `get_next(num)` calculates the sum of the squares of digits. `get_next(19) = 1² + 9² = 82`.\n- **Initial State:** `slow = 19`, `fast = 19`.\n- **Iteration 1:**\n    - `slow` moves 1 step: `slow = get_next(19) = 82`.\n    - `fast` moves 2 steps: `fast = get_next(get_next(19)) = get_next(82) = 68`.\n    - `slow` (82) != `fast` (68).\n- **Iteration 2:**\n    - `slow` moves 1 step: `slow = get_next(82) = 68`.\n    - `fast` moves 2 steps: `fast = get_next(get_next(68)) = get_next(100) = 1`.\n    - `slow` (68) != `fast` (1).\n- **Termination:** The `fast` pointer has reached 1. We exit the loop and check if `fast == 1`. It is, so we return `True`.\n\n**Python Code:**\n```python\ndef isHappy(n: int) -> bool:\n    \n    def get_next(number: int) -> int:\n        \"\"\"Helper function to compute the sum of the squares of the digits.\"\"\"\n        total_sum = 0\n        while number > 0:\n            digit = number % 10\n            total_sum += digit * digit\n            number //= 10\n        return total_sum\n\n    # Initialize two pointers starting from the original number.\n    slow_runner = n\n    fast_runner = get_next(n)\n\n    # The loop continues as long as the fast runner hasn't reached 1\n    # and the two pointers haven't met.\n    while fast_runner != 1 and slow_runner != fast_runner:\n        # Slow pointer moves one step.\n        slow_runner = get_next(slow_runner)\n        # Fast pointer moves two steps.\n        fast_runner = get_next(get_next(fast_runner))\n\n    # If the loop terminated, one of two conditions was met:\n    # 1. fast_runner == 1: We found the happy number termination.\n    # 2. slow_runner == fast_runner: A cycle was detected. Since fast_runner is not 1,\n    #    it must be an unhappy cycle.\n    return fast_runner == 1\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(log n)**\n    The time complexity remains the same as the hash set approach. The number of steps until the pointers meet or reach 1 is bounded, and each step's calculation takes `O(log k)` time for a number `k`.\n\n*   **Space Complexity: O(1)**\n    This is the key improvement. We are no longer storing a history of seen numbers. We only use a fixed number of variables (`slow_runner`, `fast_runner`) to solve the problem, regardless of the input size. This gives us constant space complexity.\n\n---\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Fast & Slow Pointer** pattern for cycle detection, even though it doesn't involve an explicit linked list data structure.\n\nThe signal to use this pattern arises when you have a sequence generated by repeatedly applying a function (`n -> f(n) -> f(f(n)) -> ...`), and you need to determine if this sequence ever enters a repeating cycle.\n\nThe key characteristics of the \"Happy Number\" problem that point to this pattern are:\n1.  **A Sequence of States:** The problem is defined by a sequence of numbers, where each number is derived from the previous one.\n2.  **Two Possible Endings:** The sequence either terminates at a specific value (1) or falls into a loop.\n3.  **The Need for Cycle Detection:** The core task is to distinguish between these two outcomes, which is precisely what cycle detection algorithms are for.\n\nBy conceptualizing the numbers as nodes and the transformation function as the `next` pointer, the problem becomes identical to \"Linked List Cycle II\". The Fast & Slow Pointer approach provides a highly efficient, `O(1)` space solution, making it the optimal way to solve problems with this underlying structure.",
    "description": "Study Happy Number using the Pattern 2: Two Pointers - Fast & Slow (Cycle Detection) approach.",
    "has_content": true
  },
  {
    "id": "problem_206",
    "number": 206,
    "title": "Reverse Linked List",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 69: Linked List - In-place Reversal",
    "url": "https://leetcode.com/problems/reverse-linked-list/",
    "difficulty": "medium",
    "content": "# Reverse Linked List\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Reverse Linked List](https://leetcode.com/problems/reverse-linked-list/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 69: Linked List - In-place Reversal",
    "description": "Study Reverse Linked List using the Pattern 69: Linked List - In-place Reversal approach.",
    "has_content": false
  },
  {
    "id": "problem_207",
    "number": 207,
    "title": "Course Schedule",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "url": "https://leetcode.com/problems/course-schedule/",
    "difficulty": "medium",
    "content": "# Course Schedule\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Course Schedule](https://leetcode.com/problems/course-schedule/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "description": "Study Course Schedule using the Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_208",
    "number": 208,
    "title": "Implement Trie (Prefix Tree)",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/implement-trie-prefix-tree/",
    "difficulty": "medium",
    "content": "# Implement Trie (Prefix Tree)\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Implement Trie (Prefix Tree)](https://leetcode.com/problems/implement-trie-prefix-tree/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Implement Trie (Prefix Tree) using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_209",
    "number": 209,
    "title": "Minimum Size Subarray Sum",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/minimum-size-subarray-sum/",
    "difficulty": "medium",
    "content": "# Minimum Size Subarray Sum\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Size Subarray Sum](https://leetcode.com/problems/minimum-size-subarray-sum/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Minimum Size Subarray Sum using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_210",
    "number": 210,
    "title": "Course Schedule II",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "url": "https://leetcode.com/problems/course-schedule-ii/",
    "difficulty": "medium",
    "content": "# Course Schedule II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Course Schedule II](https://leetcode.com/problems/course-schedule-ii/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "description": "Study Course Schedule II using the Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_211",
    "number": 211,
    "title": "Design Add and Search Words Data Structure",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-add-and-search-words-data-structure/",
    "difficulty": "medium",
    "content": "# Design Add and Search Words Data Structure\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design Add and Search Words Data Structure](https://leetcode.com/problems/design-add-and-search-words-data-structure/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design Add and Search Words Data Structure using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_212",
    "number": 212,
    "title": "Word Search II",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 45: Backtracking - Word Search / Path Finding in Grid",
    "url": "https://leetcode.com/problems/word-search-ii/",
    "difficulty": "medium",
    "content": "# Word Search II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Word Search II](https://leetcode.com/problems/word-search-ii/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 45: Backtracking - Word Search / Path Finding in Grid",
    "description": "Study Word Search II using the Pattern 45: Backtracking - Word Search / Path Finding in Grid approach.",
    "has_content": false
  },
  {
    "id": "problem_213",
    "number": 213,
    "title": "House Robber II",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 26: DP - 1D Array (Fibonacci Style)",
    "url": "https://leetcode.com/problems/house-robber-ii/",
    "difficulty": "medium",
    "content": "# House Robber II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [House Robber II](https://leetcode.com/problems/house-robber-ii/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 26: DP - 1D Array (Fibonacci Style)",
    "description": "Study House Robber II using the Pattern 26: DP - 1D Array (Fibonacci Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_214",
    "number": 214,
    "title": "Shortest Palindrome",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 87: String Matching - Naive / KMP / Rabin-Karp",
    "url": "https://leetcode.com/problems/shortest-palindrome/",
    "difficulty": "medium",
    "content": "# Shortest Palindrome\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Shortest Palindrome](https://leetcode.com/problems/shortest-palindrome/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 87: String Matching - Naive / KMP / Rabin-Karp",
    "description": "Study Shortest Palindrome using the Pattern 87: String Matching - Naive / KMP / Rabin-Karp approach.",
    "has_content": false
  },
  {
    "id": "problem_215",
    "number": 215,
    "title": "Kth Largest Element in an Array",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "url": "https://leetcode.com/problems/kth-largest-element-in-an-array/",
    "difficulty": "medium",
    "content": "# Kth Largest Element in an Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Kth Largest Element in an Array](https://leetcode.com/problems/kth-largest-element-in-an-array/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "description": "Study Kth Largest Element in an Array using the Pattern 37: Heap - Top K Elements (Selection/Frequency) approach.",
    "has_content": false
  },
  {
    "id": "problem_219",
    "number": 219,
    "title": "Contains Duplicate II",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/contains-duplicate-ii/",
    "difficulty": "medium",
    "content": "# Contains Duplicate II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Contains Duplicate II](https://leetcode.com/problems/contains-duplicate-ii/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Contains Duplicate II using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_221",
    "number": 221,
    "title": "Maximal Square",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "url": "https://leetcode.com/problems/maximal-square/",
    "difficulty": "medium",
    "content": "# Maximal Square\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximal Square](https://leetcode.com/problems/maximal-square/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "description": "Study Maximal Square using the Pattern 33: DP - 2D Array (Unique Paths on Grid) approach.",
    "has_content": false
  },
  {
    "id": "problem_224",
    "number": 224,
    "title": "Basic Calculator",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 60: Stack - Expression Evaluation (RPN/Infix)",
    "url": "https://leetcode.com/problems/basic-calculator/",
    "difficulty": "medium",
    "content": "# Basic Calculator\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Basic Calculator](https://leetcode.com/problems/basic-calculator/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 60: Stack - Expression Evaluation (RPN/Infix)",
    "description": "Study Basic Calculator using the Pattern 60: Stack - Expression Evaluation (RPN/Infix) approach.",
    "has_content": false
  },
  {
    "id": "problem_225",
    "number": 225,
    "title": "Implement Stack using Queues",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/implement-stack-using-queues/",
    "difficulty": "medium",
    "content": "# Implement Stack using Queues\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Implement Stack using Queues](https://leetcode.com/problems/implement-stack-using-queues/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Implement Stack using Queues using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_226",
    "number": 226,
    "title": "Invert Binary Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "url": "https://leetcode.com/problems/invert-binary-tree/",
    "difficulty": "medium",
    "content": "# Invert Binary Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Invert Binary Tree](https://leetcode.com/problems/invert-binary-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "description": "Study Invert Binary Tree using the Pattern 13: Tree DFS - Recursive Preorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_227",
    "number": 227,
    "title": "Basic Calculator II",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 60: Stack - Expression Evaluation (RPN/Infix)",
    "url": "https://leetcode.com/problems/basic-calculator-ii/",
    "difficulty": "medium",
    "content": "# Basic Calculator II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Basic Calculator II](https://leetcode.com/problems/basic-calculator-ii/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 60: Stack - Expression Evaluation (RPN/Infix)",
    "description": "Study Basic Calculator II using the Pattern 60: Stack - Expression Evaluation (RPN/Infix) approach.",
    "has_content": false
  },
  {
    "id": "problem_230",
    "number": 230,
    "title": "Kth Smallest Element in a BST",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "url": "https://leetcode.com/problems/kth-smallest-element-in-a-bst/",
    "difficulty": "medium",
    "content": "# Kth Smallest Element in a BST\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Kth Smallest Element in a BST](https://leetcode.com/problems/kth-smallest-element-in-a-bst/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "description": "Study Kth Smallest Element in a BST using the Pattern 14: Tree DFS - Recursive Inorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_231",
    "number": 231,
    "title": "Power of Two",
    "category": "XI. Bit Manipulation Patterns",
    "pattern": "Pattern 68: Bitwise Operations - Power of Two/Four Check",
    "url": "https://leetcode.com/problems/power-of-two/",
    "difficulty": "medium",
    "content": "# Power of Two\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Power of Two](https://leetcode.com/problems/power-of-two/)\n\n**Category:** XI. Bit Manipulation Patterns\n**Pattern:** Pattern 68: Bitwise Operations - Power of Two/Four Check",
    "description": "Study Power of Two using the Pattern 68: Bitwise Operations - Power of Two/Four Check approach.",
    "has_content": false
  },
  {
    "id": "problem_232",
    "number": 232,
    "title": "Implement Queue using Stacks",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/implement-queue-using-stacks/",
    "difficulty": "medium",
    "content": "# Implement Queue using Stacks\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Implement Queue using Stacks](https://leetcode.com/problems/implement-queue-using-stacks/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Implement Queue using Stacks using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_234",
    "number": 234,
    "title": "Palindrome Linked List",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 69: Linked List - In-place Reversal",
    "url": "https://leetcode.com/problems/palindrome-linked-list/",
    "difficulty": "medium",
    "content": "# Palindrome Linked List\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Palindrome Linked List](https://leetcode.com/problems/palindrome-linked-list/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 69: Linked List - In-place Reversal",
    "description": "Study Palindrome Linked List using the Pattern 69: Linked List - In-place Reversal approach.",
    "has_content": false
  },
  {
    "id": "problem_235",
    "number": 235,
    "title": "Lowest Common Ancestor of a Binary Search Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 16: Tree - Lowest Common Ancestor (LCA) Finding",
    "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/",
    "difficulty": "medium",
    "content": "# Lowest Common Ancestor of a Binary Search Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Lowest Common Ancestor of a Binary Search Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-search-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 16: Tree - Lowest Common Ancestor (LCA) Finding",
    "description": "Study Lowest Common Ancestor of a Binary Search Tree using the Pattern 16: Tree - Lowest Common Ancestor (LCA) Finding approach.",
    "has_content": false
  },
  {
    "id": "problem_236",
    "number": 236,
    "title": "Lowest Common Ancestor of a Binary Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 16: Tree - Lowest Common Ancestor (LCA) Finding",
    "url": "https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/",
    "difficulty": "medium",
    "content": "# Lowest Common Ancestor of a Binary Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Lowest Common Ancestor of a Binary Tree](https://leetcode.com/problems/lowest-common-ancestor-of-a-binary-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 16: Tree - Lowest Common Ancestor (LCA) Finding",
    "description": "Study Lowest Common Ancestor of a Binary Tree using the Pattern 16: Tree - Lowest Common Ancestor (LCA) Finding approach.",
    "has_content": false
  },
  {
    "id": "problem_238",
    "number": 238,
    "title": "Product of Array Except Self",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 77: Array - Product Except Self (Prefix/Suffix Products)",
    "url": "https://leetcode.com/problems/product-of-array-except-self/",
    "difficulty": "medium",
    "content": "# Product of Array Except Self\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Product of Array Except Self](https://leetcode.com/problems/product-of-array-except-self/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 77: Array - Product Except Self (Prefix/Suffix Products)",
    "description": "Study Product of Array Except Self using the Pattern 77: Array - Product Except Self (Prefix/Suffix Products) approach.",
    "has_content": false
  },
  {
    "id": "problem_239",
    "number": 239,
    "title": "Sliding Window Maximum",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 10: Sliding Window - Monotonic Queue for Max/Min",
    "url": "https://leetcode.com/problems/sliding-window-maximum/",
    "difficulty": "medium",
    "content": "# Sliding Window Maximum\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Sliding Window Maximum](https://leetcode.com/problems/sliding-window-maximum/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 10: Sliding Window - Monotonic Queue for Max/Min",
    "description": "Study Sliding Window Maximum using the Pattern 10: Sliding Window - Monotonic Queue for Max/Min approach.",
    "has_content": false
  },
  {
    "id": "problem_241",
    "number": 241,
    "title": "Different Ways to Add Parentheses",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 35: DP - Catalan Numbers",
    "url": "https://leetcode.com/problems/different-ways-to-add-parentheses/",
    "difficulty": "medium",
    "content": "# Different Ways to Add Parentheses\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Different Ways to Add Parentheses](https://leetcode.com/problems/different-ways-to-add-parentheses/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 35: DP - Catalan Numbers",
    "description": "Study Different Ways to Add Parentheses using the Pattern 35: DP - Catalan Numbers approach.",
    "has_content": false
  },
  {
    "id": "problem_242",
    "number": 242,
    "title": "Valid Anagram",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 83: String - Anagram Check (Frequency Count/Sort)",
    "url": "https://leetcode.com/problems/valid-anagram/",
    "difficulty": "medium",
    "content": "# Valid Anagram\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Valid Anagram](https://leetcode.com/problems/valid-anagram/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 83: String - Anagram Check (Frequency Count/Sort)",
    "description": "Study Valid Anagram using the Pattern 83: String - Anagram Check (Frequency Count/Sort) approach.",
    "has_content": false
  },
  {
    "id": "problem_251",
    "number": 251,
    "title": "Flatten 2D Vector",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/flatten-2d-vector/",
    "difficulty": "medium",
    "content": "# Flatten 2D Vector\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Flatten 2D Vector](https://leetcode.com/problems/flatten-2d-vector/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Flatten 2D Vector using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_253",
    "number": 253,
    "title": "Meeting Rooms II",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "url": "https://leetcode.com/problems/meeting-rooms-ii/",
    "difficulty": "medium",
    "content": "# Meeting Rooms II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "description": "Study Meeting Rooms II using the Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue) approach.",
    "has_content": false
  },
  {
    "id": "problem_257",
    "number": 257,
    "title": "Binary Tree Paths",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "url": "https://leetcode.com/problems/binary-tree-paths/",
    "difficulty": "medium",
    "content": "# Binary Tree Paths\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Binary Tree Paths](https://leetcode.com/problems/binary-tree-paths/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "description": "Study Binary Tree Paths using the Pattern 13: Tree DFS - Recursive Preorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_259",
    "number": 259,
    "title": "3Sum Smaller",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)",
    "url": "https://leetcode.com/problems/3sum-smaller/",
    "difficulty": "medium",
    "content": "---\n### **259. 3Sum Smaller**\n**Link to Problem:** [https://leetcode.com/problems/3sum-smaller/](https://leetcode.com/problems/3sum-smaller/)\n\n#### **1. Problem Statement**\nGiven an array of integers `nums` and a `target` value, the task is to find the number of unique index triplets `(i, j, k)` where `0 <= i < j < k < n` such that the sum of the corresponding elements `nums[i] + nums[j] + nums[k]` is strictly less than the `target`.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to simply check every possible unique triplet in the array. We can achieve this by using three nested loops. The outer loop will pick the first element `nums[i]`, the second loop will pick `nums[j]` from the elements after `i`, and the innermost loop will pick `nums[k]` from the elements after `j`. For each triplet, we calculate the sum and, if it's less than the `target`, we increment a counter.\n\n**Python Code:**\n```python\ndef threeSumSmaller_brute_force(nums: list[int], target: int) -> int:\n    n = len(nums)\n    if n < 3:\n        return 0\n    \n    count = 0\n    \n    # First loop to fix the first element of the triplet\n    for i in range(n - 2):\n        # Second loop to fix the second element\n        for j in range(i + 1, n - 1):\n            # Third loop to find the third element\n            for k in range(j + 1, n):\n                # Check if the sum is smaller than the target\n                if nums[i] + nums[j] + nums[k] < target:\n                    count += 1\n                    \n    return count\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(n³)**\n    This is due to the three nested loops. In the worst case, each loop runs proportional to the size of the array `n`, leading to a cubic time complexity.\n\n*   **Space Complexity: O(1)**\n    We only use a few variables to store the count and loop indices, so the extra space required is constant.\n\n### **3. Optimized Approach: Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)**\n**Intuition:**\nThe `O(n³)` brute force solution is too slow for larger inputs. We can significantly improve performance by first sorting the array. Sorting allows us to use the **Two Pointers - Converging** pattern to efficiently find pairs that satisfy a condition.\n\nThe strategy is to iterate through the array with a single `for` loop, fixing one element `nums[i]` at a time. For each `nums[i]`, our goal is to find the number of pairs `(nums[j], nums[k])` in the rest of the array (where `j > i` and `k > j`) such that `nums[j] + nums[k] < target - nums[i]`. This transforms the problem into a \"2Sum Smaller\" subproblem.\n\nWe solve this subproblem using two pointers, `left` and `right`, initialized at the start (`i + 1`) and end of the remaining portion of the array.\n\nLet's walk through an example: `nums = [-2, 0, 1, 3]`, `target = 2`.\n1.  **Sort `nums`:** The array is already sorted.\n2.  **Outer loop `i = 0` (`nums[i] = -2`):**\n    *   We need to find pairs in `[0, 1, 3]` that sum to less than `target - nums[i] = 2 - (-2) = 4`.\n    *   Initialize `left = 1`, `right = 3`. The pointers are on `0` and `3`.\n    *   `sum = nums[left] + nums[right] = 0 + 3 = 3`.\n    *   Since `3 < 4`, we have found valid pairs. The key insight is that if `(nums[left], nums[right])` works, then because the array is sorted, any element between `left` and `right` used as the second element will also work with `nums[left]`.\n    *   The pairs are `(0, 3)` and `(0, 1)`. The number of such pairs is `right - left = 3 - 1 = 2`.\n    *   We add `2` to our total count and move `left` forward to find new pairs: `left++`.\n    *   `left` is now `2`, `right` is `3`. Pointers are on `1` and `3`.\n    *   `sum = nums[left] + nums[right] = 1 + 3 = 4`.\n    *   `4` is not less than `4`, so the sum is too large. To decrease the sum, we move `right` inward: `right--`.\n    *   Now `left = 2`, `right = 2`. The loop terminates as `left` is no longer less than `right`.\n3.  **Outer loop `i = 1` (`nums[i] = 0`):**\n    *   We need pairs in `[1, 3]` that sum to less than `target - nums[i] = 2 - 0 = 2`.\n    *   Initialize `left = 2`, `right = 3`. Pointers are on `1` and `3`.\n    *   `sum = 1 + 3 = 4`. `4` is not less than `2`. Sum is too large, so `right--`.\n    *   `left` and `right` pointers meet. The loop terminates.\n4.  The outer loop finishes. The final count is `2`.\n\n**Python Code:**\n```python\ndef threeSumSmaller(nums: list[int], target: int) -> int:\n    # Sorting is the essential first step for the two-pointer pattern.\n    nums.sort()\n    n = len(nums)\n    count = 0\n    \n    # Iterate through the array, fixing the first element `nums[i]`.\n    # We only need to go up to n-2 since we need at least two other elements.\n    for i in range(n - 2):\n        # Set up two pointers for the rest of the array.\n        left, right = i + 1, n - 1\n        \n        # Use the converging two-pointer technique on the sub-array.\n        while left < right:\n            current_sum = nums[i] + nums[left] + nums[right]\n            \n            if current_sum < target:\n                # If the sum with the 'right' element is smaller than the target,\n                # then any element between 'left' and 'right' will also work\n                # as the third element, because the array is sorted.\n                # The number of such valid triplets is (right - left).\n                count += (right - left)\n                \n                # To find more potential solutions, we need a larger sum.\n                # The only way to increase the sum is to move the 'left' pointer forward.\n                left += 1\n            else:\n                # The sum is too large or equal to the target.\n                # To make the sum smaller, we must move the 'right' pointer inward.\n                right -= 1\n                \n    return count\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(n²)**\n    The initial sort takes `O(n log n)`. The main logic consists of a `for` loop that runs `n` times, and inside it, a `while` loop with two pointers. For each `i`, the `left` and `right` pointers traverse the sub-array at most once, making the inner part `O(n)`. This results in a total time complexity of `O(n log n + n²)`, which simplifies to `O(n²)`.\n\n*   **Space Complexity: O(log n) to O(n)**\n    The space complexity is dominated by the sorting algorithm. In Python, Timsort uses space that can range from `O(log n)` to `O(n)` depending on the data. If we were to implement a sort like Heapsort, it could be `O(1)`.\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - Converging (Sorted Array Target Sum)** pattern, extended from a 2Sum to a 3Sum context. The signals that point directly to this pattern are:\n\n1.  **A Sorted Array is Key:** The problem doesn't require a sorted array, but sorting it is the crucial step that unlocks an efficient solution. The ability to logically move pointers inward or outward relies entirely on the sorted property.\n2.  **Finding Combinations (Triplets) with a Sum Condition:** The core task is to find triplets that satisfy a condition based on their sum (`< target`). This is a classic setup for target-sum problems.\n3.  **Reducing the Problem Space:** By fixing one element with an outer loop, we effectively reduce a `k`-sum problem to a `(k-1)`-sum problem on a subarray. Here, 3Sum Smaller becomes a series of 2Sum Smaller subproblems.\n4.  **Converging Pointers for Efficient Search:** For each subproblem, the two pointers starting at opposite ends (`left` and `right`) efficiently scan all possible pairs. If the sum is too small, we move `left` forward; if too large, we move `right` backward. This systematic, linear scan avoids the nested loop of the brute-force approach, dramatically improving performance.\n\nThe \"smaller than\" variation adds a unique twist: when `nums[i] + nums[left] + nums[right] < target`, we don't just count one triplet. We leverage the sorted order to instantly count `right - left` valid triplets, which is the core optimization for this specific problem type.",
    "description": "Study 3Sum Smaller using the Pattern 1: Two Pointers - Converging (Sorted Array Target Sum) approach.",
    "has_content": true
  },
  {
    "id": "problem_261",
    "number": 261,
    "title": "Graph Valid Tree",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/graph-valid-tree/",
    "difficulty": "medium",
    "content": "# Graph Valid Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Graph Valid Tree](https://leetcode.com/problems/graph-valid-tree/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study Graph Valid Tree using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_268",
    "number": 268,
    "title": "Missing Number",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 80: Array - Cyclic Sort",
    "url": "https://leetcode.com/problems/missing-number/",
    "difficulty": "medium",
    "content": "# Missing Number\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Missing Number](https://leetcode.com/problems/missing-number/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 80: Array - Cyclic Sort",
    "description": "Study Missing Number using the Pattern 80: Array - Cyclic Sort approach.",
    "has_content": false
  },
  {
    "id": "problem_269",
    "number": 269,
    "title": "Alien Dictionary",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "url": "https://leetcode.com/problems/alien-dictionary/",
    "difficulty": "medium",
    "content": "# Alien Dictionary\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Alien Dictionary](https://leetcode.com/problems/alien-dictionary/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "description": "Study Alien Dictionary using the Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_271",
    "number": 271,
    "title": "Encode and Decode Strings",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/encode-and-decode-strings/",
    "difficulty": "medium",
    "content": "# Encode and Decode Strings\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Encode and Decode Strings](https://leetcode.com/problems/encode-and-decode-strings/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Encode and Decode Strings using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_278",
    "number": 278,
    "title": "First Bad Version",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 53: Binary Search - On Sorted Array/List",
    "url": "https://leetcode.com/problems/first-bad-version/",
    "difficulty": "medium",
    "content": "# First Bad Version\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [First Bad Version](https://leetcode.com/problems/first-bad-version/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 53: Binary Search - On Sorted Array/List",
    "description": "Study First Bad Version using the Pattern 53: Binary Search - On Sorted Array/List approach.",
    "has_content": false
  },
  {
    "id": "problem_283",
    "number": 283,
    "title": "Move Zeroes",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 4: Two Pointers - In-place Array Modification",
    "url": "https://leetcode.com/problems/move-zeroes/",
    "difficulty": "medium",
    "content": "---\n### **283. Move Zeroes**\n**Link to Problem:** [https://leetcode.com/problems/move-zeroes/](https://leetcode.com/problems/move-zeroes/)\n\n#### **1. Problem Statement**\nGiven an integer array `nums`, the task is to move all the zeros to the end of it while maintaining the relative order of the non-zero elements. This operation must be performed **in-place**, meaning you cannot create a new copy of the array.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward idea that respects the in-place constraint is to iterate through the array. Whenever we encounter a zero, we can then start a second search from that point forward to find the next non-zero element. Once found, we swap the zero with that non-zero element. This process repeats until we've moved every zero past every non-zero number. This is conceptually similar to a bubble sort, where zeros are \"bubbled\" to the end.\n\n**Python Code:**\n```python\ndef moveZeroes_brute_force(nums: list[int]) -> None:\n    \"\"\"\n    Modifies nums in-place using a brute-force nested loop approach.\n    \"\"\"\n    n = len(nums)\n    # The outer loop iterates through each element of the array.\n    for i in range(n):\n        # If we find a zero, we need to find a non-zero element to swap it with.\n        if nums[i] == 0:\n            # The inner loop searches for the *next* non-zero element.\n            for j in range(i + 1, n):\n                if nums[j] != 0:\n                    # Perform the swap.\n                    nums[i], nums[j] = nums[j], nums[i]\n                    # Once a swap is made for the zero at index i, we can break\n                    # the inner loop and continue the search for the next zero.\n                    break\n\n# Example usage:\n# nums = [0, 1, 0, 3, 12]\n# moveZeroes_brute_force(nums)\n# print(nums) -> [1, 3, 12, 0, 0]\n```\n\n**Complexity Analysis:**\n\n*   **Time Complexity: O(n²)**\n    This is due to the nested loops. In the worst-case scenario (e.g., an array like `[0, 0, 0, 1]`), for each zero found by the outer loop, the inner loop may have to scan a significant portion of the remaining array.\n\n*   **Space Complexity: O(1)**\n    The solution is performed in-place. We only use a few variables for indices and swapping, which does not depend on the size of the input array.\n\n#### **3. Optimized Approach: Two Pointers - In-place Array Modification**\n**Intuition:**\nThe brute-force approach is slow because it repeatedly scans parts of the array. We can optimize this by realizing the problem can be rephrased: \"bring all non-zero elements to the front of the array.\" The zeros will naturally be left behind. This is a classic partitioning problem, perfect for the Two Pointers pattern.\n\nWe'll use two pointers, let's call them `write_ptr` and `read_ptr`, both starting at the beginning of the array.\n1.  `read_ptr`: Its job is to scan the array from left to right, one element at a time.\n2.  `write_ptr`: Its job is to keep track of the position where the *next non-zero element* should be placed.\n\nThe algorithm works as follows:\n*   The `read_ptr` moves forward unconditionally.\n*   If `read_ptr` encounters a non-zero element, it means we've found an element that belongs in the \"non-zero\" section of the array. We copy this element's value to the location of `write_ptr`.\n*   After copying, we advance `write_ptr` by one, effectively expanding the \"non-zero\" section.\n*   If `read_ptr` encounters a zero, we simply ignore it and move on. The `write_ptr` stays put, waiting for the next non-zero element to overwrite its position.\n\n**Example Walkthrough:** `nums = [0, 1, 0, 3, 12]`\n\n| `read_ptr` | `nums[read_ptr]` | Action | `write_ptr` | `nums` State |\n| :--- | :--- | :--- | :--- | :--- |\n| 0 | 0 | Zero found. Do nothing. | 0 | `[0, 1, 0, 3, 12]` |\n| 1 | 1 | Non-zero. `nums[write_ptr]` = `nums[read_ptr]`. Increment `write_ptr`. | 1 | `[1, 1, 0, 3, 12]` |\n| 2 | 0 | Zero found. Do nothing. | 1 | `[1, 1, 0, 3, 12]` |\n| 3 | 3 | Non-zero. `nums[write_ptr]` = `nums[read_ptr]`. Increment `write_ptr`. | 2 | `[1, 3, 0, 3, 12]` |\n| 4 | 12 | Non-zero. `nums[write_ptr]` = `nums[read_ptr]`. Increment `write_ptr`. | 3 | `[1, 3, 12, 3, 12]` |\n\nAfter the first pass, `nums` is `[1, 3, 12, 3, 12]` and `write_ptr` is at index 3. This means all non-zero elements are now correctly ordered in `nums[0...2]`. The final step is to fill the rest of the array (from `write_ptr` to the end) with zeros.\n\n**Python Code:**\n```python\ndef moveZeroes(nums: list[int]) -> None:\n    \"\"\"\n    Modifies nums in-place using the two-pointer pattern.\n    \"\"\"\n    # write_ptr keeps track of the position to place the next non-zero element.\n    write_ptr = 0\n    \n    # The read_ptr iterates through the entire array.\n    for read_ptr in range(len(nums)):\n        # If we find a non-zero element with the read_ptr...\n        if nums[read_ptr] != 0:\n            # ...we place it at the write_ptr's position.\n            # This operation is harmless if read_ptr and write_ptr are the same.\n            nums[write_ptr] = nums[read_ptr]\n            \n            # The \"non-zero\" section has grown, so we advance the write_ptr.\n            write_ptr += 1\n            \n    # After the first pass, all non-zero elements are at the front.\n    # The section from write_ptr to the end must be filled with zeros.\n    for i in range(write_ptr, len(nums)):\n        nums[i] = 0\n\n# Example usage:\n# nums = [0, 1, 0, 3, 12]\n# moveZeroes(nums)\n# print(nums) -> [1, 3, 12, 0, 0]\n```\n\n**Complexity Analysis:**\n\n*   **Time Complexity: O(n)**\n    This is a significant improvement. We iterate through the array with `read_ptr` once to move the non-zero elements, and then we iterate through the remaining portion with another loop to fill in the zeros. Each element is visited a constant number of times, resulting in a linear time complexity.\n\n*   **Space Complexity: O(1)**\n    The solution is performed in-place. We only use two integer pointers, so the space used is constant and does not scale with the input size.\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - In-place Array Modification** pattern. The key signals that point to this pattern are:\n\n1.  **In-Place Requirement:** The problem explicitly forbids creating a new array. This is the strongest hint to consider an in-place algorithm, and two pointers are a primary tool for such tasks.\n2.  **Array Partitioning:** The core task is to partition the array into two distinct, contiguous groups: non-zero elements at the beginning and zero elements at the end.\n3.  **Conditional Logic:** The decision to move an element is based on a simple condition (`is the element zero?`).\n\nThe pattern works by using one pointer (`write_ptr`) to maintain the boundary of the \"processed\" or \"correct\" section of the array (in this case, the non-zeros). The second pointer (`read_ptr`) ventures into the \"unprocessed\" section to find elements that satisfy the condition and should be moved into the correct section. This \"slow and fast pointer\" dynamic is a common and powerful technique for in-place array manipulation. Whenever you need to segregate elements of an array into two groups in-place, this pattern should be one of the first you consider.",
    "description": "Study Move Zeroes using the Pattern 4: Two Pointers - In-place Array Modification approach.",
    "has_content": true
  },
  {
    "id": "problem_287",
    "number": 287,
    "title": "Find the Duplicate Number",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 80: Array - Cyclic Sort",
    "url": "https://leetcode.com/problems/find-the-duplicate-number/",
    "difficulty": "medium",
    "content": "---\n### **287. Find the Duplicate Number**\n**Link to Problem:** [https://leetcode.com/problems/find-the-duplicate-number/](https://leetcode.com/problems/find-the-duplicate-number/)\n\n#### **1. Problem Statement**\nYou are given an array of `n + 1` integers, `nums`, where each integer is in the range `[1, n]` inclusive. Since there are `n+1` numbers but only `n` possible values, at least one number must be repeated. Your task is to find this single duplicate number, with the critical constraints that you **cannot modify the input array** and must use only **constant, O(1) extra space**.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to find a duplicate is to compare every number with every other number in the array. We can use a nested loop: the outer loop picks an element, and the inner loop iterates through the rest of the array to see if a matching element exists. If a match is found, we have found our duplicate.\n\n**Python Code:**\n```python\ndef findDuplicate_brute(nums: list[int]) -> int:\n    \"\"\"\n    Finds the duplicate number by comparing every element with every other element.\n    \"\"\"\n    n = len(nums)\n    # The outer loop picks an element one by one.\n    for i in range(n):\n        # The inner loop checks if this element appears again later in the array.\n        for j in range(i + 1, n):\n            # If we find two elements at different indices with the same value,\n            # we have found the duplicate.\n            if nums[i] == nums[j]:\n                return nums[i]\n    return -1 # Should not be reached given the problem constraints\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(n^2)`. For each element, we scan the remainder of the array. This results in a nested loop structure, leading to quadratic time complexity.\n*   **Space Complexity:** `O(1)`. We only use a few variables for loop indices, requiring no extra space that scales with the input size.\n\n#### **3. Optimized Approach: Two Pointers - Fast & Slow (Cycle Detection)**\nBefore diving into the optimal solution, it's worth noting that common `O(n)` solutions are invalid here. Using a hash set would take `O(n)` space, and sorting the array would take `O(n log n)` time and violate the \"no modification\" rule. This is why a more creative approach is needed.\n\n**Intuition:**\nThe key insight is to re-frame the problem from finding a duplicate in an array to detecting a cycle in a linked list. We can imagine the array `nums` as a special kind of linked list where the value at each index `i` is a pointer to the next index, `nums[i]`.\n\nFor example, if `nums = [1, 3, 4, 2, 2]`:\n*   A \"node\" at index `0` points to index `1` (since `nums[0] = 1`).\n*   A \"node\" at index `1` points to index `3` (since `nums[1] = 3`).\n*   A \"node\" at index `3` points to index `2` (since `nums[3] = 2`).\n*   Both index `3` and index `4` point to index `2` (since `nums[3] = 2` and `nums[4] = 2`).\n\nThis structure guarantees a cycle. Since all numbers are between `1` and `n`, and indices are from `0` to `n`, every \"pointer\" `nums[i]` leads to a valid subsequent index. Because there are `n+1` \"pointers\" (the numbers) but only `n` distinct indices to point to (indices `1` to `n`), at least two pointers must point to the same index. This convergence creates a path that inevitably leads into a cycle. The duplicate number is the entry point of this cycle.\n\nWe can find this entry point using **Floyd's Tortoise and Hare (Cycle Detection) algorithm**:\n\n1.  **Phase 1: Find the intersection point inside the cycle.**\n    *   Initialize two pointers, `slow` and `fast`, at the start of the sequence (`nums[0]`).\n    *   Move `slow` one step at a time (`slow = nums[slow]`).\n    *   Move `fast` two steps at a time (`fast = nums[nums[fast]]`).\n    *   Eventually, they will meet somewhere inside the cycle.\n\n2.  **Phase 2: Find the entrance of the cycle.**\n    *   Once they meet, reset one pointer (e.g., `slow`) back to the beginning (`nums[0]`).\n    *   Keep the other pointer (`fast`) at the intersection point.\n    *   Move both pointers one step at a time.\n    *   The point where they meet again is the entrance to the cycle, which is our duplicate number.\n\n**Python Code:**\n```python\ndef findDuplicate(nums: list[int]) -> int:\n    \"\"\"\n    Finds the duplicate number using Floyd's Tortoise and Hare algorithm.\n    This treats the array as a functional graph and finds the cycle entrance.\n    \"\"\"\n    # Phase 1: Find the intersection point of the two pointers.\n    # The 'slow' pointer moves one step at a time.\n    # The 'fast' pointer moves two steps at a time.\n    slow, fast = 0, 0\n    while True:\n        slow = nums[slow]\n        fast = nums[nums[fast]]\n        # The pointers will eventually meet inside the cycle.\n        if slow == fast:\n            break\n            \n    # Phase 2: Find the entrance to the cycle.\n    # Reset one pointer to the start of the array.\n    slow2 = 0\n    while True:\n        # Move both pointers one step at a time.\n        slow = nums[slow]\n        slow2 = nums[slow2]\n        # The point where they meet is the start of the cycle,\n        # which corresponds to the duplicate number.\n        if slow == slow2:\n            return slow\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(n)`. In the first phase, the slow pointer travels at most `n` steps before entering the cycle. The fast pointer catches up within the cycle in at most `n` more steps. The second phase also takes at most `n` steps. The total time is linear.\n*   **Space Complexity:** `O(1)`. We only use a few variables (`slow`, `fast`, `slow2`) to store pointers, fully satisfying the problem's constraints.\n\n#### **4. Pattern Connection**\nThis problem is a quintessential, albeit disguised, example of the **Fast & Slow Pointers (Cycle Detection)** pattern. While it's presented as an array problem, its constraints create an underlying structure that is equivalent to a linked list with a cycle.\n\nThe key characteristics that signal this pattern are:\n1.  **An Implicit Sequence:** The problem can be modeled as a sequence where each element points to another (`index -> value -> next_index`). This forms a functional graph.\n2.  **Guaranteed Cycle:** The problem's constraints (`n+1` numbers in the range `[1,n]`) ensure that this sequence isn't just a simple path; it must contain a cycle. The \"duplicate number\" is the cause and the entry point of this cycle.\n3.  **The Goal is the Cycle's Start:** The objective is not just to detect a cycle but to find its starting point, which is precisely what the second phase of Floyd's algorithm is designed to do.\n\nRecognizing that an array problem can be transformed into a graph/linked list traversal is a powerful problem-solving skill. Whenever you encounter problems involving sequences, permutations, or arrays where values can be interpreted as indices, and you need to find duplicates or loops under strict memory constraints, the Fast & Slow Pointer pattern should be one of the first things you consider.",
    "description": "Study Find the Duplicate Number using the Pattern 80: Array - Cyclic Sort approach.",
    "has_content": true
  },
  {
    "id": "problem_295",
    "number": 295,
    "title": "Find Median from Data Stream",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/find-median-from-data-stream/",
    "difficulty": "medium",
    "content": "# Find Median from Data Stream\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find Median from Data Stream](https://leetcode.com/problems/find-median-from-data-stream/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Find Median from Data Stream using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_297",
    "number": 297,
    "title": "Serialize and Deserialize Binary Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 17: Tree - Serialization and Deserialization",
    "url": "https://leetcode.com/problems/serialize-and-deserialize-binary-tree/",
    "difficulty": "medium",
    "content": "# Serialize and Deserialize Binary Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Serialize and Deserialize Binary Tree](https://leetcode.com/problems/serialize-and-deserialize-binary-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 17: Tree - Serialization and Deserialization",
    "description": "Study Serialize and Deserialize Binary Tree using the Pattern 17: Tree - Serialization and Deserialization approach.",
    "has_content": false
  },
  {
    "id": "problem_300",
    "number": 300,
    "title": "Longest Increasing Subsequence",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 36: DP - Longest Increasing Subsequence (LIS)",
    "url": "https://leetcode.com/problems/longest-increasing-subsequence/",
    "difficulty": "medium",
    "content": "# Longest Increasing Subsequence\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Longest Increasing Subsequence](https://leetcode.com/problems/longest-increasing-subsequence/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 36: DP - Longest Increasing Subsequence (LIS)",
    "description": "Study Longest Increasing Subsequence using the Pattern 36: DP - Longest Increasing Subsequence (LIS) approach.",
    "has_content": false
  },
  {
    "id": "problem_301",
    "number": 301,
    "title": "Remove Invalid Parentheses",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 44: Backtracking - Parentheses Generation",
    "url": "https://leetcode.com/problems/remove-invalid-parentheses/",
    "difficulty": "medium",
    "content": "# Remove Invalid Parentheses\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Remove Invalid Parentheses](https://leetcode.com/problems/remove-invalid-parentheses/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 44: Backtracking - Parentheses Generation",
    "description": "Study Remove Invalid Parentheses using the Pattern 44: Backtracking - Parentheses Generation approach.",
    "has_content": false
  },
  {
    "id": "problem_305",
    "number": 305,
    "title": "Number of Islands II",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/number-of-islands-ii/",
    "difficulty": "medium",
    "content": "# Number of Islands II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Number of Islands II](https://leetcode.com/problems/number-of-islands-ii/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study Number of Islands II using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_309",
    "number": 309,
    "title": "Best Time to Buy and Sell Stock with Cooldown",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 37: DP - Stock problems",
    "url": "https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/",
    "difficulty": "medium",
    "content": "# Best Time to Buy and Sell Stock with Cooldown\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Best Time to Buy and Sell Stock with Cooldown](https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 37: DP - Stock problems",
    "description": "Study Best Time to Buy and Sell Stock with Cooldown using the Pattern 37: DP - Stock problems approach.",
    "has_content": false
  },
  {
    "id": "problem_310",
    "number": 310,
    "title": "Minimum Height Trees",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "url": "https://leetcode.com/problems/minimum-height-trees/",
    "difficulty": "medium",
    "content": "# Minimum Height Trees\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Height Trees](https://leetcode.com/problems/minimum-height-trees/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "description": "Study Minimum Height Trees using the Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_312",
    "number": 312,
    "title": "Burst Balloons",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 34: DP - Interval DP",
    "url": "https://leetcode.com/problems/burst-balloons/",
    "difficulty": "medium",
    "content": "# Burst Balloons\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Burst Balloons](https://leetcode.com/problems/burst-balloons/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 34: DP - Interval DP",
    "description": "Study Burst Balloons using the Pattern 34: DP - Interval DP approach.",
    "has_content": false
  },
  {
    "id": "problem_322",
    "number": 322,
    "title": "Coin Change",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 28: DP - 1D Array (Coin Change / Unbounded Knapsack Style)",
    "url": "https://leetcode.com/problems/coin-change/",
    "difficulty": "medium",
    "content": "# Coin Change\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Coin Change](https://leetcode.com/problems/coin-change/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 28: DP - 1D Array (Coin Change / Unbounded Knapsack Style)",
    "description": "Study Coin Change using the Pattern 28: DP - 1D Array (Coin Change / Unbounded Knapsack Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_323",
    "number": 323,
    "title": "Number of Connected Components in an Undirected Graph",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/",
    "difficulty": "medium",
    "content": "# Number of Connected Components in an Undirected Graph\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Number of Connected Components in an Undirected Graph](https://leetcode.com/problems/number-of-connected-components-in-an-undirected-graph/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study Number of Connected Components in an Undirected Graph using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_328",
    "number": 328,
    "title": "Odd Even Linked List",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 73: Linked List - Reordering / Partitioning",
    "url": "https://leetcode.com/problems/odd-even-linked-list/",
    "difficulty": "medium",
    "content": "# Odd Even Linked List\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Odd Even Linked List](https://leetcode.com/problems/odd-even-linked-list/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 73: Linked List - Reordering / Partitioning",
    "description": "Study Odd Even Linked List using the Pattern 73: Linked List - Reordering / Partitioning approach.",
    "has_content": false
  },
  {
    "id": "problem_337",
    "number": 337,
    "title": "House Robber III",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 26: DP - 1D Array (Fibonacci Style)",
    "url": "https://leetcode.com/problems/house-robber-iii/",
    "difficulty": "medium",
    "content": "# House Robber III\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [House Robber III](https://leetcode.com/problems/house-robber-iii/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 26: DP - 1D Array (Fibonacci Style)",
    "description": "Study House Robber III using the Pattern 26: DP - 1D Array (Fibonacci Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_338",
    "number": 338,
    "title": "Counting Bits",
    "category": "XI. Bit Manipulation Patterns",
    "pattern": "Pattern 67: Bitwise DP - Counting Bits Optimization",
    "url": "https://leetcode.com/problems/counting-bits/",
    "difficulty": "medium",
    "content": "# Counting Bits\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Counting Bits](https://leetcode.com/problems/counting-bits/)\n\n**Category:** XI. Bit Manipulation Patterns\n**Pattern:** Pattern 67: Bitwise DP - Counting Bits Optimization",
    "description": "Study Counting Bits using the Pattern 67: Bitwise DP - Counting Bits Optimization approach.",
    "has_content": false
  },
  {
    "id": "problem_341",
    "number": 341,
    "title": "Flatten Nested List Iterator",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/flatten-nested-list-iterator/",
    "difficulty": "medium",
    "content": "# Flatten Nested List Iterator\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Flatten Nested List Iterator](https://leetcode.com/problems/flatten-nested-list-iterator/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Flatten Nested List Iterator using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_342",
    "number": 342,
    "title": "Power of Four",
    "category": "XI. Bit Manipulation Patterns",
    "pattern": "Pattern 68: Bitwise Operations - Power of Two/Four Check",
    "url": "https://leetcode.com/problems/power-of-four/",
    "difficulty": "medium",
    "content": "# Power of Four\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Power of Four](https://leetcode.com/problems/power-of-four/)\n\n**Category:** XI. Bit Manipulation Patterns\n**Pattern:** Pattern 68: Bitwise Operations - Power of Two/Four Check",
    "description": "Study Power of Four using the Pattern 68: Bitwise Operations - Power of Two/Four Check approach.",
    "has_content": false
  },
  {
    "id": "problem_344",
    "number": 344,
    "title": "Reverse String",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 7: Two Pointers - String Reversal",
    "url": "https://leetcode.com/problems/reverse-string/",
    "difficulty": "medium",
    "content": "---\n### **344. Reverse String**\n**Link to Problem:** [https://leetcode.com/problems/reverse-string/](https://leetcode.com/problems/reverse-string/)\n\n#### **1. Problem Statement**\nThe core task is to reverse a string, which is given as an array of characters `s`. The key constraint is that you must modify the input array **in-place** using constant, O(1), extra memory. The function should not return anything; it should directly alter the list it receives.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward idea is to create a new, empty array. We can iterate through the original array from the last element to the first, appending each character to our new array. At this point, the new array contains the reversed sequence of characters. However, the problem requires an *in-place* modification. To satisfy this, we can then iterate through the original array again, replacing each of its elements with the corresponding element from our newly created reversed array.\n\nThis approach works, but it temporarily uses extra memory proportional to the size of the input string, which violates the O(1) space constraint.\n\n**Python Code:**\n```python\nfrom typing import List\n\ndef reverseString_bruteforce(s: List[str]) -> None:\n    \"\"\"\n    Reverses a string by creating a copy and then overwriting the original.\n    This is NOT an in-place solution with O(1) space.\n    \"\"\"\n    # Create a new list containing the reversed characters.\n    # We can use Python's slicing feature for a concise way to do this.\n    reversed_s = s[::-1]\n\n    # Copy the elements from the new reversed list back into the original list.\n    # This loop is necessary to meet the \"in-place\" modification requirement,\n    # even though the overall logic uses O(N) space.\n    for i in range(len(s)):\n        s[i] = reversed_s[i]\n\n# Example usage:\n# my_string = [\"h\", \"e\", \"l\", \"l\", \"o\"]\n# reverseString_bruteforce(my_string)\n# print(my_string) # Output: ['o', 'l', 'l', 'e', 'h']\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    Creating the reversed slice `s[::-1]` takes O(N) time. The subsequent loop to copy elements back into `s` also takes O(N) time. This results in a total time complexity of O(N).\n\n*   **Space Complexity: O(N)**\n    The primary drawback of this method is its space usage. The slice `s[::-1]` creates a new list that is a full copy of the original string, thus requiring O(N) extra space.\n\n### **3. Optimized Approach: Two Pointers - String Reversal**\n**Intuition:**\nTo solve this problem efficiently and meet the O(1) space constraint, we can use the **Two Pointers** pattern. The idea is to process the string from both ends simultaneously. We'll set up two pointers: a `left` pointer starting at the beginning of the array (index 0) and a `right` pointer starting at the very end (index `len(s) - 1`).\n\nThe algorithm proceeds as follows:\n1.  While the `left` pointer is to the left of the `right` pointer (`left < right`):\n2.  Swap the characters at the `left` and `right` positions.\n3.  Move the `left` pointer one step to the right (`left += 1`).\n4.  Move the `right` pointer one step to the left (`right -= 1`).\n\nThis process continues until the pointers meet or cross each other, at which point the entire array will have been reversed in-place.\n\nLet's walk through an example with `s = [\"h\", \"e\", \"l\", \"l\", \"o\"]`:\n*   **Initial:** `left = 0` ('h'), `right = 4` ('o').\n*   **Swap 1:** Swap `s[0]` and `s[4]`. Array becomes `[\"o\", \"e\", \"l\", \"l\", \"h\"]`.\n    *   Increment `left` to 1, decrement `right` to 3.\n*   **Swap 2:** `left = 1` ('e'), `right = 3` ('l'). Swap `s[1]` and `s[3]`. Array becomes `[\"o\", \"l\", \"l\", \"e\", \"h\"]`.\n    *   Increment `left` to 2, decrement `right` to 2.\n*   **Stop:** Now `left` is 2 and `right` is 2. The condition `left < right` is false, so the loop terminates. The array is fully reversed.\n\n**Python Code:**\n```python\nfrom typing import List\n\ndef reverseString(s: List[str]) -> None:\n    \"\"\"\n    Reverses a string in-place using the two-pointer technique.\n    \"\"\"\n    # Initialize a pointer at the start of the list.\n    left = 0\n    # Initialize another pointer at the end of the list.\n    right = len(s) - 1\n\n    # Loop until the two pointers meet or cross each other.\n    while left < right:\n        # The core of the pattern: swap the elements at the pointers' positions.\n        # Python's tuple assignment makes this a clean, one-line swap.\n        s[left], s[right] = s[right], s[left]\n\n        # Move the left pointer forward.\n        left += 1\n        # Move the right pointer backward.\n        right -= 1\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    Although we have two pointers, they only make a single pass through the array combined. We perform approximately N/2 swaps. Therefore, the time complexity is linear with respect to the number of elements in the string.\n\n*   **Space Complexity: O(1)**\n    This is the key advantage. We are not creating any new data structures. We only use a few variables (`left`, `right`) to store indices, regardless of the input size. This satisfies the problem's requirement for constant extra memory.\n\n### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - String Reversal** pattern. The pattern is immediately signaled by a few key characteristics of the problem:\n\n1.  **Symmetric Operation:** The task requires a symmetric transformation where the first element interacts with the last, the second with the second-to-last, and so on.\n2.  **In-Place Requirement:** The constraint to modify the data structure in-place with O(1) extra space strongly suggests an approach that avoids creating copies. Two pointers allow you to rearrange elements within the existing array.\n3.  **Sequential Data:** The input is a linear, indexable data structure (an array/list).\n\nWhenever you encounter a problem that involves reversing a sequence or performing symmetric operations from the ends toward the center, the Two Pointers pattern should be your first thought. By placing one pointer at the beginning and one at the end and moving them toward each other, you create a powerful and efficient mechanism for in-place manipulation.",
    "description": "Study Reverse String using the Pattern 7: Two Pointers - String Reversal approach.",
    "has_content": true
  },
  {
    "id": "problem_345",
    "number": 345,
    "title": "Reverse Vowels of a String",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 7: Two Pointers - String Reversal",
    "url": "https://leetcode.com/problems/reverse-vowels-of-a-string/",
    "difficulty": "medium",
    "content": "---\n### **345. Reverse Vowels of a String**\n**Link to Problem:** [https://leetcode.com/problems/reverse-vowels-of-a-string/](https://leetcode.com/problems/reverse-vowels-of-a-string/)\n\n#### **1. Problem Statement**\nGiven a string `s`, the task is to reverse the positions of only the vowels within the string. All consonants must remain in their original positions. The vowels are 'a', 'e', 'i', 'o', 'u', and their uppercase counterparts.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most direct way to solve this is to treat it as two separate problems: first, find all the vowels, and second, place them back into the string in reversed order.\n\n1.  **Extract:** Iterate through the input string and store all the vowels in a separate list.\n2.  **Reverse:** Reverse this new list of vowels.\n3.  **Replace:** Iterate through the original string again. When we encounter a position that originally held a vowel, we replace it with the next vowel from our reversed list.\n\nThis approach correctly solves the problem but requires multiple passes over the string and extra storage for the vowels.\n\n**Python Code:**\n```python\ndef reverseVowels_brute_force(s: str) -> str:\n    # A set for O(1) vowel checking.\n    vowels_set = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    \n    # 1. Extract all vowels from the string in the order they appear.\n    extracted_vowels = []\n    for char in s:\n        if char in vowels_set:\n            extracted_vowels.append(char)\n            \n    # 2. Reverse the list of extracted vowels.\n    # This prepares them to be placed back in reverse order.\n    extracted_vowels.reverse()\n    \n    # Convert the immutable string to a list of characters for modification.\n    s_list = list(s)\n    \n    # 3. Replace the original vowel positions with the reversed vowels.\n    vowel_idx = 0\n    for i in range(len(s_list)):\n        if s_list[i] in vowels_set:\n            s_list[i] = extracted_vowels[vowel_idx]\n            vowel_idx += 1\n            \n    # Join the list back into a string.\n    return \"\".join(s_list)\n\n# Example:\n# s = \"hello\"\n# extracted_vowels = ['e', 'o']\n# reversed vowels = ['o', 'e']\n# s_list = ['h', 'e', 'l', 'l', 'o']\n# First vowel at index 1 is replaced with 'o'.\n# Second vowel at index 4 is replaced with 'e'.\n# Result: ['h', 'o', 'l', 'l', 'e'] -> \"holle\"\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**, where N is the length of the string. We perform two separate full iterations over the string: one to extract vowels and one to replace them.\n*   **Space Complexity: O(V)**, where V is the number of vowels in the string. In the worst-case scenario (a string of all vowels), this becomes **O(N)**, as we need to store all the vowels in the `extracted_vowels` list.\n\n---\n### **3. Optimized Approach: [Pattern 7: Two Pointers - String Reversal]**\n**Intuition:**\nThe brute-force method is inefficient because it uses extra space to store the vowels and requires multiple passes. We can optimize this by performing the swaps in-place using two pointers that converge toward the center of the string. This is the classic \"Two Pointers - String Reversal\" pattern.\n\n1.  Initialize a `left` pointer at the beginning of the string (`0`) and a `right` pointer at the end (`len(s) - 1`).\n2.  The pointers will move towards each other, looking for vowels.\n3.  If the character at `left` is not a vowel, we leave it alone and move the pointer forward (`left += 1`).\n4.  Similarly, if the character at `right` is not a vowel, we leave it and move the pointer backward (`right -= 1`).\n5.  When both `left` and `right` point to vowels, we have found a pair to swap. We swap the characters at these two positions. After swapping, we move both pointers inward (`left += 1`, `right -= 1`) to continue searching for the next pair.\n6.  This process continues until the `left` pointer crosses the `right` pointer, ensuring all vowel pairs have been reversed.\n\nLet's walk through an example: `s = \"leetcode\"`\n\n*   `s_list = ['l', 'e', 'e', 't', 'c', 'o', 'd', 'e']`\n*   `left = 0`, `right = 7`\n*   `s_list[left]` ('l') is a consonant. Move `left` to 1.\n*   `s_list[left]` ('e') is a vowel. `s_list[right]` ('e') is a vowel. They are a pair!\n*   Swap `s_list[1]` and `s_list[7]`. String remains `['l', 'e', 'e', 't', 'c', 'o', 'd', 'e']`.\n*   Move pointers: `left` becomes 2, `right` becomes 6.\n*   `s_list[left]` ('e') is a vowel.\n*   `s_list[right]` ('d') is a consonant. Move `right` to 5.\n*   `s_list[left]` ('e') is a vowel. `s_list[right]` ('o') is a vowel. They are a pair!\n*   Swap `s_list[2]` and `s_list[5]`. String becomes `['l', 'e', 'o', 't', 'c', 'e', 'd', 'e']`.\n*   Move pointers: `left` becomes 3, `right` becomes 4.\n*   `s_list[left]` ('t') is a consonant. Move `left` to 4.\n*   Now `left` (4) is not less than `right` (4). The loop terminates.\n*   Join the list to get the final result: `\"leotcede\"`.\n\n**Python Code:**\n```python\ndef reverseVowels(s: str) -> str:\n    # A set for O(1) vowel checking is highly efficient.\n    vowels_set = {'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'}\n    \n    # Python strings are immutable, so we work with a list of characters.\n    s_list = list(s)\n    \n    # Initialize two pointers at the start and end of the list.\n    left, right = 0, len(s_list) - 1\n    \n    # The loop continues as long as the pointers haven't crossed.\n    while left < right:\n        # Move the left pointer inward until it lands on a vowel.\n        while left < right and s_list[left] not in vowels_set:\n            left += 1\n        \n        # Move the right pointer inward until it lands on a vowel.\n        while left < right and s_list[right] not in vowels_set:\n            right -= 1\n            \n        # If the pointers haven't crossed, we've found two vowels to swap.\n        if left < right:\n            # Perform the swap.\n            s_list[left], s_list[right] = s_list[right], s_list[left]\n            \n            # Move both pointers inward to continue the search.\n            left += 1\n            right -= 1\n            \n    # Join the list of characters back into a final string.\n    return \"\".join(s_list)\n```\n\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**. Although we have nested `while` loops, each pointer (`left` and `right`) traverses the list at most once. The total number of operations is proportional to the length of the string, N.\n*   **Space Complexity: O(N)**. This is specific to Python because strings are immutable and we must convert the string to a list of characters to perform the in-place swaps. In languages with mutable strings (like C++ or Java using a `char` array), the space complexity would be **O(1)**.\n\n---\n### **4. Pattern Connection**\nThis problem is a canonical example of the **Two Pointers - String Reversal** pattern (also known as converging or opposing pointers). The key signals for using this pattern are:\n\n1.  **In-place Modification:** The problem asks to modify a sequence (like an array or string) without using significant extra storage.\n2.  **Symmetrical Processing:** The operation involves pairing elements from the opposite ends of the sequence. Here, we need to swap the first vowel with the last, the second vowel with the second-to-last, and so on.\n3.  **Conditional Logic:** The pointers don't just move one step at a time; they \"seek\" the next element that meets a specific condition (being a vowel) before performing an action (the swap).\n\nThe two-pointer technique elegantly handles the requirement of leaving consonants untouched by simply skipping over them. It transforms a multi-pass, high-storage problem into a single-pass, in-place solution, which is the hallmark of an efficient pointer-based algorithm.",
    "description": "Study Reverse Vowels of a String using the Pattern 7: Two Pointers - String Reversal approach.",
    "has_content": true
  },
  {
    "id": "problem_346",
    "number": 346,
    "title": "Moving Average from Data Stream",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/moving-average-from-data-stream/",
    "difficulty": "medium",
    "content": "---\n### **346. Moving Average from Data Stream**\n**Link to Problem:** [https://leetcode.com/problems/moving-average-from-data-stream/](https://leetcode.com/problems/moving-average-from-data-stream/)\n\n#### **1. Problem Statement**\nThe task is to implement a `MovingAverage` class that calculates the moving average of the last `k` numbers in a data stream. The class will be initialized with a window size `k`. Its single method, `next(val)`, adds a new integer `val` to the stream and returns the average of the last `k` elements.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to store every number we've seen. Each time `next()` is called, we add the new number to our list. Then, to calculate the moving average, we identify the last `k` elements in our list, sum them up, and divide by the number of elements in that window (which could be less than `k` initially).\n\n**Python Code:**\n```python\nclass MovingAverage:\n    def __init__(self, size: int):\n        \"\"\"\n        Initializes the MovingAverage object.\n        - self.size: The fixed size of the window.\n        - self.stream: A list to store all numbers encountered so far.\n        \"\"\"\n        self.size = size\n        self.stream = []\n\n    def next(self, val: int) -> float:\n        \"\"\"\n        Adds a new value and calculates the moving average.\n        \"\"\"\n        # Add the new value to our record of all numbers.\n        self.stream.append(val)\n        \n        # Determine the slice of the stream that represents our window.\n        # We use max(0, ...) to handle the case where the stream is shorter than the window size.\n        window = self.stream[max(0, len(self.stream) - self.size):]\n        \n        # Calculate the sum of elements in the current window and divide by its size.\n        return sum(window) / len(window)\n\n# Complexity Analysis:\n\n# Time Complexity: O(k) for each call to next().\n# The dominant operation is `sum(window)`. In the worst case, the window has `k` elements,\n# so calculating the sum requires iterating over all `k` of them.\n\n# Space Complexity: O(N), where N is the total number of calls to `next()`.\n# The `self.stream` list grows indefinitely, storing every single element ever passed to the method.\n# This can become very memory-intensive for a long data stream.\n```\n\n### **3. Optimized Approach: [Pattern 8: Sliding Window - Fixed Size (Subarray Calculation)]**\n**Intuition:**\nThe brute-force approach is inefficient because it recalculates the sum of the window from scratch every single time. We can do better. The key insight of the sliding window pattern is to recognize that as the window \"slides\" forward, we only need to account for two changes: the new element entering the window and the oldest element leaving it.\n\nInstead of storing all `N` elements, we only need to keep track of the `k` elements currently inside the window. A `deque` (double-ended queue) is the perfect data structure for this. We can also maintain a running `window_sum`.\n\nLet's walk through an example: `size = 3`.\n1.  `next(1)`: Window `[1]`. Sum is 1. Avg = 1/1 = 1.0.\n2.  `next(10)`: Window `[1, 10]`. Sum is 1+10=11. Avg = 11/2 = 5.5.\n3.  `next(3)`: Window `[1, 10, 3]`. Sum is 11+3=14. Avg = 14/3 ≈ 4.67. The window is now full.\n4.  `next(5)`: The window needs to slide.\n    *   The new element `5` enters. We add it to our sum: `14 + 5 = 19`.\n    *   The oldest element `1` must leave. We subtract it from our sum: `19 - 1 = 18`.\n    *   The new window is `[10, 3, 5]`. The new average is `18 / 3 = 6.0`.\n\nBy updating the sum in O(1) time, we avoid the expensive O(k) re-summation.\n\n**Python Code:**\n```python\nfrom collections import deque\n\nclass MovingAverage:\n    def __init__(self, size: int):\n        \"\"\"\n        Initializes the MovingAverage object.\n        - self.size: The fixed size of the window.\n        - self.window: A deque to efficiently store only the elements in the window.\n        - self.window_sum: The running sum of elements currently in the window.\n        \"\"\"\n        self.size = size\n        self.window = deque()\n        self.window_sum = 0.0\n\n    def next(self, val: int) -> float:\n        \"\"\"\n        Adds a new value and calculates the moving average in O(1) time.\n        \"\"\"\n        # --- Window Expansion ---\n        # A new element enters the window from the right.\n        self.window.append(val)\n        # Add its value to our running sum.\n        self.window_sum += val\n        \n        # --- Window Contraction ---\n        # If the window is now too large, the oldest element must be removed.\n        if len(self.window) > self.size:\n            # Remove the leftmost element from the window and subtract its value from the sum.\n            # This is the core of the sliding window optimization.\n            removed_val = self.window.popleft()\n            self.window_sum -= removed_val\n            \n        # The average is the current sum divided by the number of elements in the window.\n        return self.window_sum / len(self.window)\n\n# Complexity Analysis:\n\n# Time Complexity: O(1) for each call to next().\n# All operations within the `next` method (`append`, `popleft`, addition, subtraction, division)\n# take constant time, regardless of the window size. This is a significant improvement.\n\n# Space Complexity: O(k), where `k` is the window size.\n# The `deque` stores at most `k` elements, providing a fixed memory footprint that doesn't\n# grow with the length of the data stream.\n```\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Fixed-Size Sliding Window** pattern. The pattern is immediately identifiable by these key characteristics:\n\n*   **Input as a Sequence:** We are processing a `data stream`, which is conceptually the same as iterating over a long array.\n*   **Contiguous Subarray/Window:** The problem asks for a calculation (the average) over a contiguous block of the most recent elements.\n*   **Fixed Size:** The size of this block, `k`, is defined at the start and does not change.\n*   **Calculation can be Updated Efficiently:** The core of the problem is a calculation (a sum) that can be updated in O(1) time as the window slides. Instead of re-computing the sum for the entire new window, we simply add the new element and subtract the one that falls off.\n\nWhenever you encounter a problem that requires performing a calculation on a fixed-size, contiguous segment of an array or stream, your first thought should be the fixed-size sliding window pattern. The key is to avoid redundant work by maintaining a running state (like a sum, count, or character map) and only updating it with the elements that enter and exit the window on each step.",
    "description": "Study Moving Average from Data Stream using the Pattern 89: Design (General/Specific) approach.",
    "has_content": true
  },
  {
    "id": "problem_347",
    "number": 347,
    "title": "Top K Frequent Elements",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "url": "https://leetcode.com/problems/top-k-frequent-elements/",
    "difficulty": "medium",
    "content": "# Top K Frequent Elements\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Top K Frequent Elements](https://leetcode.com/problems/top-k-frequent-elements/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "description": "Study Top K Frequent Elements using the Pattern 37: Heap - Top K Elements (Selection/Frequency) approach.",
    "has_content": false
  },
  {
    "id": "problem_349",
    "number": 349,
    "title": "Intersection of Two Arrays",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)",
    "url": "https://leetcode.com/problems/intersection-of-two-arrays/",
    "difficulty": "medium",
    "content": "---\n### **349. Intersection of Two Arrays**\n**Link to Problem:** [https://leetcode.com/problems/intersection-of-two-arrays/](https://leetcode.com/problems/intersection-of-two-arrays/)\n\n#### **1. Problem Statement**\nGiven two integer arrays, `nums1` and `nums2`, the task is to return an array containing their intersection. The key constraints are that each element in the result must be **unique**, and the order of the elements in the output does not matter.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to check every element of the first array against every element of the second array. We can iterate through `nums1`, and for each element, we scan the entirety of `nums2` to see if a match exists. To handle the \"unique\" requirement, we can use a hash set to store the common elements we find, which automatically prevents duplicates.\n\n**Python Code:**\n```python\ndef intersection_brute_force(nums1, nums2):\n    # Use a set to store the intersection to automatically handle uniqueness.\n    intersection_set = set()\n    \n    # Iterate through each number in the first array.\n    for n1 in nums1:\n        # For each number, iterate through the entire second array to look for a match.\n        for n2 in nums2:\n            if n1 == n2:\n                # If a match is found, add it to our set.\n                # If the element is already in the set, this operation does nothing.\n                intersection_set.add(n1)\n                # We can break here since we only care if it exists, not how many times.\n                break\n                \n    # The problem asks for an array (list in Python) as output.\n    return list(intersection_set)\n\n# Complexity Analysis:\n#\n# Time Complexity: O(n * m)\n# Where 'n' is the length of nums1 and 'm' is the length of nums2. This is because\n# for every element in nums1, we potentially iterate through all elements of nums2,\n# leading to a nested loop structure.\n#\n# Space Complexity: O(k)\n# Where 'k' is the number of unique elements in the intersection. In the worst case,\n# if the smaller array is a subset of the larger one, the space complexity would be\n# O(min(n, m)) to store the result set.\n```\n\n#### **3. Optimized Approach: Two Pointers on Sorted Arrays**\n*(Note: While categorized under \"Converging Pointers\", this problem uses a variation where two pointers traverse two separate arrays in the same direction, rather than converging from opposite ends of a single array. The core principle of using pointers to avoid redundant checks remains the same.)*\n\n**Intuition:**\nThe brute-force approach is slow because for each element in `nums1`, we repeatedly search `nums2` from the beginning. We can do much better if the arrays are ordered.\n\nThe key insight is to **sort both arrays first**. Once sorted, we can use two pointers, one for each array, and traverse them in a single, linear pass. This is the essence of the Two Pointers pattern for this problem.\n\nLet's walk through an example:\n`nums1 = [4, 9, 5]`, `nums2 = [9, 4, 9, 8, 4]`\n\n1.  **Sort:**\n    *   `nums1` becomes `[4, 5, 9]`\n    *   `nums2` becomes `[4, 4, 8, 9, 9]`\n\n2.  **Initialize Pointers:**\n    *   `p1` points to `nums1[0]` (value 4).\n    *   `p2` points to `nums2[0]` (value 4).\n\n3.  **Compare and Move:**\n    *   **Iteration 1:** `nums1[p1]` (4) == `nums2[p2]` (4). We found an intersection! Add 4 to our result set. Advance **both** pointers.\n        *   `p1` is now at index 1 (value 5). `p2` is at index 1 (value 4).\n    *   **Iteration 2:** `nums1[p1]` (5) > `nums2[p2]` (4). The value in `nums2` is too small. To find a potential match for 5, we must look at a larger number in `nums2`. Advance `p2`.\n        *   `p1` is at index 1 (value 5). `p2` is at index 2 (value 8).\n    *   **Iteration 3:** `nums1[p1]` (5) < `nums2[p2]` (8). Now the value in `nums1` is too small. To find a potential match for 8, we must look at a larger number in `nums1`. Advance `p1`.\n        *   `p1` is at index 2 (value 9). `p2` is at index 2 (value 8).\n    *   **Iteration 4:** `nums1[p1]` (9) > `nums2[p2]` (8). The value in `nums2` is too small. Advance `p2`.\n        *   `p1` is at index 2 (value 9). `p2` is at index 3 (value 9).\n    *   **Iteration 5:** `nums1[p1]` (9) == `nums2[p2]` (9). Another intersection! Add 9 to the result set. Advance **both** pointers.\n        *   `p1` is at index 3 (out of bounds).\n    *   The `while` loop terminates because `p1` is out of bounds. The final result is `{4, 9}`.\n\n**Python Code:**\n```python\ndef intersection_two_pointers(nums1, nums2):\n    # The two-pointer approach requires sorted arrays to work correctly.\n    # This is the crucial pre-processing step.\n    nums1.sort()\n    nums2.sort()\n    \n    # Initialize pointers at the beginning of each array.\n    p1, p2 = 0, 0\n    result_set = set()\n    \n    # The main loop continues as long as both pointers are within their array's bounds.\n    while p1 < len(nums1) and p2 < len(nums2):\n        # Case 1: The elements are equal, we found an intersection.\n        if nums1[p1] == nums2[p2]:\n            result_set.add(nums1[p1])\n            # Advance both pointers to look for the next potential intersection.\n            p1 += 1\n            p2 += 1\n        # Case 2: The element in nums1 is smaller.\n        # We need to advance p1 to find a potentially larger value to match nums2[p2].\n        elif nums1[p1] < nums2[p2]:\n            p1 += 1\n        # Case 3: The element in nums2 is smaller.\n        # We need to advance p2 to find a potentially larger value to match nums1[p1].\n        else: # nums1[p1] > nums2[p2]\n            p2 += 1\n            \n    return list(result_set)\n\n# Complexity Analysis:\n#\n# Time Complexity: O(n log n + m log m)\n# The dominant operation is sorting. Sorting nums1 takes O(n log n) and nums2 takes\n# O(m log m). The subsequent two-pointer scan takes only O(n + m) because each\n# pointer moves forward and traverses its array just once. The overall complexity\n# is therefore determined by the sorting step.\n#\n# Space Complexity: O(k) or O(n + m)\n# The space for the output set is O(k), where 'k' is the number of intersection elements.\n# However, it's important to note that the sorting algorithm itself might require auxiliary space.\n# Python's Timsort can use up to O(n) space in the worst case. If we are not allowed to\n# modify the input arrays, we would need O(n + m) space to store the sorted copies.\n```\n\n#### **4. Pattern Connection**\nThis problem is a classic example of the **Two Pointers** pattern, specifically the variant applied to two separate arrays. The key signal for this pattern is when you need to find pairs of elements or commonalities between **two sorted sequences**.\n\nThe brute-force solution's inefficiency stems from its O(n*m) comparisons. Sorting the arrays is the critical enabler. It imposes an order that allows us to discard parts of the search space intelligently. If `nums1[p1]` is smaller than `nums2[p2]`, we know for a fact that `nums1[p1]` cannot match `nums2[p2]` or any subsequent elements in `nums2` (since `nums2` is sorted). Therefore, we can safely advance `p1` without ever looking back. This single-pass, coordinated movement of two pointers after a sorting pre-step is the hallmark of this pattern, effectively reducing the comparison time complexity from quadratic to linear.",
    "description": "Study Intersection of Two Arrays using the Pattern 1: Two Pointers - Converging (Sorted Array Target Sum) approach.",
    "has_content": true
  },
  {
    "id": "problem_353",
    "number": 353,
    "title": "Design Snake Game",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-snake-game/",
    "difficulty": "medium",
    "content": "# Design Snake Game\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design Snake Game](https://leetcode.com/problems/design-snake-game/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design Snake Game using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_354",
    "number": 354,
    "title": "Russian Doll Envelopes",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 36: DP - Longest Increasing Subsequence (LIS)",
    "url": "https://leetcode.com/problems/russian-doll-envelopes/",
    "difficulty": "medium",
    "content": "# Russian Doll Envelopes\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Russian Doll Envelopes](https://leetcode.com/problems/russian-doll-envelopes/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 36: DP - Longest Increasing Subsequence (LIS)",
    "description": "Study Russian Doll Envelopes using the Pattern 36: DP - Longest Increasing Subsequence (LIS) approach.",
    "has_content": false
  },
  {
    "id": "problem_359",
    "number": 359,
    "title": "Logger Rate Limiter",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/logger-rate-limiter/",
    "difficulty": "medium",
    "content": "# Logger Rate Limiter\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Logger Rate Limiter](https://leetcode.com/problems/logger-rate-limiter/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Logger Rate Limiter using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_362",
    "number": 362,
    "title": "Design Hit Counter",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-hit-counter/",
    "difficulty": "medium",
    "content": "# Design Hit Counter\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design Hit Counter](https://leetcode.com/problems/design-hit-counter/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design Hit Counter using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_366",
    "number": 366,
    "title": "Find Leaves of Binary Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "url": "https://leetcode.com/problems/find-leaves-of-binary-tree/",
    "difficulty": "medium",
    "content": "# Find Leaves of Binary Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find Leaves of Binary Tree](https://leetcode.com/problems/find-leaves-of-binary-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "description": "Study Find Leaves of Binary Tree using the Pattern 15: Tree DFS - Recursive Postorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_369",
    "number": 369,
    "title": "Plus One Linked List",
    "category": "XII. Linked List Manipulation Patterns",
    "pattern": "Pattern 71: Linked List - Addition of Numbers",
    "url": "https://leetcode.com/problems/plus-one-linked-list/",
    "difficulty": "medium",
    "content": "# Plus One Linked List\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Plus One Linked List](https://leetcode.com/problems/plus-one-linked-list/)\n\n**Category:** XII. Linked List Manipulation Patterns\n**Pattern:** Pattern 71: Linked List - Addition of Numbers",
    "description": "Study Plus One Linked List using the Pattern 71: Linked List - Addition of Numbers approach.",
    "has_content": false
  },
  {
    "id": "problem_373",
    "number": 373,
    "title": "Find K Pairs with Smallest Sums",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 39: Heap - K-way Merge",
    "url": "https://leetcode.com/problems/find-k-pairs-with-smallest-sums/",
    "difficulty": "medium",
    "content": "# Find K Pairs with Smallest Sums\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find K Pairs with Smallest Sums](https://leetcode.com/problems/find-k-pairs-with-smallest-sums/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 39: Heap - K-way Merge",
    "description": "Study Find K Pairs with Smallest Sums using the Pattern 39: Heap - K-way Merge approach.",
    "has_content": false
  },
  {
    "id": "problem_374",
    "number": 374,
    "title": "Guess Number Higher or Lower",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 53: Binary Search - On Sorted Array/List",
    "url": "https://leetcode.com/problems/guess-number-higher-or-lower/",
    "difficulty": "medium",
    "content": "# Guess Number Higher or Lower\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Guess Number Higher or Lower](https://leetcode.com/problems/guess-number-higher-or-lower/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 53: Binary Search - On Sorted Array/List",
    "description": "Study Guess Number Higher or Lower using the Pattern 53: Binary Search - On Sorted Array/List approach.",
    "has_content": false
  },
  {
    "id": "problem_377",
    "number": 377,
    "title": "Combination Sum IV",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 28: DP - 1D Array (Coin Change / Unbounded Knapsack Style)",
    "url": "https://leetcode.com/problems/combination-sum-iv/",
    "difficulty": "medium",
    "content": "# Combination Sum IV\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Combination Sum IV](https://leetcode.com/problems/combination-sum-iv/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 28: DP - 1D Array (Coin Change / Unbounded Knapsack Style)",
    "description": "Study Combination Sum IV using the Pattern 28: DP - 1D Array (Coin Change / Unbounded Knapsack Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_378",
    "number": 378,
    "title": "Kth Smallest Element in a Sorted Matrix",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 39: Heap - K-way Merge",
    "url": "https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/",
    "difficulty": "medium",
    "content": "# Kth Smallest Element in a Sorted Matrix\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Kth Smallest Element in a Sorted Matrix](https://leetcode.com/problems/kth-smallest-element-in-a-sorted-matrix/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 39: Heap - K-way Merge",
    "description": "Study Kth Smallest Element in a Sorted Matrix using the Pattern 39: Heap - K-way Merge approach.",
    "has_content": false
  },
  {
    "id": "problem_379",
    "number": 379,
    "title": "Design Phone Directory",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-phone-directory/",
    "difficulty": "medium",
    "content": "# Design Phone Directory\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design Phone Directory](https://leetcode.com/problems/design-phone-directory/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design Phone Directory using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_380",
    "number": 380,
    "title": "Insert Delete GetRandom O(1)",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/insert-delete-getrandom-o1/",
    "difficulty": "medium",
    "content": "# Insert Delete GetRandom O(1)\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Insert Delete GetRandom O(1)](https://leetcode.com/problems/insert-delete-getrandom-o1/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Insert Delete GetRandom O(1) using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_389",
    "number": 389,
    "title": "Find the Difference",
    "category": "XI. Bit Manipulation Patterns",
    "pattern": "Pattern 65: Bitwise XOR - Finding Single/Missing Number",
    "url": "https://leetcode.com/problems/find-the-difference/",
    "difficulty": "medium",
    "content": "# Find the Difference\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find the Difference](https://leetcode.com/problems/find-the-difference/)\n\n**Category:** XI. Bit Manipulation Patterns\n**Pattern:** Pattern 65: Bitwise XOR - Finding Single/Missing Number",
    "description": "Study Find the Difference using the Pattern 65: Bitwise XOR - Finding Single/Missing Number approach.",
    "has_content": false
  },
  {
    "id": "problem_392",
    "number": 392,
    "title": "Is Subsequence",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 2: Two Pointers - Fast & Slow (Cycle Detection)",
    "url": "https://leetcode.com/problems/is-subsequence/",
    "difficulty": "medium",
    "content": "---\n### **392. Is Subsequence**\n**Link to Problem:** [https://leetcode.com/problems/is-subsequence/](https://leetcode.com/problems/is-subsequence/)\n\n#### **1. Problem Statement**\nGiven two strings, `s` and `t`, the task is to determine if `s` is a subsequence of `t`. A subsequence is formed by deleting zero or more characters from the original string (`t`) without changing the relative order of the remaining characters. For example, \"ace\" is a subsequence of \"abcde\", but \"aec\" is not.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nA straightforward way to think about this is to iterate through the potential subsequence `s` character by character. For each character in `s`, we need to find its first occurrence in `t` *after* the position of the previous character we found. We can maintain a \"search-from\" index for `t`. If we ever fail to find a character, we know `s` cannot be a subsequence.\n\nThe logic is as follows:\n1.  Initialize a pointer, `search_from_index`, to 0. This tracks where in `t` we should start our next search.\n2.  Iterate through each character `char_s` in string `s`.\n3.  For each `char_s`, search for it within string `t`, but only starting from `search_from_index`.\n4.  If `char_s` is found at a position `found_pos`, we update `search_from_index` to `found_pos + 1` for the next iteration. This ensures we only look forward in `t`, preserving the relative order.\n5.  If `char_s` is not found in the remainder of `t`, it's impossible to form the subsequence. We can immediately return `False`.\n6.  If the loop completes, it means every character in `s` was found in `t` in the correct order, so we return `True`.\n\n**Python Code:**\n```python\ndef isSubsequence_brute_force(s: str, t: str) -> bool:\n    # This index tracks where our search should begin in the target string 't'.\n    search_from_index = 0\n\n    # Iterate through each character of the potential subsequence 's'.\n    for char_s in s:\n        # str.find(substring, start_index) is a convenient way to implement this logic.\n        # It searches for char_s in t, starting from our current search position.\n        found_pos = t.find(char_s, search_from_index)\n\n        # If find() returns -1, the character was not found in the rest of string 't'.\n        if found_pos == -1:\n            return False  # s cannot be a subsequence.\n        \n        # If the character was found, we must start the search for the *next*\n        # character of 's' *after* the current character's position.\n        search_from_index = found_pos + 1\n    \n    # If we successfully exit the loop, all characters of 's' were found in order.\n    return True\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(S * T)**, where `S` is the length of `s` and `T` is the length of `t`. In the worst case (e.g., `s = \"aaaa\"` and `t = \"aaaaa\"`), for each of the `S` characters in `s`, the `t.find()` method might scan a large portion of `t`.\n*   **Space Complexity: O(1)**. We only use a few variables for storage, regardless of the input string sizes.\n\n---\n### **3. Optimized Approach: Two Pointers - Fast & Slow (Cycle Detection)**\n**Intuition:**\nThe brute-force approach is inefficient because it may re-scan parts of string `t` repeatedly. We can optimize this by making a single pass through `t`. The key insight is to use two pointers to track our progress through both strings simultaneously. This is a classic application of the Two Pointers pattern.\n\nLet's call our pointers `s_ptr` (for string `s`) and `t_ptr` (for string `t`). Both start at index 0.\n\n1.  `s_ptr` points to the character in `s` we are currently looking for.\n2.  `t_ptr` scans through string `t`.\n\nThe algorithm works by advancing `t_ptr` through `t` and only advancing `s_ptr` when we find a match. This ensures we check for characters in the correct relative order.\n\nLet's trace `s = \"ace\"`, `t = \"abcde\"`:\n*   **Initial:** `s_ptr = 0` (points to 'a'), `t_ptr = 0` (points to 'a').\n*   **Step 1:** `s[s_ptr]` ('a') == `t[t_ptr]` ('a'). It's a match! We've found the first character of `s`. We advance **both** pointers to look for the next character.\n    *   `s_ptr` becomes 1, `t_ptr` becomes 1.\n*   **Step 2:** `s[s_ptr]` ('c') != `t[t_ptr]` ('b'). No match. We haven't found the 'c' we're looking for yet. We advance only `t_ptr` to continue scanning `t`.\n    *   `s_ptr` stays 1, `t_ptr` becomes 2.\n*   **Step 3:** `s[s_ptr]` ('c') == `t[t_ptr]` ('c'). A match! We advance **both**.\n    *   `s_ptr` becomes 2, `t_ptr` becomes 3.\n*   **Step 4:** `s[s_ptr]` ('e') != `t[t_ptr]` ('d'). No match. Advance only `t_ptr`.\n    *   `s_ptr` stays 2, `t_ptr` becomes 4.\n*   **Step 5:** `s[s_ptr]` ('e') == `t[t_ptr]` ('e'). A match! Advance **both**.\n    *   `s_ptr` becomes 3, `t_ptr` becomes 5.\n\nThe loop terminates when one of the pointers goes out of bounds. The final check is key: if `s_ptr` has successfully reached the end of `s` (i.e., `s_ptr == len(s)`), it means every character of `s` was found in order.\n\n**Python Code:**\n```python\ndef isSubsequence_optimized(s: str, t: str) -> bool:\n    # s_ptr tracks our progress in the subsequence 's'.\n    # t_ptr tracks our progress in the main string 't'.\n    s_ptr, t_ptr = 0, 0\n\n    # We continue as long as both pointers are within the bounds of their respective strings.\n    while s_ptr < len(s) and t_ptr < len(t):\n        # If the characters match, it means we've found the character s[s_ptr] in 't'.\n        # We can now look for the *next* character in 's'.\n        if s[s_ptr] == t[t_ptr]:\n            s_ptr += 1  # Move the 'slow' pointer only on a match.\n        \n        # We always advance t_ptr to scan through the main string.\n        # This is the 'fast' pointer that moves unconditionally.\n        t_ptr += 1\n    \n    # After the loop, if s_ptr has reached the length of s,\n    # it means all characters of s were found in order.\n    return s_ptr == len(s)\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(T)**, where `T` is the length of `t`. We traverse the string `t` with `t_ptr` exactly once. The `s_ptr` only moves forward and does not add to the overall complexity. This is a significant improvement over O(S * T).\n*   **Space Complexity: O(1)**. We only use two integer variables for the pointers.\n\n---\n### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers** pattern. While it's not the \"Fast & Slow\" variant typically used for cycle detection in a single data structure, it perfectly demonstrates the power of using two pointers to process sequences in lockstep.\n\nThe key characteristics that signal the Two Pointers pattern here are:\n1.  **Comparison between two sequences:** We need to compare characters from `s` and `t`.\n2.  **Order matters:** The problem requires maintaining the relative order of characters, making a simple frequency count (like with a hash map) insufficient.\n3.  **Linear scan:** The problem can be solved by iterating through the strings without complex nested structures.\n\nThe two pointers, `s_ptr` and `t_ptr`, efficiently manage state: `s_ptr` represents the \"requirement\" (which character we are looking for), and `t_ptr` represents the \"progress\" (where we are in our search). One pointer (`t_ptr`) moves steadily forward, while the other (`s_ptr`) moves conditionally. This \"different rate of movement\" is the core principle that connects this problem to the broader family of Two Pointer algorithms, allowing us to solve it elegantly in a single, linear pass.",
    "description": "Study Is Subsequence using the Pattern 2: Two Pointers - Fast & Slow (Cycle Detection) approach.",
    "has_content": true
  },
  {
    "id": "problem_394",
    "number": 394,
    "title": "Decode String",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 61: Stack - Simulation / Backtracking Helper",
    "url": "https://leetcode.com/problems/decode-string/",
    "difficulty": "medium",
    "content": "# Decode String\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Decode String](https://leetcode.com/problems/decode-string/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 61: Stack - Simulation / Backtracking Helper",
    "description": "Study Decode String using the Pattern 61: Stack - Simulation / Backtracking Helper approach.",
    "has_content": false
  },
  {
    "id": "problem_402",
    "number": 402,
    "title": "Remove K Digits",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 59: Stack - Monotonic Stack",
    "url": "https://leetcode.com/problems/remove-k-digits/",
    "difficulty": "medium",
    "content": "# Remove K Digits\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Remove K Digits](https://leetcode.com/problems/remove-k-digits/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 59: Stack - Monotonic Stack",
    "description": "Study Remove K Digits using the Pattern 59: Stack - Monotonic Stack approach.",
    "has_content": false
  },
  {
    "id": "problem_410",
    "number": 410,
    "title": "Split Array Largest Sum",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 55: Binary Search - On Answer / Condition Function",
    "url": "https://leetcode.com/problems/split-array-largest-sum/",
    "difficulty": "medium",
    "content": "# Split Array Largest Sum\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Split Array Largest Sum](https://leetcode.com/problems/split-array-largest-sum/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 55: Binary Search - On Answer / Condition Function",
    "description": "Study Split Array Largest Sum using the Pattern 55: Binary Search - On Answer / Condition Function approach.",
    "has_content": false
  },
  {
    "id": "problem_416",
    "number": 416,
    "title": "Partition Equal Subset Sum",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 29: DP - 1D Array (0/1 Knapsack Subset Sum Style)",
    "url": "https://leetcode.com/problems/partition-equal-subset-sum/",
    "difficulty": "medium",
    "content": "# Partition Equal Subset Sum\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 29: DP - 1D Array (0/1 Knapsack Subset Sum Style)",
    "description": "Study Partition Equal Subset Sum using the Pattern 29: DP - 1D Array (0/1 Knapsack Subset Sum Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_417",
    "number": 417,
    "title": "Pacific Atlantic Water Flow",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 18: Graph DFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/pacific-atlantic-water-flow/",
    "difficulty": "medium",
    "content": "# Pacific Atlantic Water Flow\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Pacific Atlantic Water Flow](https://leetcode.com/problems/pacific-atlantic-water-flow/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 18: Graph DFS - Connected Components / Island Counting",
    "description": "Study Pacific Atlantic Water Flow using the Pattern 18: Graph DFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_424",
    "number": 424,
    "title": "Longest Repeating Character Replacement",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/longest-repeating-character-replacement/",
    "difficulty": "medium",
    "content": "# Longest Repeating Character Replacement\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Longest Repeating Character Replacement](https://leetcode.com/problems/longest-repeating-character-replacement/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Longest Repeating Character Replacement using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_432",
    "number": 432,
    "title": "All O`one Data Structure",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/all-oone-data-structure/",
    "difficulty": "medium",
    "content": "# All O`one Data Structure\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [All O`one Data Structure](https://leetcode.com/problems/all-oone-data-structure/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study All O`one Data Structure using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_438",
    "number": 438,
    "title": "Find All Anagrams in a String",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 11: Sliding Window - Character Frequency Matching",
    "url": "https://leetcode.com/problems/find-all-anagrams-in-a-string/",
    "difficulty": "medium",
    "content": "# Find All Anagrams in a String\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 11: Sliding Window - Character Frequency Matching",
    "description": "Study Find All Anagrams in a String using the Pattern 11: Sliding Window - Character Frequency Matching approach.",
    "has_content": false
  },
  {
    "id": "problem_442",
    "number": 442,
    "title": "Find All Duplicates in an Array",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 80: Array - Cyclic Sort",
    "url": "https://leetcode.com/problems/find-all-duplicates-in-an-array/",
    "difficulty": "medium",
    "content": "# Find All Duplicates in an Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find All Duplicates in an Array](https://leetcode.com/problems/find-all-duplicates-in-an-array/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 80: Array - Cyclic Sort",
    "description": "Study Find All Duplicates in an Array using the Pattern 80: Array - Cyclic Sort approach.",
    "has_content": false
  },
  {
    "id": "problem_443",
    "number": 443,
    "title": "String Compression",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 4: Two Pointers - In-place Array Modification",
    "url": "https://leetcode.com/problems/string-compression/",
    "difficulty": "medium",
    "content": "---\n### **443. String Compression**\n**Link to Problem:** [https://leetcode.com/problems/string-compression/](https://leetcode.com/problems/string-compression/)\n\n#### **1. Problem Statement**\nGiven an array of characters `chars`, compress it in-place. The compression logic is to replace consecutive repeating characters with the character itself followed by its count. If a group's length is 1, the number '1' should not be appended. The function must return the new length of the compressed array.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward idea is to ignore the \"in-place\" constraint initially to simplify the logic. We can build the compressed result in a separate data structure (like a list of characters or a string builder). After processing the entire input array, we can then copy this new, compressed result back into the beginning of the original `chars` array. This separates the logic of compression from the complexity of in-place modification.\n\n**Python Code:**\n```python\ndef compress_brute_force(chars: list[str]) -> int:\n    # This approach is not truly in-place and uses O(N) extra space.\n    if not chars:\n        return 0\n\n    # Use an auxiliary list to build the compressed result.\n    compressed_result = []\n    \n    i = 0\n    n = len(chars)\n    while i < n:\n        current_char = chars[i]\n        count = 0\n        \n        # Count consecutive occurrences of the current character.\n        j = i\n        while j < n and chars[j] == current_char:\n            count += 1\n            j += 1\n        \n        # Append the character to our result.\n        compressed_result.append(current_char)\n        \n        # If the count is greater than 1, append the digits of the count.\n        if count > 1:\n            for digit in str(count):\n                compressed_result.append(digit)\n        \n        # Move the main pointer to the start of the next new character.\n        i = j\n        \n    # Now, copy the compressed result back into the original `chars` array.\n    for i in range(len(compressed_result)):\n        chars[i] = compressed_result[i]\n    \n    # The new length is the length of our auxiliary list.\n    return len(compressed_result)\n\n# Example Usage:\n# chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n# new_length = compress_brute_force(chars)\n# print(new_length)  # Output: 6\n# print(chars[:new_length]) # Output: ['a', '2', 'b', '2', 'c', '3']\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    The `while` loop iterates through the input `chars` array once to build the `compressed_result`, which takes O(N) time. The final `for` loop to copy the result back into `chars` also takes O(N) in the worst case. Therefore, the total time complexity is O(N) + O(N) = O(N).\n\n*   **Space Complexity: O(N)**\n    This is the main drawback. We use an auxiliary list, `compressed_result`, which in the worst-case scenario (e.g., `[\"a\",\"b\",\"c\"]`) could grow to be the same size as the input array. This violates the problem's O(1) space constraint.\n\n### **3. Optimized Approach: Pattern 4: Two Pointers - In-place Array Modification**\n**Intuition:**\nTo solve this in-place, we need a way to overwrite the input array `chars` without losing information we still need to read. This is a perfect scenario for a \"read/write\" two-pointer approach.\n\nWe'll use two pointers:\n1.  A `read` pointer (`i` in the code) that scans through the original array.\n2.  A `write` pointer (`write_idx`) that marks the position in the array where the next piece of compressed information (a character or a digit) should be written.\n\nThe `read` pointer will always be ahead of or at the same position as the `write` pointer. The `read` pointer's job is to find the boundaries of a group of consecutive characters. Once a group is identified (e.g., \"a\", \"a\", \"a\"), the `write` pointer writes the character ('a') and its count ('3') to the front of the array. This process overwrites the old data, which is safe because the `read` pointer has already scanned past it.\n\nLet's walk through `chars = [\"a\", \"a\", \"b\", \"b\", \"c\", \"c\", \"c\"]`:\n\n1.  Initialize `read = 0` and `write_idx = 0`.\n2.  **Group 'a':** The `read` pointer scans forward and finds two 'a's.\n    *   Write the character: `chars[write_idx] = 'a'`. `write_idx` is now 1.\n    *   Count is 2. Convert '2' to a character and write it: `chars[write_idx] = '2'`. `write_idx` is now 2.\n    *   `chars` is now `[\"a\", \"2\", \"b\", \"b\", \"c\", \"c\", \"c\"]`.\n3.  **Group 'b':** The `read` pointer is now at the first 'b' (index 2). It scans forward and finds two 'b's.\n    *   Write the character: `chars[write_idx] = 'b'`. `write_idx` is now 3.\n    *   Count is 2. Write '2': `chars[write_idx] = '2'`. `write_idx` is now 4.\n    *   `chars` is now `[\"a\", \"2\", \"b\", \"2\", \"c\", \"c\", \"c\"]`.\n4.  **Group 'c':** The `read` pointer is now at the first 'c' (index 4). It scans forward and finds three 'c's.\n    *   Write the character: `chars[write_idx] = 'c'`. `write_idx` is now 5.\n    *   Count is 3. Write '3': `chars[write_idx] = '3'`. `write_idx` is now 6.\n    *   `chars` is now `[\"a\", \"2\", \"b\", \"2\", \"c\", \"3\", \"c\"]`.\n5.  The `read` pointer reaches the end. The final value of `write_idx` (6) is the new length.\n\n**Python Code:**\n```python\ndef compress(chars: list[str]) -> int:\n    # write_idx is our slow \"write\" pointer.\n    # It tracks the end of the compressed section of the array.\n    write_idx = 0\n    \n    # read_ptr is our fast \"read\" pointer.\n    # It scans the original array.\n    read_ptr = 0\n    n = len(chars)\n\n    while read_ptr < n:\n        current_char = chars[read_ptr]\n        count = 0\n        \n        # Use a separate pointer to find the end of the current group of characters.\n        group_end_ptr = read_ptr\n        while group_end_ptr < n and chars[group_end_ptr] == current_char:\n            count += 1\n            group_end_ptr += 1\n            \n        # --- Perform the In-place Write ---\n        # 1. Write the character itself.\n        chars[write_idx] = current_char\n        write_idx += 1\n        \n        # 2. If the count is > 1, write the digits of the count.\n        if count > 1:\n            for digit in str(count):\n                chars[write_idx] = digit\n                write_idx += 1\n        \n        # Move the read pointer to the start of the next group.\n        read_ptr = group_end_ptr\n        \n    # The final position of the write_idx is the new length of the array.\n    return write_idx\n\n# Example Usage:\n# chars = [\"a\",\"a\",\"b\",\"b\",\"c\",\"c\",\"c\"]\n# new_length = compress(chars)\n# print(new_length)  # Output: 6\n# print(chars[:new_length]) # Output: ['a', '2', 'b', '2', 'c', '3']\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    Although we have a nested `while` loop, this is a single-pass solution. The outer `read_ptr` and the inner `group_end_ptr` together ensure that each character in the `chars` array is visited exactly once. Therefore, the time complexity is linear.\n\n*   **Space Complexity: O(1)**\n    This is the key improvement. We modify the array in-place and only use a few variables (`write_idx`, `read_ptr`, `count`, etc.) for tracking. The space required does not depend on the size of the input array.\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - In-place Array Modification** pattern. The pattern is signaled by two key constraints:\n1.  The modification must happen **in-place**.\n2.  The result of the modification is guaranteed to be **shorter than or equal to** the original array length.\n\nThese constraints create a scenario where you can safely overwrite the beginning of the array while reading from a point further ahead. The \"write\" pointer (`write_idx`) constructs the new, valid array at the front, while the \"read\" pointer (`read_ptr`) explores the yet-unprocessed part of the original array. This separation of reading and writing duties is the core concept of the pattern, allowing for efficient O(1) space solutions to problems that would otherwise seem to require extra memory. Problems like \"Remove Duplicates from Sorted Array\" (LeetCode 26) and \"Move Zeroes\" (LeetCode 283) follow this exact same structural logic.",
    "description": "Study String Compression using the Pattern 4: Two Pointers - In-place Array Modification approach.",
    "has_content": true
  },
  {
    "id": "problem_444",
    "number": 444,
    "title": "Sequence Reconstruction",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "url": "https://leetcode.com/problems/sequence-reconstruction/",
    "difficulty": "medium",
    "content": "# Sequence Reconstruction\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Sequence Reconstruction](https://leetcode.com/problems/sequence-reconstruction/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "description": "Study Sequence Reconstruction using the Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_448",
    "number": 448,
    "title": "Find All Numbers Disappeared in an Array",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 80: Array - Cyclic Sort",
    "url": "https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/",
    "difficulty": "medium",
    "content": "# Find All Numbers Disappeared in an Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find All Numbers Disappeared in an Array](https://leetcode.com/problems/find-all-numbers-disappeared-in-an-array/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 80: Array - Cyclic Sort",
    "description": "Study Find All Numbers Disappeared in an Array using the Pattern 80: Array - Cyclic Sort approach.",
    "has_content": false
  },
  {
    "id": "problem_451",
    "number": 451,
    "title": "Sort Characters By Frequency",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "url": "https://leetcode.com/problems/sort-characters-by-frequency/",
    "difficulty": "medium",
    "content": "# Sort Characters By Frequency\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Sort Characters By Frequency](https://leetcode.com/problems/sort-characters-by-frequency/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "description": "Study Sort Characters By Frequency using the Pattern 37: Heap - Top K Elements (Selection/Frequency) approach.",
    "has_content": false
  },
  {
    "id": "problem_459",
    "number": 459,
    "title": "Repeated Substring Pattern",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 88: String - Repeated Substring Pattern Detection",
    "url": "https://leetcode.com/problems/repeated-substring-pattern/",
    "difficulty": "medium",
    "content": "# Repeated Substring Pattern\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Repeated Substring Pattern](https://leetcode.com/problems/repeated-substring-pattern/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 88: String - Repeated Substring Pattern Detection",
    "description": "Study Repeated Substring Pattern using the Pattern 88: String - Repeated Substring Pattern Detection approach.",
    "has_content": false
  },
  {
    "id": "problem_460",
    "number": 460,
    "title": "LFU Cache",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/lfu-cache/",
    "difficulty": "medium",
    "content": "# LFU Cache\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [LFU Cache](https://leetcode.com/problems/lfu-cache/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study LFU Cache using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_494",
    "number": 494,
    "title": "Target Sum",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 29: DP - 1D Array (0/1 Knapsack Subset Sum Style)",
    "url": "https://leetcode.com/problems/target-sum/",
    "difficulty": "medium",
    "content": "# Target Sum\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Target Sum](https://leetcode.com/problems/target-sum/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 29: DP - 1D Array (0/1 Knapsack Subset Sum Style)",
    "description": "Study Target Sum using the Pattern 29: DP - 1D Array (0/1 Knapsack Subset Sum Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_496",
    "number": 496,
    "title": "Next Greater Element I",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 59: Stack - Monotonic Stack",
    "url": "https://leetcode.com/problems/next-greater-element-i/",
    "difficulty": "medium",
    "content": "# Next Greater Element I\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Next Greater Element I](https://leetcode.com/problems/next-greater-element-i/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 59: Stack - Monotonic Stack",
    "description": "Study Next Greater Element I using the Pattern 59: Stack - Monotonic Stack approach.",
    "has_content": false
  },
  {
    "id": "problem_501",
    "number": 501,
    "title": "Find Mode in Binary Search Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "url": "https://leetcode.com/problems/find-mode-in-binary-search-tree/",
    "difficulty": "hard",
    "content": "# Find Mode in Binary Search Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find Mode in Binary Search Tree](https://leetcode.com/problems/find-mode-in-binary-search-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "description": "Study Find Mode in Binary Search Tree using the Pattern 14: Tree DFS - Recursive Inorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_503",
    "number": 503,
    "title": "Next Greater Element II",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 59: Stack - Monotonic Stack",
    "url": "https://leetcode.com/problems/next-greater-element-ii/",
    "difficulty": "hard",
    "content": "# Next Greater Element II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Next Greater Element II](https://leetcode.com/problems/next-greater-element-ii/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 59: Stack - Monotonic Stack",
    "description": "Study Next Greater Element II using the Pattern 59: Stack - Monotonic Stack approach.",
    "has_content": false
  },
  {
    "id": "problem_506",
    "number": 506,
    "title": "Relative Ranks",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "url": "https://leetcode.com/problems/relative-ranks/",
    "difficulty": "hard",
    "content": "# Relative Ranks\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Relative Ranks](https://leetcode.com/problems/relative-ranks/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "description": "Study Relative Ranks using the Pattern 37: Heap - Top K Elements (Selection/Frequency) approach.",
    "has_content": false
  },
  {
    "id": "problem_509",
    "number": 509,
    "title": "Fibonacci Number",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 26: DP - 1D Array (Fibonacci Style)",
    "url": "https://leetcode.com/problems/fibonacci-number/",
    "difficulty": "hard",
    "content": "# Fibonacci Number\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Fibonacci Number](https://leetcode.com/problems/fibonacci-number/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 26: DP - 1D Array (Fibonacci Style)",
    "description": "Study Fibonacci Number using the Pattern 26: DP - 1D Array (Fibonacci Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_515",
    "number": 515,
    "title": "Find Largest Value in Each Tree Row",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 12: Tree BFS - Level Order Traversal",
    "url": "https://leetcode.com/problems/find-largest-value-in-each-tree-row/",
    "difficulty": "hard",
    "content": "# Find Largest Value in Each Tree Row\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find Largest Value in Each Tree Row](https://leetcode.com/problems/find-largest-value-in-each-tree-row/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 12: Tree BFS - Level Order Traversal",
    "description": "Study Find Largest Value in Each Tree Row using the Pattern 12: Tree BFS - Level Order Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_518",
    "number": 518,
    "title": "Coin Change II",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 28: DP - 1D Array (Coin Change / Unbounded Knapsack Style)",
    "url": "https://leetcode.com/problems/coin-change-ii/",
    "difficulty": "hard",
    "content": "# Coin Change II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Coin Change II](https://leetcode.com/problems/coin-change-ii/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 28: DP - 1D Array (Coin Change / Unbounded Knapsack Style)",
    "description": "Study Coin Change II using the Pattern 28: DP - 1D Array (Coin Change / Unbounded Knapsack Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_530",
    "number": 530,
    "title": "Minimum Absolute Difference in BST",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "url": "https://leetcode.com/problems/minimum-absolute-difference-in-bst/",
    "difficulty": "hard",
    "content": "# Minimum Absolute Difference in BST\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Absolute Difference in BST](https://leetcode.com/problems/minimum-absolute-difference-in-bst/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 14: Tree DFS - Recursive Inorder Traversal",
    "description": "Study Minimum Absolute Difference in BST using the Pattern 14: Tree DFS - Recursive Inorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_540",
    "number": 540,
    "title": "Single Element in a Sorted Array",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 53: Binary Search - On Sorted Array/List",
    "url": "https://leetcode.com/problems/single-element-in-a-sorted-array/",
    "difficulty": "hard",
    "content": "# Single Element in a Sorted Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Single Element in a Sorted Array](https://leetcode.com/problems/single-element-in-a-sorted-array/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 53: Binary Search - On Sorted Array/List",
    "description": "Study Single Element in a Sorted Array using the Pattern 53: Binary Search - On Sorted Array/List approach.",
    "has_content": false
  },
  {
    "id": "problem_541",
    "number": 541,
    "title": "Reverse String II",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 7: Two Pointers - String Reversal",
    "url": "https://leetcode.com/problems/reverse-string-ii/",
    "difficulty": "hard",
    "content": "---\n### **541. Reverse String II**\n**Link to Problem:** [https://leetcode.com/problems/reverse-string-ii/](https://leetcode.com/problems/reverse-string-ii/)\n\n#### **1. Problem Statement**\nGiven a string `s` and an integer `k`, the core task is to modify the string by reversing the first `k` characters for every `2k` characters, starting from the beginning. If there are fewer than `k` characters left at the end, all of them are reversed. If there are between `k` and `2k` characters left, only the first `k` are reversed, and the rest remain unchanged. The output is the modified string.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to conceptualize this is to build the result piece by piece. We can iterate through the string in chunks of `2k`. For each chunk, we identify the part that needs reversal (the first `k` characters) and the part that doesn't (the next `k` characters). We can use string slicing to extract these parts, reverse the necessary segment, and then concatenate them to form a new result string. We must carefully handle the final segment of the string, which might not be a full `2k` characters long.\n\nSince strings are immutable in Python, we would convert the string to a list of characters, perform the slicing and reversal on the list, and then join it back into a string.\n\n**Python Code:**\n```python\ndef reverseStr_brute_force(s: str, k: int) -> str:\n    \"\"\"\n    A straightforward approach using list conversion and slicing.\n    \"\"\"\n    # In Python, strings are immutable. To modify characters, we must\n    # first convert the string to a list, which is a mutable sequence.\n    char_list = list(s)\n    \n    # We iterate through the list in steps of 2*k, as the problem\n    # defines the logic based on chunks of this size.\n    for i in range(0, len(char_list), 2 * k):\n        # Define the segment to be reversed. It starts at `i` and ends at `i+k`.\n        start = i\n        # The end of the slice might go past the end of the string, but\n        # Python's slicing handles this gracefully.\n        end = i + k\n        \n        # Extract the segment that needs to be reversed.\n        segment_to_reverse = char_list[start:end]\n        \n        # Reverse it using Python's convenient slice notation `[::-1]`.\n        reversed_segment = segment_to_reverse[::-1]\n        \n        # Place the reversed segment back into the list.\n        char_list[start:end] = reversed_segment\n\n    # Finally, join the characters in the list back into a single string.\n    return \"\".join(char_list)\n\n# Example:\n# s = \"abcdefg\", k = 2\n# char_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g']\n# i = 0: reverse char_list[0:2] -> ['b', 'a', 'c', 'd', 'e', 'f', 'g']\n# i = 4: reverse char_list[4:6] -> ['b', 'a', 'c', 'd', 'f', 'e', 'g']\n# result: \"bacdfeg\"\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**, where N is the length of the string. The `range` function steps through the string, ensuring we visit each `2k` block once. The slicing and reversing of a `k`-sized segment takes O(k) time. Since we do this N / (2k) times, the total time for all reversals is `(N / 2k) * O(k) = O(N)`. Converting the string to a list and joining it back also takes O(N).\n*   **Space Complexity: O(N)**. We create a list of characters from the string, which requires O(N) space. Furthermore, the slicing operation `segment_to_reverse[::-1]` creates a temporary copy of the segment, though this doesn't change the overall O(N) complexity dominated by the character list.\n\n### **3. Optimized Approach: [Pattern 7: Two Pointers - String Reversal]**\n**Intuition:**\nWhile the brute-force approach has an optimal time complexity of O(N), we can refine the *implementation* by performing the reversal **in-place** on our list of characters. This avoids creating temporary copies of slices and directly applies the classic **Two Pointers - String Reversal** pattern.\n\nThe overall strategy is the same: iterate through the string in chunks of `2k`. However, instead of using Python's `[::-1]` slicing shortcut to reverse segments, we'll implement the reversal manually with two pointers.\n\nFor each segment that needs reversing (i.e., the first `k` characters of a `2k` chunk), we'll do the following:\n1.  Initialize a `left` pointer to the start of the segment.\n2.  Initialize a `right` pointer to the end of the segment.\n3.  While `left` is less than `right`, swap the characters at these pointers.\n4.  Move `left` one step to the right and `right` one step to the left.\n\nThis process continues until the pointers meet or cross, at which point the segment is fully reversed. The key is to correctly calculate the `right` pointer's initial position to handle the string's edge cases naturally. `right` should be the end of the reversal block (`i + k - 1`) or the end of the string, whichever comes first.\n\nLet's walk through `s = \"abcdefg\", k = 2`:\n-   Convert `s` to `char_list = ['a', 'b', 'c', 'd', 'e', 'f', 'g']`.\n-   **Iteration 1 (i=0):**\n    -   `left` pointer starts at `i = 0`.\n    -   `right` pointer starts at `min(0 + 2 - 1, 6) = 1`.\n    -   `while left < right`:\n        -   `swap(char_list[0], char_list[1])`. List becomes `['b', 'a', 'c', 'd', 'e', 'f', 'g']`.\n        -   `left` becomes 1, `right` becomes 0. Loop terminates.\n-   **Iteration 2 (i=4):**\n    -   `left` pointer starts at `i = 4`.\n    -   `right` pointer starts at `min(4 + 2 - 1, 6) = 5`.\n    -   `while left < right`:\n        -   `swap(char_list[4], char_list[5])`. List becomes `['b', 'a', 'c', 'd', 'f', 'e', 'g']`.\n        -   `left` becomes 5, `right` becomes 4. Loop terminates.\n-   The loop finishes. Join the list to get `\"bacdfeg\"`.\n\nThis in-place swap is the essence of the Two Pointer pattern for reversal.\n\n**Python Code:**\n```python\ndef reverseStr(s: str, k: int) -> str:\n    \"\"\"\n    Optimized approach using the Two Pointer pattern for in-place reversal.\n    \"\"\"\n    # As before, we need a mutable sequence to perform swaps.\n    char_list = list(s)\n    \n    # Iterate through the string in steps of 2*k.\n    for i in range(0, len(s), 2 * k):\n        # --- Start of the Two Pointer Pattern ---\n        \n        # The 'left' pointer always starts at the beginning of the 2k chunk.\n        left = i\n        \n        # The 'right' pointer is at the end of the k-length segment we need to reverse.\n        # We use min() to gracefully handle the final chunks of the string:\n        # 1. If len(remaining) < k, right will be the last index of the string.\n        # 2. If k <= len(remaining) < 2k, right will be i + k - 1.\n        right = min(i + k - 1, len(s) - 1)\n        \n        # Core reversal loop: pointers move towards each other, swapping elements.\n        while left < right:\n            # Python's tuple unpacking makes the swap clean and efficient.\n            char_list[left], char_list[right] = char_list[right], char_list[left]\n            \n            # Move the pointers inward.\n            left += 1\n            right -= 1\n        \n        # --- End of the Two Pointer Pattern ---\n            \n    # Join the modified list back into a string.\n    return \"\".join(char_list)\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**. This remains the same. The outer loop combined with the inner `while` loop ensures that each character is visited a constant number of times. The `left` and `right` pointers together traverse each `k`-sized segment exactly once.\n*   **Space Complexity: O(N)**. In Python, this is unchanged because of string immutability requiring the `char_list` conversion. However, it's important to note that the algorithm *itself* is O(1) in terms of auxiliary space (ignoring the input/output storage). In a language with mutable strings like C++, this exact logic would achieve O(1) space complexity.\n\n#### **4. Pattern Connection**\nThis problem is a perfect illustration of applying a fundamental pattern—**Two Pointers for Reversal**—as a subroutine to solve a more complex problem.\n\nThe key signal for this pattern is any task that requires **reversing a sequence or a subsequence in-place**. While simple string reversal might seem trivial, especially in Python with its slicing syntax, understanding the underlying two-pointer mechanism is critical. Here, the problem isn't just to reverse the whole string, but to repeatedly reverse *specific segments*.\n\nThis problem demonstrates that mastery of a pattern isn't just about solving the canonical problem (e.g., \"reverse this entire string\"), but about recognizing when it can be used as a building block. The characteristics that make this a Two Pointer problem are:\n1.  **Core Sub-Problem:** The fundamental operation is reversing a contiguous block of characters.\n2.  **In-Place Modification:** The most efficient way to perform this reversal is in-place, which immediately suggests a swapping mechanism.\n3.  **Symmetrical Operation:** The swap operation is symmetrical: the first element is swapped with the last, the second with the second-to-last, and so on, which is the exact motion of two pointers moving towards a center.\n\nBy identifying the \"reverse this segment\" sub-problem, you can immediately map it to the Two Pointers - String Reversal pattern, simplifying the logic and leading to a clean, efficient, and fundamental solution.",
    "description": "Study Reverse String II using the Pattern 7: Two Pointers - String Reversal approach.",
    "has_content": true
  },
  {
    "id": "problem_542",
    "number": 542,
    "title": "01 Matrix",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 19: Graph BFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/01-matrix/",
    "difficulty": "hard",
    "content": "# 01 Matrix\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [01 Matrix](https://leetcode.com/problems/01-matrix/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 19: Graph BFS - Connected Components / Island Counting",
    "description": "Study 01 Matrix using the Pattern 19: Graph BFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_543",
    "number": 543,
    "title": "Diameter of Binary Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "url": "https://leetcode.com/problems/diameter-of-binary-tree/",
    "difficulty": "hard",
    "content": "# Diameter of Binary Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Diameter of Binary Tree](https://leetcode.com/problems/diameter-of-binary-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "description": "Study Diameter of Binary Tree using the Pattern 15: Tree DFS - Recursive Postorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_546",
    "number": 546,
    "title": "Remove Boxes",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 34: DP - Interval DP",
    "url": "https://leetcode.com/problems/remove-boxes/",
    "difficulty": "hard",
    "content": "# Remove Boxes\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Remove Boxes](https://leetcode.com/problems/remove-boxes/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 34: DP - Interval DP",
    "description": "Study Remove Boxes using the Pattern 34: DP - Interval DP approach.",
    "has_content": false
  },
  {
    "id": "problem_547",
    "number": 547,
    "title": "Number of Provinces",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/number-of-provinces/",
    "difficulty": "hard",
    "content": "# Number of Provinces\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Number of Provinces](https://leetcode.com/problems/number-of-provinces/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study Number of Provinces using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_567",
    "number": 567,
    "title": "Permutation in String",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 11: Sliding Window - Character Frequency Matching",
    "url": "https://leetcode.com/problems/permutation-in-string/",
    "difficulty": "hard",
    "content": "# Permutation in String\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Permutation in String](https://leetcode.com/problems/permutation-in-string/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 11: Sliding Window - Character Frequency Matching",
    "description": "Study Permutation in String using the Pattern 11: Sliding Window - Character Frequency Matching approach.",
    "has_content": false
  },
  {
    "id": "problem_572",
    "number": 572,
    "title": "Subtree of Another Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 17: Tree - Serialization and Deserialization",
    "url": "https://leetcode.com/problems/subtree-of-another-tree/",
    "difficulty": "hard",
    "content": "# Subtree of Another Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Subtree of Another Tree](https://leetcode.com/problems/subtree-of-another-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 17: Tree - Serialization and Deserialization",
    "description": "Study Subtree of Another Tree using the Pattern 17: Tree - Serialization and Deserialization approach.",
    "has_content": false
  },
  {
    "id": "problem_583",
    "number": 583,
    "title": "Delete Operation for Two Strings",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 32: DP - 2D Array (Edit Distance / Levenshtein Distance)",
    "url": "https://leetcode.com/problems/delete-operation-for-two-strings/",
    "difficulty": "hard",
    "content": "# Delete Operation for Two Strings\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Delete Operation for Two Strings](https://leetcode.com/problems/delete-operation-for-two-strings/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 32: DP - 2D Array (Edit Distance / Levenshtein Distance)",
    "description": "Study Delete Operation for Two Strings using the Pattern 32: DP - 2D Array (Edit Distance / Levenshtein Distance) approach.",
    "has_content": false
  },
  {
    "id": "problem_604",
    "number": 604,
    "title": "Design Compressed String Iterator",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-compressed-string-iterator/",
    "difficulty": "hard",
    "content": "# Design Compressed String Iterator\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design Compressed String Iterator](https://leetcode.com/problems/design-compressed-string-iterator/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design Compressed String Iterator using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_621",
    "number": 621,
    "title": "Task Scheduler",
    "category": "VIII. Greedy Patterns",
    "pattern": "Pattern 52: Greedy - Task Scheduling (Frequency Based)",
    "url": "https://leetcode.com/problems/task-scheduler/",
    "difficulty": "hard",
    "content": "# Task Scheduler\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Task Scheduler](https://leetcode.com/problems/task-scheduler/)\n\n**Category:** VIII. Greedy Patterns\n**Pattern:** Pattern 52: Greedy - Task Scheduling (Frequency Based)",
    "description": "Study Task Scheduler using the Pattern 52: Greedy - Task Scheduling (Frequency Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_622",
    "number": 622,
    "title": "Design Circular Queue",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-circular-queue/",
    "difficulty": "hard",
    "content": "# Design Circular Queue\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design Circular Queue](https://leetcode.com/problems/design-circular-queue/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design Circular Queue using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_632",
    "number": 632,
    "title": "Smallest Range Covering Elements from K Lists",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 39: Heap - K-way Merge",
    "url": "https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/",
    "difficulty": "hard",
    "content": "# Smallest Range Covering Elements from K Lists\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Smallest Range Covering Elements from K Lists](https://leetcode.com/problems/smallest-range-covering-elements-from-k-lists/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 39: Heap - K-way Merge",
    "description": "Study Smallest Range Covering Elements from K Lists using the Pattern 39: Heap - K-way Merge approach.",
    "has_content": false
  },
  {
    "id": "problem_641",
    "number": 641,
    "title": "Design Circular Deque",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-circular-deque/",
    "difficulty": "hard",
    "content": "# Design Circular Deque\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design Circular Deque](https://leetcode.com/problems/design-circular-deque/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design Circular Deque using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_642",
    "number": 642,
    "title": "Design Search Autocomplete System",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-search-autocomplete-system/",
    "difficulty": "hard",
    "content": "# Design Search Autocomplete System\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design Search Autocomplete System](https://leetcode.com/problems/design-search-autocomplete-system/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design Search Autocomplete System using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_643",
    "number": 643,
    "title": "Maximum Average Subarray I",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 8: Sliding Window - Fixed Size (Subarray Calculation)",
    "url": "https://leetcode.com/problems/maximum-average-subarray-i/",
    "difficulty": "hard",
    "content": "---\n### **643. Maximum Average Subarray I**\n**Link to Problem:** [https://leetcode.com/problems/maximum-average-subarray-i/](https://leetcode.com/problems/maximum-average-subarray-i/)\n\n#### **1. Problem Statement**\nGiven an array of integers `nums` and an integer `k`, the task is to find the contiguous subarray of length `k` that has the maximum average value. The function should return this maximum average value.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to examine every possible contiguous subarray of length `k`. We can iterate through the array, treating each index as the potential start of a subarray. For each starting index `i`, we then form a subarray of length `k` (from `i` to `i + k - 1`) and calculate its sum. We keep track of the maximum sum found so far. After checking all possible subarrays, we divide the maximum sum by `k` to get the final average.\n\n**Python Code:**\n```python\nimport math\n\ndef findMaxAverage_bruteforce(nums: list[int], k: int) -> float:\n    \"\"\"\n    Finds the maximum average of a subarray of size k using a brute-force approach.\n    \"\"\"\n    # Initialize max_sum to a very small number to ensure any valid sum will be larger.\n    max_sum = -math.inf\n    n = len(nums)\n    \n    # The outer loop determines the starting point of each subarray.\n    # We only need to start up to the point where a full subarray of size k can be formed.\n    for i in range(n - k + 1):\n        current_sum = 0\n        # The inner loop calculates the sum for the current subarray starting at i.\n        for j in range(i, i + k):\n            current_sum += nums[j]\n        \n        # After calculating the sum of the current window,\n        # update the overall maximum sum if needed.\n        if current_sum > max_sum:\n            max_sum = current_sum\n            \n    # The problem asks for the average, so we divide the maximum sum by k.\n    return max_sum / k\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** **O(n * k)**\n    The outer loop runs `n - k + 1` times, and for each of these iterations, the inner loop runs `k` times to calculate the sum. This results in a time complexity proportional to `(n - k + 1) * k`, which simplifies to O(n * k).\n\n*   **Space Complexity:** **O(1)**\n    We only use a few variables (`max_sum`, `current_sum`, `i`, `j`) to store intermediate values, regardless of the input size.\n\n### **3. Optimized Approach: [Pattern 8: Sliding Window - Fixed Size (Subarray Calculation)]**\n**Intuition:**\nThe brute-force method is inefficient because it repeatedly re-calculates the sum of overlapping elements. For instance, when we move from the subarray `nums[0...k-1]` to `nums[1...k]`, we re-sum the common elements `nums[1...k-1]`.\n\nThe **Sliding Window** pattern eliminates this redundant work. The core idea is to maintain a \"window\" of size `k` and slide it across the array one element at a time. Instead of re-calculating the sum for each new window, we can update the sum from the previous window in constant time, O(1).\n\nHere’s the step-by-step logic:\n1.  **Initialize the Window:** Calculate the sum of the very first subarray (the first `k` elements). This sum becomes our initial `max_sum`.\n2.  **Slide the Window:** Iterate from the `k`-th element to the end of the array. In each step:\n    *   **Add the new element:** Add the current element (the one entering the window from the right) to our running sum.\n    *   **Subtract the old element:** Subtract the element that is falling off the left side of the window.\n3.  **Update Maximum:** After each slide, the running sum represents the sum of the new window. Compare this new sum with `max_sum` and update `max_sum` if the new sum is greater.\n4.  **Calculate Final Average:** After the loop finishes, `max_sum` will hold the maximum sum of any contiguous subarray of size `k`. Divide it by `k` to get the result.\n\nLet's walk through an example: `nums = [1, 12, -5, -6, 50, 3]`, `k = 4`.\n\n1.  **Initial Window:** `[1, 12, -5, -6]`. `window_sum = 1 + 12 - 5 - 6 = 2`. `max_sum` is initialized to `2`.\n2.  **Slide 1:**\n    *   The window moves right. The new element is `50` (at index 4). The old element is `1` (at index 0).\n    *   Update sum: `new_sum = 2 - 1 + 50 = 51`.\n    *   Compare: `51 > 2`, so `max_sum` is now `51`.\n3.  **Slide 2:**\n    *   The window moves right again. The new element is `3` (at index 5). The old element is `12` (at index 1).\n    *   Update sum: `new_sum = 51 - 12 + 3 = 42`.\n    *   Compare: `42 < 51`, so `max_sum` remains `51`.\n4.  The loop ends. The final result is `max_sum / k = 51 / 4 = 12.75`.\n\n**Python Code:**\n```python\ndef findMaxAverage(nums: list[int], k: int) -> float:\n    \"\"\"\n    Finds the maximum average of a subarray of size k using a fixed-size sliding window.\n    \"\"\"\n    # 1. Initialize the window\n    # Calculate the sum of the first 'k' elements to establish the initial window.\n    window_sum = sum(nums[0:k])\n    max_sum = window_sum\n    n = len(nums)\n    \n    # 2. Slide the window\n    # Iterate from the k-th element to the end of the array.\n    for i in range(k, n):\n        # The core of the sliding window: update the sum in O(1).\n        # Add the new element entering the window from the right.\n        # Subtract the old element leaving the window from the left.\n        window_sum += nums[i] - nums[i - k]\n        \n        # 3. Update Maximum\n        # Check if the new window's sum is greater than the max sum found so far.\n        max_sum = max(max_sum, window_sum)\n            \n    # 4. Calculate Final Average\n    # Return the final average by dividing the overall maximum sum by k.\n    return max_sum / k\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** **O(n)**\n    We calculate the sum of the first `k` elements, which takes O(k) time. Then, we iterate through the rest of the array from index `k` to `n-1`. This loop runs `n - k` times, and each step inside is an O(1) operation. The total time is O(k + (n - k)) = O(n). We process each element of the array a constant number of times.\n\n*   **Space Complexity:** **O(1)**\n    The algorithm uses only a few variables (`window_sum`, `max_sum`, `n`, `i`) for its calculations, so the space required is constant and does not depend on the size of the input array.\n\n### **4. Pattern Connection**\nThis problem is a quintessential example of the **Fixed-Size Sliding Window** pattern. The key signals in the problem statement that point directly to this pattern are:\n\n1.  **Contiguous Subarray:** The problem asks to operate on a \"contiguous subarray,\" which is a primary indicator for window-based approaches.\n2.  **Fixed Size `k`:** The constraint is on a subarray of a specific, unchanging length `k`. This \"fixed size\" is the most telling characteristic. Unlike variable-size window problems where you might expand/shrink the window based on a condition, here the window's size is constant, simplifying the logic to just \"sliding.\"\n3.  **Aggregate Calculation:** The goal is to find a maximum value derived from an aggregate property (sum, which leads to average) of these subarrays.\n\nThe brute-force solution's inefficiency arises from re-computing this aggregate value for overlapping subarrays. The Fixed-Size Sliding Window pattern is the direct optimization for this exact scenario. It elegantly maintains the aggregate value by making small, constant-time adjustments as the window slides, thereby reducing the time complexity from quadratic O(n*k) to a much more efficient linear O(n).",
    "description": "Study Maximum Average Subarray I using the Pattern 8: Sliding Window - Fixed Size (Subarray Calculation) approach.",
    "has_content": true
  },
  {
    "id": "problem_647",
    "number": 647,
    "title": "Palindromic Substrings",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 6: Two Pointers - Expanding From Center (Palindromes)",
    "url": "https://leetcode.com/problems/palindromic-substrings/",
    "difficulty": "hard",
    "content": "---\n### **647. Palindromic Substrings**\n**Link to Problem:** [https://leetcode.com/problems/palindromic-substrings/](https://leetcode.com/problems/palindromic-substrings/)\n\n#### **1. Problem Statement**\nGiven a string `s`, the task is to count the total number of palindromic substrings it contains. A substring is a contiguous sequence of characters, and a palindrome reads the same forwards and backward. Substrings with different start or end indices are counted as distinct even if they consist of the same characters.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to generate every possible substring of `s`, and for each one, check if it is a palindrome. We can generate all substrings using two nested loops: the outer loop `i` will determine the starting index and the inner loop `j` will determine the ending index. A simple helper check, like comparing a substring to its reverse, can validate if it's a palindrome.\n\n**Python Code:**\n```python\nclass Solution:\n    def countSubstrings(self, s: str) -> int:\n        n = len(s)\n        count = 0\n\n        # Step 1: Iterate through all possible starting points of a substring.\n        for i in range(n):\n            # Step 2: Iterate through all possible ending points for the given start.\n            for j in range(i, n):\n                # Step 3: Extract the substring from index i to j (inclusive).\n                substring = s[i : j + 1]\n                \n                # Step 4: Check if the extracted substring is a palindrome.\n                # The `[::-1]` slice notation is a concise way to reverse a string in Python.\n                if substring == substring[::-1]:\n                    count += 1\n        \n        return count\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N³)**\n    This is due to three nested levels of work. The two nested loops (`i` and `j`) give us O(N²) iterations for generating all substrings. Inside the inner loop, creating the substring slice `s[i:j+1]` and then reversing it `substring[::-1]` both take time proportional to the length of the substring, which can be up to O(N). This results in a total complexity of O(N² * N) = O(N³).\n\n*   **Space Complexity: O(N)**\n    In each iteration of the inner loop, a new `substring` is created. In the worst case, this substring can have a length of N, so the space required for this temporary variable is O(N).\n\n---\n### **3. Optimized Approach: Two Pointers - Expanding From Center**\n**Intuition:**\nThe brute-force approach is slow because it re-evaluates the same characters many times within different substrings. A more efficient strategy is to flip the logic: instead of generating a substring and *then* checking if it's a palindrome, we can pick a potential *center* of a palindrome and expand outwards to find all palindromes centered there.\n\nA palindrome is symmetric around its center. This center can be a single character (for odd-length palindromes like \"r-a-c-e-c-a-r\") or the space between two identical characters (for even-length palindromes like \"a-b-b-a\"). For a string of length N, there are `2N - 1` such potential centers: `N` single-character centers and `N - 1` in-between centers.\n\nWe can iterate through all `2N - 1` potential centers. For each center, we use two pointers, `left` and `right`, and expand them outwards as long as they are within the string's bounds and the characters they point to are equal. Each time they match, we've found another valid palindrome.\n\n**Example Walkthrough:** `s = \"aba\"`\n1.  **Center at `i=0` ('a'):**\n    *   **Odd Case:** `left=0`, `right=0`. `s[0]==s[0]`. Found \"a\". `count=1`. Pointers move to `left=-1`, `right=1`. Out of bounds. Stop.\n2.  **Center between `i=0` and `i=1`:**\n    *   **Even Case:** `left=0`, `right=1`. `s[0]!='b'`. No palindrome here. Stop.\n3.  **Center at `i=1` ('b'):**\n    *   **Odd Case:** `left=1`, `right=1`. `s[1]==s[1]`. Found \"b\". `count=2`. Pointers move to `left=0`, `right=2`. `s[0]==s[2]`. Found \"aba\". `count=3`. Pointers move to `left=-1`, `right=3`. Out of bounds. Stop.\n4.  **Center between `i=1` and `i=2`:**\n    *   **Even Case:** `left=1`, `right=2`. `s[1]!='a'`. No palindrome here. Stop.\n5.  **Center at `i=2` ('a'):**\n    *   **Odd Case:** `left=2`, `right=2`. `s[2]==s[2]`. Found \"a\". `count=4`. Pointers move to `left=1`, `right=3`. Out of bounds. Stop.\n\nFinal `count` is 4. The palindromes are \"a\", \"b\", \"a\", \"aba\".\n\n**Python Code:**\n```python\nclass Solution:\n    def countSubstrings(self, s: str) -> int:\n        n = len(s)\n        self.count = 0\n\n        # Helper function to perform the expansion and count palindromes\n        def expand_from_center(left, right):\n            # The core of the pattern: two pointers expand outwards\n            while left >= 0 and right < n and s[left] == s[right]:\n                # Each time the characters match, we've found a new valid palindrome.\n                self.count += 1\n                \n                # Move pointers outwards to check for a larger palindrome\n                left -= 1\n                right += 1\n\n        # Main loop to iterate through all possible centers\n        for i in range(n):\n            # Case 1: Odd-length palindromes, centered at a single character 'i'\n            # e.g., for \"racecar\", the center is 'e'\n            expand_from_center(i, i)\n            \n            # Case 2: Even-length palindromes, centered between two characters 'i' and 'i+1'\n            # e.g., for \"aabbaa\", the center is between the two 'b's\n            expand_from_center(i, i + 1)\n            \n        return self.count\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N²)**\n    We iterate through the string with a single loop of length `N`. For each index `i`, we call `expand_from_center` twice. In the worst-case scenario (e.g., a string like \"aaaaa\"), each expansion can take up to O(N) time. Therefore, the total time complexity is `N * O(N) = O(N²)`.\n\n*   **Space Complexity: O(1)**\n    This algorithm is very space-efficient. We only use a few variables (`left`, `right`, `count`, `i`) to keep track of our state, regardless of the input string's size. No auxiliary data structures are needed.\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - Expanding From Center** pattern. The defining characteristic that signals this pattern is the task of finding or counting **palindromes**.\n\nA palindrome's inherent symmetry is the key. The brute-force approach ignores this symmetry, leading to redundant work. The \"Expanding From Center\" approach leverages this property directly. By fixing a center and using two pointers (`left` and `right`) that move in opposite directions, we efficiently verify and count all palindromes associated with that center.\n\nYou should think of this pattern whenever a problem involves:\n1.  Identifying palindromic substrings.\n2.  Finding the longest palindromic substring.\n3.  Any problem structure that exhibits symmetry around a central point.\n\nThe two pointers moving away from each other is the mechanical signature of this pattern, distinguishing it from other two-pointer patterns where pointers might move towards each other or in the same direction.",
    "description": "Study Palindromic Substrings using the Pattern 6: Two Pointers - Expanding From Center (Palindromes) approach.",
    "has_content": true
  },
  {
    "id": "problem_652",
    "number": 652,
    "title": "Find Duplicate Subtrees",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 17: Tree - Serialization and Deserialization",
    "url": "https://leetcode.com/problems/find-duplicate-subtrees/",
    "difficulty": "hard",
    "content": "# Find Duplicate Subtrees\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find Duplicate Subtrees](https://leetcode.com/problems/find-duplicate-subtrees/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 17: Tree - Serialization and Deserialization",
    "description": "Study Find Duplicate Subtrees using the Pattern 17: Tree - Serialization and Deserialization approach.",
    "has_content": false
  },
  {
    "id": "problem_658",
    "number": 658,
    "title": "Find K Closest Elements",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 56: Binary Search - Find First/Last Occurrence",
    "url": "https://leetcode.com/problems/find-k-closest-elements/",
    "difficulty": "hard",
    "content": "# Find K Closest Elements\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find K Closest Elements](https://leetcode.com/problems/find-k-closest-elements/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 56: Binary Search - Find First/Last Occurrence",
    "description": "Study Find K Closest Elements using the Pattern 56: Binary Search - Find First/Last Occurrence approach.",
    "has_content": false
  },
  {
    "id": "problem_680",
    "number": 680,
    "title": "Valid Palindrome II",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 82: String - Palindrome Check (Two Pointers / Reverse)",
    "url": "https://leetcode.com/problems/valid-palindrome-ii/",
    "difficulty": "hard",
    "content": "# Valid Palindrome II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Valid Palindrome II](https://leetcode.com/problems/valid-palindrome-ii/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 82: String - Palindrome Check (Two Pointers / Reverse)",
    "description": "Study Valid Palindrome II using the Pattern 82: String - Palindrome Check (Two Pointers / Reverse) approach.",
    "has_content": false
  },
  {
    "id": "problem_684",
    "number": 684,
    "title": "Redundant Connection",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/redundant-connection/",
    "difficulty": "hard",
    "content": "# Redundant Connection\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Redundant Connection](https://leetcode.com/problems/redundant-connection/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study Redundant Connection using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_686",
    "number": 686,
    "title": "Repeated String Match",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 87: String Matching - Naive / KMP / Rabin-Karp",
    "url": "https://leetcode.com/problems/repeated-string-match/",
    "difficulty": "hard",
    "content": "# Repeated String Match\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Repeated String Match](https://leetcode.com/problems/repeated-string-match/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 87: String Matching - Naive / KMP / Rabin-Karp",
    "description": "Study Repeated String Match using the Pattern 87: String Matching - Naive / KMP / Rabin-Karp approach.",
    "has_content": false
  },
  {
    "id": "problem_695",
    "number": 695,
    "title": "Max Area of Island",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 18: Graph DFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/max-area-of-island/",
    "difficulty": "hard",
    "content": "# Max Area of Island\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Max Area of Island](https://leetcode.com/problems/max-area-of-island/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 18: Graph DFS - Connected Components / Island Counting",
    "description": "Study Max Area of Island using the Pattern 18: Graph DFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_703",
    "number": 703,
    "title": "Kth Largest Element in a Stream",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "url": "https://leetcode.com/problems/kth-largest-element-in-a-stream/",
    "difficulty": "hard",
    "content": "# Kth Largest Element in a Stream\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Kth Largest Element in a Stream](https://leetcode.com/problems/kth-largest-element-in-a-stream/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "description": "Study Kth Largest Element in a Stream using the Pattern 37: Heap - Top K Elements (Selection/Frequency) approach.",
    "has_content": false
  },
  {
    "id": "problem_704",
    "number": 704,
    "title": "Binary Search",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 53: Binary Search - On Sorted Array/List",
    "url": "https://leetcode.com/problems/binary-search/",
    "difficulty": "hard",
    "content": "# Binary Search\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Binary Search](https://leetcode.com/problems/binary-search/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 53: Binary Search - On Sorted Array/List",
    "description": "Study Binary Search using the Pattern 53: Binary Search - On Sorted Array/List approach.",
    "has_content": false
  },
  {
    "id": "problem_706",
    "number": 706,
    "title": "Design HashMap",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-hashmap/",
    "difficulty": "hard",
    "content": "# Design HashMap\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design HashMap](https://leetcode.com/problems/design-hashmap/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design HashMap using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_712",
    "number": 712,
    "title": "Minimum ASCII Delete Sum for Two Strings",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 32: DP - 2D Array (Edit Distance / Levenshtein Distance)",
    "url": "https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/",
    "difficulty": "hard",
    "content": "# Minimum ASCII Delete Sum for Two Strings\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum ASCII Delete Sum for Two Strings](https://leetcode.com/problems/minimum-ascii-delete-sum-for-two-strings/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 32: DP - 2D Array (Edit Distance / Levenshtein Distance)",
    "description": "Study Minimum ASCII Delete Sum for Two Strings using the Pattern 32: DP - 2D Array (Edit Distance / Levenshtein Distance) approach.",
    "has_content": false
  },
  {
    "id": "problem_713",
    "number": 713,
    "title": "Subarray Product Less Than K",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/subarray-product-less-than-k/",
    "difficulty": "hard",
    "content": "# Subarray Product Less Than K\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Subarray Product Less Than K](https://leetcode.com/problems/subarray-product-less-than-k/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Subarray Product Less Than K using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_715",
    "number": 715,
    "title": "Range Module",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/range-module/",
    "difficulty": "hard",
    "content": "# Range Module\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Range Module](https://leetcode.com/problems/range-module/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Range Module using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_721",
    "number": 721,
    "title": "Accounts Merge",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/accounts-merge/",
    "difficulty": "hard",
    "content": "# Accounts Merge\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Accounts Merge](https://leetcode.com/problems/accounts-merge/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study Accounts Merge using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_733",
    "number": 733,
    "title": "Flood Fill",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 18: Graph DFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/flood-fill/",
    "difficulty": "hard",
    "content": "# Flood Fill\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Flood Fill](https://leetcode.com/problems/flood-fill/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 18: Graph DFS - Connected Components / Island Counting",
    "description": "Study Flood Fill using the Pattern 18: Graph DFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_735",
    "number": 735,
    "title": "Asteroid Collision",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 61: Stack - Simulation / Backtracking Helper",
    "url": "https://leetcode.com/problems/asteroid-collision/",
    "difficulty": "hard",
    "content": "# Asteroid Collision\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Asteroid Collision](https://leetcode.com/problems/asteroid-collision/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 61: Stack - Simulation / Backtracking Helper",
    "description": "Study Asteroid Collision using the Pattern 61: Stack - Simulation / Backtracking Helper approach.",
    "has_content": false
  },
  {
    "id": "problem_737",
    "number": 737,
    "title": "Sentence Similarity II",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/sentence-similarity-ii/",
    "difficulty": "hard",
    "content": "# Sentence Similarity II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Sentence Similarity II](https://leetcode.com/problems/sentence-similarity-ii/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study Sentence Similarity II using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_739",
    "number": 739,
    "title": "Daily Temperatures",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 59: Stack - Monotonic Stack",
    "url": "https://leetcode.com/problems/daily-temperatures/",
    "difficulty": "hard",
    "content": "# Daily Temperatures\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Daily Temperatures](https://leetcode.com/problems/daily-temperatures/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 59: Stack - Monotonic Stack",
    "description": "Study Daily Temperatures using the Pattern 59: Stack - Monotonic Stack approach.",
    "has_content": false
  },
  {
    "id": "problem_740",
    "number": 740,
    "title": "Delete and Earn",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 26: DP - 1D Array (Fibonacci Style)",
    "url": "https://leetcode.com/problems/delete-and-earn/",
    "difficulty": "hard",
    "content": "# Delete and Earn\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Delete and Earn](https://leetcode.com/problems/delete-and-earn/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 26: DP - 1D Array (Fibonacci Style)",
    "description": "Study Delete and Earn using the Pattern 26: DP - 1D Array (Fibonacci Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_743",
    "number": 743,
    "title": "Network Delay Time",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 24: Graph - Shortest Path (Bellman-Ford / BFS+K)",
    "url": "https://leetcode.com/problems/network-delay-time/",
    "difficulty": "hard",
    "content": "# Network Delay Time\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Network Delay Time](https://leetcode.com/problems/network-delay-time/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 24: Graph - Shortest Path (Bellman-Ford / BFS+K)",
    "description": "Study Network Delay Time using the Pattern 24: Graph - Shortest Path (Bellman-Ford / BFS+K) approach.",
    "has_content": false
  },
  {
    "id": "problem_746",
    "number": 746,
    "title": "Min Cost Climbing Stairs",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 26: DP - 1D Array (Fibonacci Style)",
    "url": "https://leetcode.com/problems/min-cost-climbing-stairs/",
    "difficulty": "hard",
    "content": "# Min Cost Climbing Stairs\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Min Cost Climbing Stairs](https://leetcode.com/problems/min-cost-climbing-stairs/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 26: DP - 1D Array (Fibonacci Style)",
    "description": "Study Min Cost Climbing Stairs using the Pattern 26: DP - 1D Array (Fibonacci Style) approach.",
    "has_content": false
  },
  {
    "id": "problem_759",
    "number": 759,
    "title": "Employee Free Time",
    "category": "VIII. Greedy Patterns",
    "pattern": "Pattern 48: Greedy - Interval Merging/Scheduling",
    "url": "https://leetcode.com/problems/employee-free-time/",
    "difficulty": "hard",
    "content": "# Employee Free Time\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Employee Free Time](https://leetcode.com/problems/employee-free-time/)\n\n**Category:** VIII. Greedy Patterns\n**Pattern:** Pattern 48: Greedy - Interval Merging/Scheduling",
    "description": "Study Employee Free Time using the Pattern 48: Greedy - Interval Merging/Scheduling approach.",
    "has_content": false
  },
  {
    "id": "problem_767",
    "number": 767,
    "title": "Reorganize String",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "url": "https://leetcode.com/problems/reorganize-string/",
    "difficulty": "hard",
    "content": "# Reorganize String\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Reorganize String](https://leetcode.com/problems/reorganize-string/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "description": "Study Reorganize String using the Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue) approach.",
    "has_content": false
  },
  {
    "id": "problem_772",
    "number": 772,
    "title": "Basic Calculator III",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 60: Stack - Expression Evaluation (RPN/Infix)",
    "url": "https://leetcode.com/problems/basic-calculator-iii/",
    "difficulty": "hard",
    "content": "# Basic Calculator III\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Basic Calculator III](https://leetcode.com/problems/basic-calculator-iii/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 60: Stack - Expression Evaluation (RPN/Infix)",
    "description": "Study Basic Calculator III using the Pattern 60: Stack - Expression Evaluation (RPN/Infix) approach.",
    "has_content": false
  },
  {
    "id": "problem_774",
    "number": 774,
    "title": "Minimize Max Distance to Gas Station",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 55: Binary Search - On Answer / Condition Function",
    "url": "https://leetcode.com/problems/minimize-max-distance-to-gas-station/",
    "difficulty": "hard",
    "content": "# Minimize Max Distance to Gas Station\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimize Max Distance to Gas Station](https://leetcode.com/problems/minimize-max-distance-to-gas-station/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 55: Binary Search - On Answer / Condition Function",
    "description": "Study Minimize Max Distance to Gas Station using the Pattern 55: Binary Search - On Answer / Condition Function approach.",
    "has_content": false
  },
  {
    "id": "problem_778",
    "number": 778,
    "title": "Swim in Rising Water",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "url": "https://leetcode.com/problems/swim-in-rising-water/",
    "difficulty": "hard",
    "content": "# Swim in Rising Water\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Swim in Rising Water](https://leetcode.com/problems/swim-in-rising-water/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "description": "Study Swim in Rising Water using the Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_787",
    "number": 787,
    "title": "Cheapest Flights Within K Stops",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 24: Graph - Shortest Path (Bellman-Ford / BFS+K)",
    "url": "https://leetcode.com/problems/cheapest-flights-within-k-stops/",
    "difficulty": "hard",
    "content": "# Cheapest Flights Within K Stops\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Cheapest Flights Within K Stops](https://leetcode.com/problems/cheapest-flights-within-k-stops/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 24: Graph - Shortest Path (Bellman-Ford / BFS+K)",
    "description": "Study Cheapest Flights Within K Stops using the Pattern 24: Graph - Shortest Path (Bellman-Ford / BFS+K) approach.",
    "has_content": false
  },
  {
    "id": "problem_796",
    "number": 796,
    "title": "Rotate String",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 87: String Matching - Naive / KMP / Rabin-Karp",
    "url": "https://leetcode.com/problems/rotate-string/",
    "difficulty": "hard",
    "content": "# Rotate String\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Rotate String](https://leetcode.com/problems/rotate-string/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 87: String Matching - Naive / KMP / Rabin-Karp",
    "description": "Study Rotate String using the Pattern 87: String Matching - Naive / KMP / Rabin-Karp approach.",
    "has_content": false
  },
  {
    "id": "problem_802",
    "number": 802,
    "title": "Find Eventual Safe States",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 20: Graph DFS - Cycle Detection (Directed Graph)",
    "url": "https://leetcode.com/problems/find-eventual-safe-states/",
    "difficulty": "hard",
    "content": "# Find Eventual Safe States\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find Eventual Safe States](https://leetcode.com/problems/find-eventual-safe-states/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 20: Graph DFS - Cycle Detection (Directed Graph)",
    "description": "Study Find Eventual Safe States using the Pattern 20: Graph DFS - Cycle Detection (Directed Graph) approach.",
    "has_content": false
  },
  {
    "id": "problem_841",
    "number": 841,
    "title": "Keys and Rooms",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 18: Graph DFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/keys-and-rooms/",
    "difficulty": "hard",
    "content": "# Keys and Rooms\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Keys and Rooms](https://leetcode.com/problems/keys-and-rooms/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 18: Graph DFS - Connected Components / Island Counting",
    "description": "Study Keys and Rooms using the Pattern 18: Graph DFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_844",
    "number": 844,
    "title": "Backspace String Compare",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 5: Two Pointers - String Comparison",
    "url": "https://leetcode.com/problems/backspace-string-compare/",
    "difficulty": "hard",
    "content": "---\n### **844. Backspace String Compare**\n**Link to Problem:** [https://leetcode.com/problems/backspace-string-compare/](https://leetcode.com/problems/backspace-string-compare/)\n\n#### **1. Problem Statement**\nGiven two strings, `s` and `t`, we need to determine if they are equal when typed into an empty text editor. The character `'#'` represents a backspace, which deletes the preceding character. The goal is to return `true` if the final resulting strings are identical, and `false` otherwise.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to simulate the typing process for each string. We can build the final, \"processed\" version of each string by iterating through them and handling the backspace characters as we encounter them. A stack (or a simple list in Python) is a perfect data structure for this simulation. For each character, if it's a regular letter, we push it onto the stack. If it's a backspace (`#`), we pop the last character from the stack. After processing both strings, we can simply compare the two final resulting strings.\n\n**Python Code:**\n```python\ndef backspaceCompare_brute_force(s: str, t: str) -> bool:\n    \"\"\"\n    Compares two strings after applying backspace operations by building\n    the final strings first.\n    \"\"\"\n\n    def build_string(input_str: str) -> str:\n        \"\"\"Helper function to process a string and return the final result.\"\"\"\n        # Use a list as a stack to build the final string.\n        stack = []\n        for char in input_str:\n            if char != '#':\n                # If it's a normal character, add it to our result.\n                stack.append(char)\n            elif stack:\n                # If it's a backspace and the stack is not empty,\n                # pop the last character.\n                stack.pop()\n        \n        # Join the characters in the stack to form the final string.\n        return \"\".join(stack)\n\n    # Build the final versions of both s and t.\n    final_s = build_string(s)\n    final_t = build_string(t)\n\n    # Return true if the final strings are identical.\n    return final_s == final_t\n\n# Example usage:\ns = \"ab#c\"\nt = \"ad#c\"\nprint(f\"Brute Force Result for s='{s}', t='{t}': {backspaceCompare_brute_force(s, t)}\") # Output: True\n\ns = \"a##c\"\nt = \"#a#c\"\nprint(f\"Brute Force Result for s='{s}', t='{t}': {backspaceCompare_brute_force(s, t)}\") # Output: True\n\ns = \"a#c\"\nt = \"b\"\nprint(f\"Brute Force Result for s='{s}', t='{t}': {backspaceCompare_brute_force(s, t)}\") # Output: False\n```\n\n**Complexity Analysis:**\n\n*   **Time Complexity:** O(M + N), where M and N are the lengths of strings `s` and `t`, respectively. We iterate through each string once to build the final versions.\n*   **Space Complexity:** O(M + N). In the worst-case scenario (strings with no backspaces), the stacks will grow to the size of the original strings, requiring extra space proportional to their lengths.\n\n### **3. Optimized Approach: Two Pointers - String Comparison**\n**Intuition:**\nThe brute-force approach is perfectly valid, but it uses extra space to build new strings. We can optimize this to an O(1) space solution using the **Two Pointers** pattern.\n\nThe key insight is to compare the strings from right to left. When we iterate backward, a backspace character tells us to *skip* the next valid character we encounter. This is easier to manage than iterating forward, where a backspace modifies a character we have already processed.\n\nWe'll set up two pointers, `p1` and `p2`, at the ends of strings `s` and `t`, respectively. We then move them backward, finding the next valid character in each string (i.e., a character that isn't deleted by a backspace). Once we find a valid character from each string, we compare them. If they don't match, the strings are not equal. We continue this process until one or both pointers go past the beginning of their string.\n\n**Example Walkthrough:** `s = \"ab#c\"`, `t = \"ad#c\"`\n1.  Initialize `p1 = 3` (pointing to `c` in `s`) and `p2 = 3` (pointing to `c` in `t`).\n2.  **Comparison 1:**\n    *   `s[p1]` is 'c'. It's a valid character.\n    *   `t[p2]` is 'c'. It's a valid character.\n    *   'c' == 'c'. They match. Decrement pointers: `p1 = 2`, `p2 = 2`.\n3.  **Comparison 2:**\n    *   **Process `s`:** `s[p1]` is '#'. We see one backspace (`skip_s = 1`). Decrement `p1` to 1. Now `s[p1]` is 'b'. Since `skip_s > 0`, we skip 'b' and decrement `skip_s` to 0. Decrement `p1` to 0. The next valid character in `s` is 'a' at index 0.\n    *   **Process `t`:** `t[p2]` is '#'. We see one backspace (`skip_t = 1`). Decrement `p2` to 1. Now `t[p2]` is 'd'. Since `skip_t > 0`, we skip 'd' and decrement `skip_t` to 0. Decrement `p2` to 0. The next valid character in `t` is 'a' at index 0.\n    *   **Compare:** The valid characters are `s[0]` ('a') and `t[0]` ('a'). They match. Decrement pointers: `p1 = -1`, `p2 = -1`.\n4.  Both pointers are now out of bounds (`< 0`). The loop terminates. Since we never found a mismatch, we return `True`.\n\n**Python Code:**\n```python\ndef backspaceCompare(s: str, t: str) -> bool:\n    \"\"\"\n    Compares two strings after applying backspace operations using a\n    two-pointer approach for O(1) space complexity.\n    \"\"\"\n    # Initialize pointers to the end of the strings.\n    p1 = len(s) - 1\n    p2 = len(t) - 1\n\n    # Loop as long as there are characters to process in either string.\n    while p1 >= 0 or p2 >= 0:\n        # Find the next valid character in string 's'.\n        skip_s = 0\n        while p1 >= 0:\n            if s[p1] == '#':\n                skip_s += 1\n                p1 -= 1 # Move pointer left\n            elif skip_s > 0:\n                skip_s -= 1 # Use up a skip for this character\n                p1 -= 1 # Move pointer left\n            else:\n                # Found a valid character that is not skipped.\n                break\n        \n        # Find the next valid character in string 't'.\n        skip_t = 0\n        while p2 >= 0:\n            if t[p2] == '#':\n                skip_t += 1\n                p2 -= 1 # Move pointer left\n            elif skip_t > 0:\n                skip_t -= 1 # Use up a skip for this character\n                p2 -= 1 # Move pointer left\n            else:\n                # Found a valid character that is not skipped.\n                break\n\n        # Now, compare the valid characters.\n        \n        # Case 1: Both pointers found a valid character.\n        if p1 >= 0 and p2 >= 0:\n            if s[p1] != t[p2]:\n                return False  # Mismatch found.\n        # Case 2: One string has remaining characters, the other does not.\n        elif p1 >= 0 or p2 >= 0:\n            return False # Unequal lengths after backspaces.\n        \n        # Move pointers inward to continue the comparison.\n        p1 -= 1\n        p2 -= 1\n\n    # If the loop completes without returning False, the strings are equal.\n    return True\n\n# Example usage:\ns = \"ab#c\"\nt = \"ad#c\"\nprint(f\"Optimized Result for s='{s}', t='{t}': {backspaceCompare(s, t)}\") # Output: True\n\ns = \"a##c\"\nt = \"#a#c\"\nprint(f\"Optimized Result for s='{s}', t='{t}': {backspaceCompare(s, t)}\") # Output: True\n\ns = \"a#c\"\nt = \"b\"\nprint(f\"Optimized Result for s='{s}', t='{t}': {backspaceCompare(s, t)}\") # Output: False\n```\n\n**Complexity Analysis:**\n\n*   **Time Complexity:** O(M + N). Although we have nested `while` loops, each pointer (`p1` and `p2`) only traverses its respective string once from right to left. The total number of operations is proportional to the sum of the lengths of the strings.\n*   **Space Complexity:** O(1). We only use a few variables (`p1`, `p2`, `skip_s`, `skip_t`) to keep track of our position and the number of backspaces. We do not create any new data structures, achieving a constant space solution.\n\n### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - String Comparison** pattern. The core task is to check for equivalence between two sequences, but with a twist that makes a direct, linear scan difficult.\n\nThe key signal for this pattern is the need to compare two distinct sequences (here, strings `s` and `t`) without allocating extra memory. The backspace character introduces a dependency on future characters (when reading left-to-right) or past characters (when reading right-to-left). By placing pointers at the end of the strings and moving them backward, we transform the problem. A backspace becomes a simple instruction to \"skip\" a certain number of characters we are about to see. This allows for an in-place comparison, perfectly embodying the efficiency goal of the two-pointer technique: process sequences with minimal space by intelligently coordinating pointers. Whenever a comparison problem involves transformations or non-local dependencies (like a backspace affecting a previous character), consider a two-pointer approach from a non-standard direction (e.g., right-to-left).",
    "description": "Study Backspace String Compare using the Pattern 5: Two Pointers - String Comparison approach.",
    "has_content": true
  },
  {
    "id": "problem_852",
    "number": 852,
    "title": "Peak Index in a Mountain Array",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "url": "https://leetcode.com/problems/peak-index-in-a-mountain-array/",
    "difficulty": "hard",
    "content": "# Peak Index in a Mountain Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Peak Index in a Mountain Array](https://leetcode.com/problems/peak-index-in-a-mountain-array/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "description": "Study Peak Index in a Mountain Array using the Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array approach.",
    "has_content": false
  },
  {
    "id": "problem_857",
    "number": 857,
    "title": "Minimum Cost to Hire K Workers",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "url": "https://leetcode.com/problems/minimum-cost-to-hire-k-workers/",
    "difficulty": "hard",
    "content": "# Minimum Cost to Hire K Workers\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Cost to Hire K Workers](https://leetcode.com/problems/minimum-cost-to-hire-k-workers/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "description": "Study Minimum Cost to Hire K Workers using the Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue) approach.",
    "has_content": false
  },
  {
    "id": "problem_862",
    "number": 862,
    "title": "Shortest Subarray with Sum at Least K",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 10: Sliding Window - Monotonic Queue for Max/Min",
    "url": "https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/",
    "difficulty": "hard",
    "content": "# Shortest Subarray with Sum at Least K\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Shortest Subarray with Sum at Least K](https://leetcode.com/problems/shortest-subarray-with-sum-at-least-k/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 10: Sliding Window - Monotonic Queue for Max/Min",
    "description": "Study Shortest Subarray with Sum at Least K using the Pattern 10: Sliding Window - Monotonic Queue for Max/Min approach.",
    "has_content": false
  },
  {
    "id": "problem_863",
    "number": 863,
    "title": "All Nodes Distance K in Binary Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "url": "https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/",
    "difficulty": "hard",
    "content": "# All Nodes Distance K in Binary Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "description": "Study All Nodes Distance K in Binary Tree using the Pattern 15: Tree DFS - Recursive Postorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_875",
    "number": 875,
    "title": "Koko Eating Bananas",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 55: Binary Search - On Answer / Condition Function",
    "url": "https://leetcode.com/problems/koko-eating-bananas/",
    "difficulty": "hard",
    "content": "# Koko Eating Bananas\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Koko Eating Bananas](https://leetcode.com/problems/koko-eating-bananas/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 55: Binary Search - On Answer / Condition Function",
    "description": "Study Koko Eating Bananas using the Pattern 55: Binary Search - On Answer / Condition Function approach.",
    "has_content": false
  },
  {
    "id": "problem_876",
    "number": 876,
    "title": "Middle of the Linked List",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 3: Two Pointers - Fixed Separation (Nth Node from End)",
    "url": "https://leetcode.com/problems/middle-of-the-linked-list/",
    "difficulty": "hard",
    "content": "---\n### **876. Middle of the Linked List**\n**Link to Problem:** [https://leetcode.com/problems/middle-of-the-linked-list/](https://leetcode.com/problems/middle-of-the-linked-list/)\n\n#### **1. Problem Statement**\nGiven the `head` of a singly linked list, the task is to find and return the middle node of that list. If the list contains an even number of nodes, there will be two middle nodes; in this case, the second middle node should be returned.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to find the middle of something is to first know its total size. The brute-force approach follows this logic directly. We can solve this in two distinct passes over the linked list:\n1.  **First Pass (Count):** Traverse the entire list from the `head` to the end, counting the total number of nodes (`N`).\n2.  **Second Pass (Find):** Calculate the index of the middle node, which is `N // 2`. Then, start another traversal from the `head` and stop after `N // 2` steps. The node at this position is our answer.\n\n**Python Code:**\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # --- First Pass: Count the total number of nodes ---\n        count = 0\n        current = head\n        # Traverse the list to its end to get the total count.\n        while current:\n            count += 1\n            current = current.next\n\n        # --- Second Pass: Traverse to the middle node ---\n        # Calculate the index of the middle node.\n        # For a list of 5 nodes (0,1,2,3,4), middle is 5//2 = 2.\n        # For a list of 6 nodes (0,1,2,3,4,5), middle is 6//2 = 3 (the second middle node).\n        middle_index = count // 2\n        \n        # Reset the pointer to the beginning of the list for the second pass.\n        current = head\n        # Traverse half the list to reach the designated middle node.\n        for _ in range(middle_index):\n            current = current.next\n            \n        return current\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    We traverse the list twice. The first pass takes N steps to count the nodes. The second pass takes N/2 steps to reach the middle. The total time is O(N + N/2), which simplifies to O(N).\n\n*   **Space Complexity: O(1)**\n    We only use a few variables (`count`, `current`, `middle_index`) for storage, which does not depend on the size of the linked list.\n\n#### **3. Optimized Approach: Two Pointers - Fixed Separation (Nth Node from End)**\n**Intuition:**\nThe two-pass brute force approach is inefficient. We can find the middle node in a single pass using the **Fast and Slow Pointer** technique, a classic variation of the Two Pointer pattern.\n\nThe idea is to have two pointers, `slow` and `fast`, both starting at the `head`. In each iteration, the `slow` pointer advances by one step, while the `fast` pointer advances by two steps. Because the `fast` pointer moves at double the speed, by the time it reaches the end of the list, the `slow` pointer will have traveled exactly half the distance. This positions the `slow` pointer perfectly at the middle node.\n\nLet's walk through an example: `1 -> 2 -> 3 -> 4 -> 5`\n- **Initial:** `slow` is at 1, `fast` is at 1.\n- **Step 1:** `slow` moves to 2. `fast` moves to 3.\n- **Step 2:** `slow` moves to 3. `fast` moves to 5.\n- **End:** `fast.next` is now `null`, so the loop terminates. The `slow` pointer is at node 3, which is the middle.\n\nThis works for even-length lists as well, correctly identifying the second middle node as required.\n\n**Python Code:**\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def middleNode(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Initialize two pointers, both starting at the head of the list.\n        slow = head\n        fast = head\n        \n        # The core of the fast/slow pointer pattern.\n        # We must check for 'fast' and 'fast.next' to safely advance the fast pointer by two.\n        # This condition naturally handles both odd and even length lists.\n        while fast and fast.next:\n            # Slow pointer moves one step at a time.\n            slow = slow.next\n            # Fast pointer moves two steps at a time.\n            fast = fast.next.next\n            \n        # When the loop ends, the fast pointer has reached the end,\n        # and the slow pointer is now at the middle.\n        return slow\n```\n\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    Although we use two pointers, we only traverse the list once. The `fast` pointer reaches the end in N/2 steps, making the overall time complexity linear to the number of nodes. This is significantly faster in practice than the O(1.5N) of the brute-force method.\n\n*   **Space Complexity: O(1)**\n    We only need memory for the two pointers (`slow` and `fast`), resulting in constant space usage.\n\n#### **4. Pattern Connection**\nThis problem is the quintessential example of the **Fast and Slow Pointer** technique, which is a powerful variant of the broader Two Pointers pattern.\n\nThe key signal for this pattern is when you need to find a node based on its **relative position** within a sequence (like the middle, the Nth from the end, or the start of a cycle) without first knowing the sequence's total length. A single pointer can only tell you about its immediate location. However, by introducing a second pointer and controlling the *relative speed* between the two, you can deduce positional information about the entire structure in a single pass. In this case, by setting one pointer's speed to be double the other's, we guarantee that when the `fast` pointer finishes, the `slow` pointer is at the halfway mark. This elegant single-pass solution is far more efficient than the naive two-pass approach and perfectly showcases the power of using two pointers in tandem.",
    "description": "Study Middle of the Linked List using the Pattern 3: Two Pointers - Fixed Separation (Nth Node from End) approach.",
    "has_content": true
  },
  {
    "id": "problem_881",
    "number": 881,
    "title": "Boats to Save People",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)",
    "url": "https://leetcode.com/problems/boats-to-save-people/",
    "difficulty": "hard",
    "content": "---\n### **881. Boats to Save People**\n**Link to Problem:** [https://leetcode.com/problems/boats-to-save-people/](https://leetcode.com/problems/boats-to-save-people/)\n\n#### **1. Problem Statement**\nYou are given an array `people` where `people[i]` is the weight of the i-th person, and a `limit` which is the maximum weight a boat can carry. Each boat can carry at most two people, provided their combined weight is not over the limit. The goal is to return the minimum number of boats required to save everyone.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nA straightforward but inefficient approach is to try and pair people up. We can sort the people by weight first, which usually simplifies problems involving combinations. A greedy idea is to take the heaviest person remaining and see if we can pair them with the heaviest possible partner who fits in the boat.\n\nThe logic would be:\n1. Sort the `people` array in ascending order.\n2. Create a boolean array `used` to keep track of who has been placed in a boat.\n3. Iterate from the heaviest person down to the lightest (`i` from `n-1` to `0`).\n4. If the current person `i` hasn't been used yet, they must take a new boat. Increment the boat count. Mark them as used.\n5. Now, try to find a partner for them. Iterate from `i-1` down to `0` (`j`). Find the first (and therefore heaviest) unused person `j` such that `people[i] + people[j] <= limit`.\n6. If a partner is found, mark them as used and break the inner loop to continue with the next heaviest person.\n\nThis approach is slow because for each person, we might have to scan a large portion of the array again to find a suitable partner.\n\n**Python Code:**\n```python\ndef numRescueBoats_brute_force(people: list[int], limit: int) -> int:\n    # 1. Sorting helps in applying a greedy strategy.\n    people.sort()\n    n = len(people)\n    \n    # 2. 'used' array to track who has been assigned a boat.\n    used = [False] * n\n    boats = 0\n    \n    # 3. Iterate from the heaviest person to the lightest.\n    for i in range(n - 1, -1, -1):\n        # If this person is already in a boat with someone heavier, skip.\n        if used[i]:\n            continue\n        \n        # This person needs a boat.\n        boats += 1\n        used[i] = True\n        \n        # 4. Try to find the heaviest possible partner for this person.\n        partner_found = False\n        for j in range(i - 1, -1, -1):\n            if not used[j] and people[i] + people[j] <= limit:\n                # Found a partner, put them in the same boat.\n                used[j] = True\n                partner_found = True\n                break # A boat can hold at most two people.\n                \n    return boats\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(N^2)`. The initial sort takes `O(N log N)`. However, the nested loops dominate. The outer loop runs `N` times, and the inner loop can also run up to `N` times in the worst case, leading to an `O(N^2)` complexity.\n*   **Space Complexity:** `O(N)`. We use an additional boolean array `used` of size `N` to store the status of each person.\n\n---\n\n### **3. Optimized Approach: Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)**\n**Intuition:**\nThe brute-force approach is slow because of the nested search for a partner. We can optimize this by realizing a crucial greedy insight:\n\n**The heaviest person is the most difficult to pair up.** They have the least amount of \"weight capacity\" remaining in their boat. If anyone can be paired with the heaviest person, it must be the lightest person.\n\nThis insight leads directly to the **Two Pointers - Converging** pattern:\n1.  **Sort the array.** This allows us to easily access the lightest and heaviest people.\n2.  Initialize two pointers: `left` at the start of the array (lightest person) and `right` at the end (heaviest person).\n3.  In each step, we decide the fate of the heaviest person (`people[right]`). They *must* get on a boat. The only question is whether they go alone or with a partner.\n4.  We check if the lightest person (`people[left]`) can fit in the boat with the heaviest person (`people[right]`).\n    *   If `people[left] + people[right] <= limit`, they can share a boat. We count this boat and move both pointers inward (`left++`, `right--`).\n    *   If `people[left] + people[right] > limit`, the lightest person is still too heavy to be paired with the heaviest. This implies *no one* can be paired with the heaviest person (since everyone else is heavier than `people[left]`). Therefore, the heaviest person must take a boat alone. We count this boat and move only the `right` pointer inward (`right--`).\n5.  We repeat this process until the pointers cross (`left > right`), at which point everyone has been assigned a boat.\n\n**Example Walkthrough:** `people = [3, 5, 3, 4]`, `limit = 5`\n1.  **Sort:** `people` becomes `[3, 3, 4, 5]`.\n2.  **Initialize:** `left = 0`, `right = 3`, `boats = 0`.\n3.  **Loop 1:**\n    *   Pointers: `left` at `3`, `right` at `5`.\n    *   Check: `3 + 5 = 8`, which is `> limit`.\n    *   Decision: The heaviest person (5) must go alone.\n    *   Update: `boats = 1`, `right` moves to `2`. Pointers are now at `left=0`, `right=2`.\n4.  **Loop 2:**\n    *   Pointers: `left` at `3`, `right` at `4`.\n    *   Check: `3 + 4 = 7`, which is `> limit`.\n    *   Decision: The heaviest remaining person (4) must go alone.\n    *   Update: `boats = 2`, `right` moves to `1`. Pointers are now at `left=0`, `right=1`.\n5.  **Loop 3:**\n    *   Pointers: `left` at `3`, `right` at `3`.\n    *   Check: `3 + 3 = 6`, which is `> limit`.\n    *   Decision: The heaviest remaining person (the second 3) must go alone.\n    *   Update: `boats = 3`, `right` moves to `0`. Pointers are now at `left=0`, `right=0`.\n6.  **Loop 4:**\n    *   Pointers: `left = 0`, `right = 0`. They point to the same person (the first 3).\n    *   The loop condition `left <= right` is true.\n    *   This last person needs a boat.\n    *   Update: `boats = 4`, `right` moves to `-1`.\n7.  The loop terminates as `left > right`. Final answer: 4 boats.\n\n**Python Code:**\n```python\ndef numRescueBoats(people: list[int], limit: int) -> int:\n    # The initial sort is the key prerequisite for the two-pointer approach.\n    people.sort()\n    \n    # Initialize pointers at the two ends of the sorted array.\n    left = 0\n    right = len(people) - 1\n    boats = 0\n    \n    # Pointers will converge towards the middle.\n    while left <= right:\n        # Each iteration accounts for one boat, carrying the heaviest person.\n        boats += 1\n        \n        # Check if the lightest person can share the boat with the heaviest.\n        if people[left] + people[right] <= limit:\n            # If they fit, the lightest person is also on this boat.\n            # Move the left pointer inward as this person is now saved.\n            left += 1\n        \n        # The heaviest person is always on the boat in this iteration,\n        # so we always move the right pointer inward.\n        right -= 1\n        \n    return boats\n```\n\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(N log N)`. The dominant operation is the initial sorting of the `people` array. The `while` loop runs in `O(N)` time because the `left` and `right` pointers will collectively scan the entire array exactly once.\n*   **Space Complexity:** `O(1)` or `O(log N)` to `O(N)`. The space used by the algorithm itself is constant (`left`, `right`, `boats`). However, the space complexity of the sort function in most standard libraries (like Python's Timsort) can range from `O(log N)` to `O(N)`, which should be noted.\n\n---\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - Converging** pattern. The signals that point to this pattern are:\n\n1.  **A Sorted Array is Beneficial:** The problem becomes much easier to reason about when the input is sorted. This allows for greedy decisions, as we can instantly access the lightest and heaviest remaining elements.\n2.  **Decisions from the Extremes:** The optimal solution involves making decisions by pairing or comparing elements from the opposite ends of the sorted array (the lightest and the heaviest).\n3.  **Converging Pointers:** The problem is solved by maintaining a `left` and `right` pointer that start at the ends and move towards each other, shrinking the problem space with each step until they meet or cross.\n4.  **Target Condition:** The core logic `people[left] + people[right] <= limit` is a variation of the \"Target Sum\" sub-pattern. Instead of looking for an exact sum, we are checking if the sum falls within a certain condition (less than or equal to `limit`), which is a common task for this pattern.\n\nBy recognizing that the optimal pairing strategy involves the two extremes (heaviest and lightest), you can quickly identify that a two-pointer approach will be far more efficient than any brute-force method involving nested loops.",
    "description": "Study Boats to Save People using the Pattern 1: Two Pointers - Converging (Sorted Array Target Sum) approach.",
    "has_content": true
  },
  {
    "id": "problem_885",
    "number": 885,
    "title": "Spiral Matrix III",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 75: Array/Matrix - Spiral Traversal",
    "url": "https://leetcode.com/problems/spiral-matrix-iii/",
    "difficulty": "hard",
    "content": "# Spiral Matrix III\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Spiral Matrix III](https://leetcode.com/problems/spiral-matrix-iii/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 75: Array/Matrix - Spiral Traversal",
    "description": "Study Spiral Matrix III using the Pattern 75: Array/Matrix - Spiral Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_900",
    "number": 900,
    "title": "RLE Iterator",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/rle-iterator/",
    "difficulty": "hard",
    "content": "# RLE Iterator\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [RLE Iterator](https://leetcode.com/problems/rle-iterator/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study RLE Iterator using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_901",
    "number": 901,
    "title": "Online Stock Span",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 59: Stack - Monotonic Stack",
    "url": "https://leetcode.com/problems/online-stock-span/",
    "difficulty": "hard",
    "content": "# Online Stock Span\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Online Stock Span](https://leetcode.com/problems/online-stock-span/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 59: Stack - Monotonic Stack",
    "description": "Study Online Stock Span using the Pattern 59: Stack - Monotonic Stack approach.",
    "has_content": false
  },
  {
    "id": "problem_904",
    "number": 904,
    "title": "Fruit Into Baskets",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/fruit-into-baskets/",
    "difficulty": "hard",
    "content": "# Fruit Into Baskets\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Fruit Into Baskets](https://leetcode.com/problems/fruit-into-baskets/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Fruit Into Baskets using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_905",
    "number": 905,
    "title": "Sort Array By Parity",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 4: Two Pointers - In-place Array Modification",
    "url": "https://leetcode.com/problems/sort-array-by-parity/",
    "difficulty": "hard",
    "content": "---\n### **905. Sort Array By Parity**\n**Link to Problem:** [https://leetcode.com/problems/sort-array-by-parity/](https://leetcode.com/problems/sort-array-by-parity/)\n\n#### **1. Problem Statement**\nGiven an integer array `nums`, the task is to rearrange its elements such that all the even integers appear at the beginning of the array, followed by all the odd integers. The relative order of the elements within the even and odd groups does not need to be preserved.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward idea is to create a new array to store the result. We can iterate through the original input array and, for each number, decide where it should go in our new array. A simple way to achieve this is to make two passes over the input: first, we iterate and collect all the even numbers, and second, we iterate again and collect all the odd numbers. This guarantees the desired partitioning.\n\n**Python Code:**\n```python\nfrom typing import List\n\nclass Solution:\n    def sortArrayByParity_brute_force(self, nums: List[int]) -> List[int]:\n        # Create a new list to store the sorted result.\n        # This approach requires extra memory proportional to the input size.\n        result = []\n\n        # First pass: Iterate through the input array to find and add all even numbers.\n        for num in nums:\n            if num % 2 == 0:\n                result.append(num)\n\n        # Second pass: Iterate through the input array again to find and add all odd numbers.\n        for num in nums:\n            if num % 2 != 0:\n                result.append(num)\n        \n        return result\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    We iterate through the entire input array `nums` twice. The total number of operations is proportional to `N + N`, which simplifies to O(N), where N is the number of elements in the array.\n\n*   **Space Complexity: O(N)**\n    The main drawback of this approach is its space usage. We create a `result` array that is the same size as the input array `nums`, leading to a space complexity of O(N).\n\n### **3. Optimized Approach: [Pattern 4: Two Pointers - In-place Array Modification]**\n**Intuition:**\nTo improve upon the brute force solution, we need to eliminate the O(N) space complexity. This means we must perform the sort **in-place**, modifying the input array directly. The **Two Pointers** pattern is perfect for this kind of in-place rearrangement.\n\nWe can think of the array as having two sections we want to build: an \"even\" section at the beginning and an \"odd\" section at the end. We'll use two pointers to manage these sections:\n1.  `left` pointer starts at the beginning of the array (index 0).\n2.  `right` pointer starts at the end of the array (index `len(nums) - 1`).\n\nThe `left` pointer's job is to find the first *odd* number from the left, and the `right` pointer's job is to find the first *even* number from the right. When they both find their target, it means we have an odd number in the \"even\" section and an even number in the \"odd\" section. This is a mismatch, so we swap them. After the swap, both numbers are in their correct partitions. We then continue moving the pointers inward until they cross.\n\nLet's walk through an example: `nums = [3, 1, 2, 4]`\n*   **Initial:** `left = 0`, `right = 3`. `nums` is `[3, 1, 2, 4]`.\n*   **Step 1:** `nums[left]` (3) is odd and `nums[right]` (4) is even. This is the exact mismatch we are looking for!\n    *   Swap `nums[left]` and `nums[right]`. The array becomes `[4, 1, 2, 3]`.\n    *   Move both pointers inward: `left` becomes 1, `right` becomes 2.\n*   **Step 2:** `left = 1`, `right = 2`. `nums` is `[4, 1, 2, 3]`.\n    *   `nums[left]` (1) is odd and `nums[right]` (2) is even. Another mismatch!\n    *   Swap `nums[left]` and `nums[right]`. The array becomes `[4, 2, 1, 3]`.\n    *   Move both pointers inward: `left` becomes 2, `right` becomes 1.\n*   **Step 3:** Now `left` (2) is greater than `right` (1). The loop condition `left < right` is false, so we terminate.\n*   **Final Result:** `[4, 2, 1, 3]`. All even numbers are at the beginning, followed by all odd numbers.\n\n**Python Code:**\n```python\nfrom typing import List\n\nclass Solution:\n    def sortArrayByParity(self, nums: List[int]) -> List[int]:\n        # Initialize two pointers, one at the start and one at the end of the array.\n        left, right = 0, len(nums) - 1\n\n        # The loop continues as long as the pointers haven't crossed.\n        while left < right:\n            # Case 1: The number at the left pointer is odd and the one at the right is even.\n            # This is the primary case where a swap is needed.\n            if nums[left] % 2 != 0 and nums[right] % 2 == 0:\n                # Swap the elements to move the even number to the left part\n                # and the odd number to the right part.\n                nums[left], nums[right] = nums[right], nums[left]\n                # Move both pointers inward since we've placed both correctly.\n                left += 1\n                right -= 1\n            else:\n                # Case 2: The number at the left pointer is already even.\n                # It's in the correct partition, so we move the left pointer to the right.\n                if nums[left] % 2 == 0:\n                    left += 1\n                \n                # Case 3: The number at the right pointer is already odd.\n                # It's in the correct partition, so we move the right pointer to the left.\n                if nums[right] % 2 != 0:\n                    right -= 1\n        \n        return nums\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    Although we have a `while` loop, the `left` and `right` pointers only move in one direction (inward). Each element in the array is visited at most once by either the `left` or the `right` pointer. Therefore, the time complexity is linear.\n\n*   **Space Complexity: O(1)**\n    The sorting is performed **in-place**. We are only using a few variables (`left`, `right`) to keep track of indices. This requires constant extra space, regardless of the input size.\n\n### **4. Pattern Connection**\nThis problem is a classic example of the **Two Pointers - In-place Array Modification** pattern. The tell-tale signs that this pattern is applicable are:\n\n1.  **In-place Requirement:** The core challenge is to rearrange the array without using extra space, which immediately points towards an in-place algorithm.\n2.  **Partitioning Task:** The goal is to partition the array into two distinct groups based on a simple condition (even or odd). Two pointers are a natural fit for managing the boundaries of these two growing partitions from opposite ends of the array.\n3.  **Order Invariance:** The problem statement explicitly mentions that the relative order within the partitions does not matter. This flexibility is key, as in-place swaps inherently alter the original ordering. If the relative order needed to be preserved, this specific two-pointer approach would not work, and a different (likely not O(1) space) algorithm would be needed.\n\nWhenever you encounter a problem that asks you to segregate array elements into two groups in-place (e.g., negatives and positives, zeros and non-zeros, elements less than a pivot and those greater), the two-pointer technique moving from both ends towards the middle should be one of the first patterns you consider.",
    "description": "Study Sort Array By Parity using the Pattern 4: Two Pointers - In-place Array Modification approach.",
    "has_content": true
  },
  {
    "id": "problem_907",
    "number": 907,
    "title": "Sum of Subarray Minimums",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 59: Stack - Monotonic Stack",
    "url": "https://leetcode.com/problems/sum-of-subarray-minimums/",
    "difficulty": "hard",
    "content": "# Sum of Subarray Minimums\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Sum of Subarray Minimums](https://leetcode.com/problems/sum-of-subarray-minimums/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 59: Stack - Monotonic Stack",
    "description": "Study Sum of Subarray Minimums using the Pattern 59: Stack - Monotonic Stack approach.",
    "has_content": false
  },
  {
    "id": "problem_918",
    "number": 918,
    "title": "Maximum Sum Circular Subarray",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray)",
    "url": "https://leetcode.com/problems/maximum-sum-circular-subarray/",
    "difficulty": "hard",
    "content": "# Maximum Sum Circular Subarray\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Sum Circular Subarray](https://leetcode.com/problems/maximum-sum-circular-subarray/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray)",
    "description": "Study Maximum Sum Circular Subarray using the Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray) approach.",
    "has_content": false
  },
  {
    "id": "problem_921",
    "number": 921,
    "title": "Minimum Add to Make Parentheses Valid",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 58: Stack - Valid Parentheses Matching",
    "url": "https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/",
    "difficulty": "hard",
    "content": "# Minimum Add to Make Parentheses Valid\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Add to Make Parentheses Valid](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 58: Stack - Valid Parentheses Matching",
    "description": "Study Minimum Add to Make Parentheses Valid using the Pattern 58: Stack - Valid Parentheses Matching approach.",
    "has_content": false
  },
  {
    "id": "problem_931",
    "number": 931,
    "title": "Minimum Falling Path Sum",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "url": "https://leetcode.com/problems/minimum-falling-path-sum/",
    "difficulty": "hard",
    "content": "# Minimum Falling Path Sum\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Falling Path Sum](https://leetcode.com/problems/minimum-falling-path-sum/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "description": "Study Minimum Falling Path Sum using the Pattern 33: DP - 2D Array (Unique Paths on Grid) approach.",
    "has_content": false
  },
  {
    "id": "problem_947",
    "number": 947,
    "title": "Most Stones Removed with Same Row or Column",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/",
    "difficulty": "hard",
    "content": "# Most Stones Removed with Same Row or Column\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Most Stones Removed with Same Row or Column](https://leetcode.com/problems/most-stones-removed-with-same-row-or-column/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study Most Stones Removed with Same Row or Column using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_952",
    "number": 952,
    "title": "Largest Component Size by Common Factor",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/largest-component-size-by-common-factor/",
    "difficulty": "hard",
    "content": "# Largest Component Size by Common Factor\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Largest Component Size by Common Factor](https://leetcode.com/problems/largest-component-size-by-common-factor/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study Largest Component Size by Common Factor using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_959",
    "number": 959,
    "title": "Regions Cut By Slashes",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/regions-cut-by-slashes/",
    "difficulty": "hard",
    "content": "# Regions Cut By Slashes\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Regions Cut By Slashes](https://leetcode.com/problems/regions-cut-by-slashes/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study Regions Cut By Slashes using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_962",
    "number": 962,
    "title": "Maximum Width Ramp",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 59: Stack - Monotonic Stack",
    "url": "https://leetcode.com/problems/maximum-width-ramp/",
    "difficulty": "hard",
    "content": "# Maximum Width Ramp\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Width Ramp](https://leetcode.com/problems/maximum-width-ramp/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 59: Stack - Monotonic Stack",
    "description": "Study Maximum Width Ramp using the Pattern 59: Stack - Monotonic Stack approach.",
    "has_content": false
  },
  {
    "id": "problem_973",
    "number": 973,
    "title": "K Closest Points to Origin",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "url": "https://leetcode.com/problems/k-closest-points-to-origin/",
    "difficulty": "hard",
    "content": "# K Closest Points to Origin\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [K Closest Points to Origin](https://leetcode.com/problems/k-closest-points-to-origin/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "description": "Study K Closest Points to Origin using the Pattern 37: Heap - Top K Elements (Selection/Frequency) approach.",
    "has_content": false
  },
  {
    "id": "problem_977",
    "number": 977,
    "title": "Squares of a Sorted Array",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)",
    "url": "https://leetcode.com/problems/squares-of-a-sorted-array/",
    "difficulty": "hard",
    "content": "---\n### **977. Squares of a Sorted Array**\n**Link to Problem:** [https://leetcode.com/problems/squares-of-a-sorted-array/](https://leetcode.com/problems/squares-of-a-sorted-array/)\n\n#### **1. Problem Statement**\nGiven an integer array `nums` that is sorted in non-decreasing order, the task is to return a new array containing the squares of each number, also sorted in non-decreasing order.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to follow the problem statement literally. First, we create a new list containing the square of each number from the input array. This new list, however, will not necessarily be sorted. For example, if the input is `[-4, -1, 0, 3]`, the squared list becomes `[16, 1, 0, 9]`. The second step, therefore, is to sort this list of squares to produce the final result.\n\n**Python Code:**\n```python\nimport collections\n\ndef sortedSquares_brute_force(nums: list[int]) -> list[int]:\n    \"\"\"\n    Solves the problem by first squaring every element and then sorting the result.\n    \"\"\"\n    # Step 1: Create a new array by squaring each element from the input array.\n    # A list comprehension is a concise way to do this.\n    squares = [num * num for num in nums]\n    \n    # Step 2: Sort the newly created list of squares.\n    # Python's built-in sort() method is highly optimized (Timsort).\n    squares.sort()\n    \n    return squares\n\n# Example usage:\n# nums = [-4, -1, 0, 3, 10]\n# print(sortedSquares_brute_force(nums))  # Output: [0, 1, 9, 16, 100]\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N log N)**\n    The process of squaring each of the N elements takes O(N) time. However, the subsequent sorting step dominates the runtime. A standard comparison-based sorting algorithm, like Timsort (used in Python), has an average and worst-case time complexity of O(N log N).\n\n*   **Space Complexity: O(N)**\n    We create a new array, `squares`, to store the squared values, which requires space proportional to the number of elements in the input array. Note: In Python, `sorted()` would create a new list (O(N)), while `.sort()` sorts in-place (O(log N) or O(N) space depending on implementation). Since we already created a new list for the squares, the space complexity is O(N).\n\n---\n\n#### **3. Optimized Approach: [Pattern 1: Two Pointers - Converging]**\n**Intuition:**\nThe brute-force approach has an O(N log N) complexity because it ignores a crucial piece of information: the input array is already sorted. We can leverage this property to build the sorted output array in a single pass, achieving a more optimal O(N) time complexity.\n\nThe key observation is that after squaring, the largest values will come from the numbers with the largest *absolute* values. Since the original array `nums` is sorted, these numbers with the largest magnitudes must be at the ends of the array.\n\nFor example, in `[-4, -1, 0, 3, 10]`, the candidates for the largest squared value are `(-4)^2 = 16` and `10^2 = 100`. The larger one is `100`. This will be the largest element in our final sorted array. The next largest will be a comparison between `(-4)^2 = 16` and `3^2 = 9`, and so on.\n\nThis insight leads directly to the **Two Pointers** pattern. We can place one pointer (`left`) at the beginning of the array and another (`right`) at the end. We compare the squares of the numbers at these two pointers and place the larger square at the end of our result array. We then move the pointer corresponding to the larger square inward and repeat the process, filling the result array from right to left (largest to smallest).\n\n**Walkthrough with `nums = [-4, -1, 0, 3, 10]`:**\n1.  Initialize `left = 0`, `right = 4`, and an empty result array `result = [0, 0, 0, 0, 0]`. We'll fill `result` from its last index, `k = 4`.\n2.  `left_sq = (-4)^2 = 16`, `right_sq = 10^2 = 100`.\n    *   `right_sq` is larger. Place `100` at `result[4]`.\n    *   `result` is now `[0, 0, 0, 0, 100]`.\n    *   Decrement `right` to 3 and `k` to 3.\n3.  `left_sq = (-4)^2 = 16`, `right_sq = 3^2 = 9`.\n    *   `left_sq` is larger. Place `16` at `result[3]`.\n    *   `result` is now `[0, 0, 0, 16, 100]`.\n    *   Increment `left` to 1 and decrement `k` to 2.\n4.  `left_sq = (-1)^2 = 1`, `right_sq = 3^2 = 9`.\n    *   `right_sq` is larger. Place `9` at `result[2]`.\n    *   `result` is now `[0, 0, 9, 16, 100]`.\n    *   Decrement `right` to 2 and `k` to 1.\n5.  `left_sq = (-1)^2 = 1`, `right_sq = 0^2 = 0`.\n    *   `left_sq` is larger. Place `1` at `result[1]`.\n    *   `result` is now `[0, 1, 9, 16, 100]`.\n    *   Increment `left` to 2 and decrement `k` to 0.\n6.  Now `left` (2) and `right` (2) point to the same element.\n    *   The loop continues. Place `0^2 = 0` at `result[0]`.\n    *   The loop terminates as `left` becomes greater than `right`. The final `result` is `[0, 1, 9, 16, 100]`.\n\n**Python Code:**\n```python\ndef sortedSquares_two_pointers(nums: list[int]) -> list[int]:\n    \"\"\"\n    Solves the problem in O(N) time using the two-pointer technique.\n    \"\"\"\n    n = len(nums)\n    # Initialize a result array of the same size, filled with zeros.\n    result = [0] * n\n    \n    # Initialize two pointers, one at the start and one at the end of the input array.\n    left, right = 0, n - 1\n    \n    # We will fill the result array from the end (largest to smallest).\n    # 'k' is the pointer for the last available position in the result array.\n    k = n - 1\n    \n    # The pointers will converge towards the center.\n    while left <= right:\n        left_square = nums[left] * nums[left]\n        right_square = nums[right] * nums[right]\n        \n        # Compare the squares of the values at the two pointers.\n        if left_square > right_square:\n            # The left value's square is larger, so it belongs at the end of the sorted output.\n            result[k] = left_square\n            # Move the left pointer inward.\n            left += 1\n        else:\n            # The right value's square is larger or equal, so it belongs at the end.\n            result[k] = right_square\n            # Move the right pointer inward.\n            right -= 1\n        \n        # Move the result array's fill position to the left.\n        k -= 1\n            \n    return result\n\n# Example usage:\n# nums = [-4, -1, 0, 3, 10]\n# print(sortedSquares_two_pointers(nums)) # Output: [0, 1, 9, 16, 100]\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    We use two pointers, `left` and `right`, that iterate through the array. The `left` pointer only moves forward, and the `right` pointer only moves backward. In total, they will make N steps. Since we iterate through the array only once, the time complexity is linear.\n\n*   **Space Complexity: O(N)**\n    We are creating a `result` array of the same size as the input array. Therefore, the space required is proportional to the input size. (This is often stated as O(1) *auxiliary* space if the space for the output array is not counted, but it's clearer to state O(N) as per standard problem constraints).\n\n---\n\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - Converging** pattern, adapted for building a new sorted array rather than finding a pair with a specific property. The signals that point to this pattern are:\n\n1.  **Sorted Input Array:** The most crucial prerequisite. The fact that `nums` is sorted guarantees that the elements with the largest absolute values are at the extremes. This property is what allows us to make a definite decision about the largest remaining element by only looking at the two ends.\n\n2.  **Creating a Sorted Output from a Sorted Input:** The task is not to search, but to transform and re-sort. Whenever you need to create a new sorted array from an already sorted one, a two-pointer approach should be a primary consideration as it can often avoid a full O(N log N) sort.\n\nWhile often associated with finding a target sum, the core principle of the \"Converging Pointers\" pattern is broader: **efficiently processing a sorted array from its opposite ends.** In this case, we use it to compare the \"end\" candidates (`nums[left]` and `nums[right]`) to determine which one produces the next value for our sorted result, effectively merging the negative and positive portions of the array into a final sorted list in a single, linear pass.",
    "description": "Study Squares of a Sorted Array using the Pattern 1: Two Pointers - Converging (Sorted Array Target Sum) approach.",
    "has_content": true
  },
  {
    "id": "problem_981",
    "number": 981,
    "title": "Time Based Key-Value Store",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/time-based-key-value-store/",
    "difficulty": "hard",
    "content": "# Time Based Key-Value Store\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Time Based Key-Value Store](https://leetcode.com/problems/time-based-key-value-store/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Time Based Key-Value Store using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_986",
    "number": 986,
    "title": "Interval List Intersections",
    "category": "VIII. Greedy Patterns",
    "pattern": "Pattern 48: Greedy - Interval Merging/Scheduling",
    "url": "https://leetcode.com/problems/interval-list-intersections/",
    "difficulty": "hard",
    "content": "# Interval List Intersections\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Interval List Intersections](https://leetcode.com/problems/interval-list-intersections/)\n\n**Category:** VIII. Greedy Patterns\n**Pattern:** Pattern 48: Greedy - Interval Merging/Scheduling",
    "description": "Study Interval List Intersections using the Pattern 48: Greedy - Interval Merging/Scheduling approach.",
    "has_content": false
  },
  {
    "id": "problem_988",
    "number": 988,
    "title": "Smallest String Starting From Leaf",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "url": "https://leetcode.com/problems/smallest-string-starting-from-leaf/",
    "difficulty": "hard",
    "content": "# Smallest String Starting From Leaf\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Smallest String Starting From Leaf](https://leetcode.com/problems/smallest-string-starting-from-leaf/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 13: Tree DFS - Recursive Preorder Traversal",
    "description": "Study Smallest String Starting From Leaf using the Pattern 13: Tree DFS - Recursive Preorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_994",
    "number": 994,
    "title": "Rotting Oranges",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 19: Graph BFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/rotting-oranges/",
    "difficulty": "hard",
    "content": "# Rotting Oranges\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 19: Graph BFS - Connected Components / Island Counting",
    "description": "Study Rotting Oranges using the Pattern 19: Graph BFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_1004",
    "number": 1004,
    "title": "Max Consecutive Ones III",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/max-consecutive-ones-iii/",
    "difficulty": "hard",
    "content": "# Max Consecutive Ones III\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Max Consecutive Ones III](https://leetcode.com/problems/max-consecutive-ones-iii/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Max Consecutive Ones III using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_1011",
    "number": 1011,
    "title": "Capacity To Ship Packages Within D Days",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 55: Binary Search - On Answer / Condition Function",
    "url": "https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/",
    "difficulty": "hard",
    "content": "# Capacity To Ship Packages Within D Days\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Capacity To Ship Packages Within D Days](https://leetcode.com/problems/capacity-to-ship-packages-within-d-days/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 55: Binary Search - On Answer / Condition Function",
    "description": "Study Capacity To Ship Packages Within D Days using the Pattern 55: Binary Search - On Answer / Condition Function approach.",
    "has_content": false
  },
  {
    "id": "problem_1020",
    "number": 1020,
    "title": "Number of Enclaves",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 18: Graph DFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/number-of-enclaves/",
    "difficulty": "hard",
    "content": "# Number of Enclaves\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Number of Enclaves](https://leetcode.com/problems/number-of-enclaves/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 18: Graph DFS - Connected Components / Island Counting",
    "description": "Study Number of Enclaves using the Pattern 18: Graph DFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_1046",
    "number": 1046,
    "title": "Last Stone Weight",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "url": "https://leetcode.com/problems/last-stone-weight/",
    "difficulty": "hard",
    "content": "# Last Stone Weight\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Last Stone Weight](https://leetcode.com/problems/last-stone-weight/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "description": "Study Last Stone Weight using the Pattern 37: Heap - Top K Elements (Selection/Frequency) approach.",
    "has_content": false
  },
  {
    "id": "problem_1059",
    "number": 1059,
    "title": "All Paths from Source Lead to Destination",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 20: Graph DFS - Cycle Detection (Directed Graph)",
    "url": "https://leetcode.com/problems/all-paths-from-source-lead-to-destination/",
    "difficulty": "hard",
    "content": "# All Paths from Source Lead to Destination\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [All Paths from Source Lead to Destination](https://leetcode.com/problems/all-paths-from-source-lead-to-destination/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 20: Graph DFS - Cycle Detection (Directed Graph)",
    "description": "Study All Paths from Source Lead to Destination using the Pattern 20: Graph DFS - Cycle Detection (Directed Graph) approach.",
    "has_content": false
  },
  {
    "id": "problem_1091",
    "number": 1091,
    "title": "Shortest Path in Binary Matrix",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 19: Graph BFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/shortest-path-in-binary-matrix/",
    "difficulty": "hard",
    "content": "# Shortest Path in Binary Matrix\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Shortest Path in Binary Matrix](https://leetcode.com/problems/shortest-path-in-binary-matrix/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 19: Graph BFS - Connected Components / Island Counting",
    "description": "Study Shortest Path in Binary Matrix using the Pattern 19: Graph BFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_1095",
    "number": 1095,
    "title": "Find in Mountain Array",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "url": "https://leetcode.com/problems/find-in-mountain-array/",
    "difficulty": "hard",
    "content": "# Find in Mountain Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find in Mountain Array](https://leetcode.com/problems/find-in-mountain-array/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array",
    "description": "Study Find in Mountain Array using the Pattern 54: Binary Search - Find Min/Max in Rotated Sorted Array approach.",
    "has_content": false
  },
  {
    "id": "problem_1101",
    "number": 1101,
    "title": "The Earliest Moment When Everyone Become Friends",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "url": "https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/",
    "difficulty": "hard",
    "content": "# The Earliest Moment When Everyone Become Friends\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [The Earliest Moment When Everyone Become Friends](https://leetcode.com/problems/the-earliest-moment-when-everyone-become-friends/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU)",
    "description": "Study The Earliest Moment When Everyone Become Friends using the Pattern 25: Graph - Union-Find (Disjoint Set Union - DSU) approach.",
    "has_content": false
  },
  {
    "id": "problem_1110",
    "number": 1110,
    "title": "Delete Nodes And Return Forest",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "url": "https://leetcode.com/problems/delete-nodes-and-return-forest/",
    "difficulty": "hard",
    "content": "# Delete Nodes And Return Forest\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Delete Nodes And Return Forest](https://leetcode.com/problems/delete-nodes-and-return-forest/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "description": "Study Delete Nodes And Return Forest using the Pattern 15: Tree DFS - Recursive Postorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_1136",
    "number": 1136,
    "title": "Parallel Courses",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "url": "https://leetcode.com/problems/parallel-courses/",
    "difficulty": "hard",
    "content": "# Parallel Courses\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Parallel Courses](https://leetcode.com/problems/parallel-courses/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "description": "Study Parallel Courses using the Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_1143",
    "number": 1143,
    "title": "Longest Common Subsequence",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 31: DP - 2D Array (Longest Common Subsequence - LCS)",
    "url": "https://leetcode.com/problems/longest-common-subsequence/",
    "difficulty": "hard",
    "content": "# Longest Common Subsequence\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Longest Common Subsequence](https://leetcode.com/problems/longest-common-subsequence/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 31: DP - 2D Array (Longest Common Subsequence - LCS)",
    "description": "Study Longest Common Subsequence using the Pattern 31: DP - 2D Array (Longest Common Subsequence - LCS) approach.",
    "has_content": false
  },
  {
    "id": "problem_1146",
    "number": 1146,
    "title": "Snapshot Array",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/snapshot-array/",
    "difficulty": "hard",
    "content": "# Snapshot Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Snapshot Array](https://leetcode.com/problems/snapshot-array/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Snapshot Array using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_1161",
    "number": 1161,
    "title": "Maximum Level Sum of a Binary Tree",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 12: Tree BFS - Level Order Traversal",
    "url": "https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/",
    "difficulty": "hard",
    "content": "# Maximum Level Sum of a Binary Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Level Sum of a Binary Tree](https://leetcode.com/problems/maximum-level-sum-of-a-binary-tree/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 12: Tree BFS - Level Order Traversal",
    "description": "Study Maximum Level Sum of a Binary Tree using the Pattern 12: Tree BFS - Level Order Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_1249",
    "number": 1249,
    "title": "Minimum Remove to Make Valid Parentheses",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 58: Stack - Valid Parentheses Matching",
    "url": "https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/",
    "difficulty": "hard",
    "content": "# Minimum Remove to Make Valid Parentheses\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Remove to Make Valid Parentheses](https://leetcode.com/problems/minimum-remove-to-make-valid-parentheses/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 58: Stack - Valid Parentheses Matching",
    "description": "Study Minimum Remove to Make Valid Parentheses using the Pattern 58: Stack - Valid Parentheses Matching approach.",
    "has_content": false
  },
  {
    "id": "problem_1254",
    "number": 1254,
    "title": "Number of Closed Islands",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 18: Graph DFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/number-of-closed-islands/",
    "difficulty": "hard",
    "content": "# Number of Closed Islands\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Number of Closed Islands](https://leetcode.com/problems/number-of-closed-islands/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 18: Graph DFS - Connected Components / Island Counting",
    "description": "Study Number of Closed Islands using the Pattern 18: Graph DFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_1277",
    "number": 1277,
    "title": "Count Square Submatrices with All Ones",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "url": "https://leetcode.com/problems/count-square-submatrices-with-all-ones/",
    "difficulty": "hard",
    "content": "# Count Square Submatrices with All Ones\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Count Square Submatrices with All Ones](https://leetcode.com/problems/count-square-submatrices-with-all-ones/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 33: DP - 2D Array (Unique Paths on Grid)",
    "description": "Study Count Square Submatrices with All Ones using the Pattern 33: DP - 2D Array (Unique Paths on Grid) approach.",
    "has_content": false
  },
  {
    "id": "problem_1334",
    "number": 1334,
    "title": "Find the City With the Smallest Number of Neighbors at a Threshold Distance",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 22: Graph - Deep Copy / Cloning",
    "url": "https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/",
    "difficulty": "hard",
    "content": "# Find the City With the Smallest Number of Neighbors at a Threshold Distance\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find the City With the Smallest Number of Neighbors at a Threshold Distance](https://leetcode.com/problems/find-the-city-with-the-smallest-number-of-neighbors-at-a-threshold-distance/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 22: Graph - Deep Copy / Cloning",
    "description": "Study Find the City With the Smallest Number of Neighbors at a Threshold Distance using the Pattern 22: Graph - Deep Copy / Cloning approach.",
    "has_content": false
  },
  {
    "id": "problem_1348",
    "number": 1348,
    "title": "Tweet Counts Per Frequency",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/tweet-counts-per-frequency/",
    "difficulty": "hard",
    "content": "# Tweet Counts Per Frequency\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Tweet Counts Per Frequency](https://leetcode.com/problems/tweet-counts-per-frequency/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Tweet Counts Per Frequency using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_1352",
    "number": 1352,
    "title": "Product of the Last K Numbers",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/product-of-the-last-k-numbers/",
    "difficulty": "hard",
    "content": "# Product of the Last K Numbers\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Product of the Last K Numbers](https://leetcode.com/problems/product-of-the-last-k-numbers/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Product of the Last K Numbers using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_1381",
    "number": 1381,
    "title": "Design a Stack With Increment Operation",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-a-stack-with-increment-operation/",
    "difficulty": "hard",
    "content": "# Design a Stack With Increment Operation\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design a Stack With Increment Operation](https://leetcode.com/problems/design-a-stack-with-increment-operation/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design a Stack With Increment Operation using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_1438",
    "number": 1438,
    "title": "Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/",
    "difficulty": "hard",
    "content": "# Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit](https://leetcode.com/problems/longest-continuous-subarray-with-absolute-diff-less-than-or-equal-to-limit/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Longest Continuous Subarray With Absolute Diff Less Than or Equal to Limit using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_1457",
    "number": 1457,
    "title": "Pseudo-Palindromic Paths in a Binary Tree",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 47: Backtracking - Palindrome Partitioning",
    "url": "https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/",
    "difficulty": "hard",
    "content": "# Pseudo-Palindromic Paths in a Binary Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Pseudo-Palindromic Paths in a Binary Tree](https://leetcode.com/problems/pseudo-palindromic-paths-in-a-binary-tree/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 47: Backtracking - Palindrome Partitioning",
    "description": "Study Pseudo-Palindromic Paths in a Binary Tree using the Pattern 47: Backtracking - Palindrome Partitioning approach.",
    "has_content": false
  },
  {
    "id": "problem_1475",
    "number": 1475,
    "title": "Final Prices With a Special Discount in a Shop",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 59: Stack - Monotonic Stack",
    "url": "https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/",
    "difficulty": "hard",
    "content": "# Final Prices With a Special Discount in a Shop\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Final Prices With a Special Discount in a Shop](https://leetcode.com/problems/final-prices-with-a-special-discount-in-a-shop/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 59: Stack - Monotonic Stack",
    "description": "Study Final Prices With a Special Discount in a Shop using the Pattern 59: Stack - Monotonic Stack approach.",
    "has_content": false
  },
  {
    "id": "problem_1482",
    "number": 1482,
    "title": "Minimum Number of Days to Make m Bouquets",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 55: Binary Search - On Answer / Condition Function",
    "url": "https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/",
    "difficulty": "hard",
    "content": "# Minimum Number of Days to Make m Bouquets\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Number of Days to Make m Bouquets](https://leetcode.com/problems/minimum-number-of-days-to-make-m-bouquets/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 55: Binary Search - On Answer / Condition Function",
    "description": "Study Minimum Number of Days to Make m Bouquets using the Pattern 55: Binary Search - On Answer / Condition Function approach.",
    "has_content": false
  },
  {
    "id": "problem_1490",
    "number": 1490,
    "title": "Clone N-ary Tree",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 22: Graph - Deep Copy / Cloning",
    "url": "https://leetcode.com/problems/clone-n-ary-tree/",
    "difficulty": "hard",
    "content": "# Clone N-ary Tree\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Clone N-ary Tree](https://leetcode.com/problems/clone-n-ary-tree/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 22: Graph - Deep Copy / Cloning",
    "description": "Study Clone N-ary Tree using the Pattern 22: Graph - Deep Copy / Cloning approach.",
    "has_content": false
  },
  {
    "id": "problem_1493",
    "number": 1493,
    "title": "Longest Subarray of 1's After Deleting One Element",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/",
    "difficulty": "hard",
    "content": "# Longest Subarray of 1's After Deleting One Element\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Longest Subarray of 1's After Deleting One Element](https://leetcode.com/problems/longest-subarray-of-1s-after-deleting-one-element/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Longest Subarray of 1's After Deleting One Element using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_1514",
    "number": 1514,
    "title": "Path with Maximum Probability",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "url": "https://leetcode.com/problems/path-with-maximum-probability/",
    "difficulty": "hard",
    "content": "# Path with Maximum Probability\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Path with Maximum Probability](https://leetcode.com/problems/path-with-maximum-probability/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "description": "Study Path with Maximum Probability using the Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_1539",
    "number": 1539,
    "title": "Kth Missing Positive Number",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 53: Binary Search - On Sorted Array/List",
    "url": "https://leetcode.com/problems/kth-missing-positive-number/",
    "difficulty": "hard",
    "content": "# Kth Missing Positive Number\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Kth Missing Positive Number](https://leetcode.com/problems/kth-missing-positive-number/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 53: Binary Search - On Sorted Array/List",
    "description": "Study Kth Missing Positive Number using the Pattern 53: Binary Search - On Sorted Array/List approach.",
    "has_content": false
  },
  {
    "id": "problem_1598",
    "number": 1598,
    "title": "Crawler Log Folder",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 5: Two Pointers - String Comparison",
    "url": "https://leetcode.com/problems/crawler-log-folder/",
    "difficulty": "hard",
    "content": "---\n### **1598. Crawler Log Folder**\n**Link to Problem:** [https://leetcode.com/problems/crawler-log-folder/](https://leetcode.com/problems/crawler-log-folder/)\n\n#### **1. Problem Statement**\nGiven a list of strings representing operations in a file system, we need to calculate the minimum number of moves to return to the main folder. The operations are: moving to a parent folder (`\"../\"`), staying in the current folder (`\"./\"`), or moving to a child folder (`\"x/\"`). The core task is to simulate this navigation and determine the final \"depth\" of the file system traversal.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to conceptualize this problem is to literally simulate the folder path. We can use a list or a stack to keep track of the folders in our current path.\n\n1.  Initialize an empty list, say `path_stack`, to represent the directory structure.\n2.  Iterate through each `log` in the input list.\n3.  If the log is `\"../\"`, we need to go up one level. This is equivalent to popping the last folder from our `path_stack`, but only if the stack is not already empty (as we can't go higher than the main folder).\n4.  If the log is `\"./\"`, we do nothing; we stay in the same directory.\n5.  If the log is anything else (e.g., `\"d1/\"`), it means we are moving into a child directory. We can push this directory name onto our `path_stack`.\n6.  After processing all logs, the size of the `path_stack` represents our final depth. This is the minimum number of `\"../\"` operations needed to get back to the main folder.\n\n**Python Code:**\n```python\nfrom typing import List\n\nclass Solution:\n    def minOperations_brute_force(self, logs: List[str]) -> int:\n        # We can use a list to act as a stack, simulating the actual path.\n        # The final answer is simply the length of this path.\n        path_stack = []\n\n        for log in logs:\n            if log == \"../\":\n                # If we are not in the main folder (stack is not empty),\n                # we move up by popping the last directory.\n                if path_stack:\n                    path_stack.pop()\n            elif log == \"./\":\n                # This operation means \"stay in the same folder\",\n                # so we do nothing to our path.\n                continue\n            else:\n                # This is a move to a child folder.\n                # We add the new folder to our path.\n                path_stack.append(log)\n        \n        # The final depth is the number of folders we are inside.\n        return len(path_stack)\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**, where N is the number of logs. We iterate through the `logs` list exactly once.\n*   **Space Complexity: O(N)**. In the worst-case scenario, every log is a move into a child directory. This would cause our `path_stack` to grow to a size of N, storing N folder names.\n\n---\n### **3. Optimized Approach: State Tracking with a Single Variable**\n**Intuition:**\nWhile the stack-based approach correctly simulates the path, it stores more information than we actually need. We don't care about the *names* of the folders in the path (`\"d1/\"`, `\"d2/\"`, etc.); we only care about the *depth*.\n\nThe key insight is that the problem can be solved by simply tracking a single integer representing our current depth.\n\n1.  Initialize a variable, `depth`, to 0.\n2.  Iterate through each `log`:\n    *   If the log is `\"../\"`, we decrement `depth`, but we ensure it never goes below 0.\n    *   If the log is `\"./\"`, we do nothing.\n    *   If the log is a child folder (`\"x/\"`), we increment `depth`.\n3.  The final value of `depth` is our answer. This avoids storing the entire path, reducing our space usage significantly.\n\nLet's walk through an example: `logs = [\"d1/\",\"d2/\",\"../\",\"d21/\",\"./\"]`\n*   `depth = 0`\n*   `\"d1/\"`: Move in. `depth` becomes 1.\n*   `\"d2/\"`: Move in. `depth` becomes 2.\n*   `\"../\"`: Move out. `depth` becomes 1.\n*   `\"d21/\"`: Move in. `depth` becomes 2.\n*   `\"./\"`: Stay put. `depth` remains 2.\n\nThe final depth is 2.\n\n**Python Code:**\n```python\nfrom typing import List\n\nclass Solution:\n    def minOperations(self, logs: List[str]) -> int:\n        # Instead of a stack, we only need to track the depth.\n        # This is our state variable.\n        depth = 0\n\n        for log in logs:\n            if log == \"../\":\n                # Move up one level. We use max(0, ...) to ensure\n                # the depth never becomes negative, as we can't go\n                # above the main folder.\n                depth = max(0, depth - 1)\n            elif log == \"./\":\n                # Stay in the current folder, so depth is unchanged.\n                continue\n            else:\n                # Move into a child folder, increasing the depth.\n                depth += 1\n        \n        return depth\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**, where N is the number of logs. We still perform a single pass through the input list.\n*   **Space Complexity: O(1)**. This is the crucial improvement. We only use a single integer variable (`depth`) to store our state, regardless of the number of logs.\n\n---\n#### **4. Pattern Connection**\nThis problem is an excellent example of a **State Simulation** problem, which can often be optimized from a stack-based approach to a simple counter. However, it is important to note that this problem **does not fit the \"Two Pointers - String Comparison\" pattern.**\n\nThe \"Two Pointers - String Comparison\" pattern is typically used when you need to compare two strings or a single string with itself, where the pointers move based on the characters they encounter. A classic example is **LeetCode 844. Backspace String Compare**. In that problem, you would use two pointers, one for each string, starting from the end. The pointers would move backward, skipping characters that are \"deleted\" by backspaces (`#`). The pointers' movements are interdependent and used for direct comparison.\n\nIn contrast, \"Crawler Log Folder\" involves processing a sequence of independent operations. There is no complex interaction between different parts of an array or string that would necessitate two pointers. The logic is a simple, linear traversal that updates a single state variable (`depth`). The core task is not comparison but **state management**. Recognizing that you only need to track the final depth, not the full path, is the key optimization and a common theme in problems that can be simplified from a stack simulation to a counter.",
    "description": "Study Crawler Log Folder using the Pattern 5: Two Pointers - String Comparison approach.",
    "has_content": true
  },
  {
    "id": "problem_1631",
    "number": 1631,
    "title": "Path With Minimum Effort",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "url": "https://leetcode.com/problems/path-with-minimum-effort/",
    "difficulty": "hard",
    "content": "# Path With Minimum Effort\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Path With Minimum Effort](https://leetcode.com/problems/path-with-minimum-effort/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "description": "Study Path With Minimum Effort using the Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_1642",
    "number": 1642,
    "title": "Furthest Building You Can Reach",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "url": "https://leetcode.com/problems/furthest-building-you-can-reach/",
    "difficulty": "hard",
    "content": "# Furthest Building You Can Reach\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Furthest Building You Can Reach](https://leetcode.com/problems/furthest-building-you-can-reach/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "description": "Study Furthest Building You Can Reach using the Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue) approach.",
    "has_content": false
  },
  {
    "id": "problem_1658",
    "number": 1658,
    "title": "Minimum Operations to Reduce X to Zero",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/",
    "difficulty": "hard",
    "content": "# Minimum Operations to Reduce X to Zero\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Operations to Reduce X to Zero](https://leetcode.com/problems/minimum-operations-to-reduce-x-to-zero/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Minimum Operations to Reduce X to Zero using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_1671",
    "number": 1671,
    "title": "Minimum Number of Removals to Make Mountain Array",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 36: DP - Longest Increasing Subsequence (LIS)",
    "url": "https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/",
    "difficulty": "hard",
    "content": "# Minimum Number of Removals to Make Mountain Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Number of Removals to Make Mountain Array](https://leetcode.com/problems/minimum-number-of-removals-to-make-mountain-array/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 36: DP - Longest Increasing Subsequence (LIS)",
    "description": "Study Minimum Number of Removals to Make Mountain Array using the Pattern 36: DP - Longest Increasing Subsequence (LIS) approach.",
    "has_content": false
  },
  {
    "id": "problem_1673",
    "number": 1673,
    "title": "Find the Most Competitive Subsequence",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 59: Stack - Monotonic Stack",
    "url": "https://leetcode.com/problems/find-the-most-competitive-subsequence/",
    "difficulty": "hard",
    "content": "# Find the Most Competitive Subsequence\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find the Most Competitive Subsequence](https://leetcode.com/problems/find-the-most-competitive-subsequence/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 59: Stack - Monotonic Stack",
    "description": "Study Find the Most Competitive Subsequence using the Pattern 59: Stack - Monotonic Stack approach.",
    "has_content": false
  },
  {
    "id": "problem_1696",
    "number": 1696,
    "title": "Jump Game VI",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 10: Sliding Window - Monotonic Queue for Max/Min",
    "url": "https://leetcode.com/problems/jump-game-vi/",
    "difficulty": "hard",
    "content": "# Jump Game VI\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Jump Game VI](https://leetcode.com/problems/jump-game-vi/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 10: Sliding Window - Monotonic Queue for Max/Min",
    "description": "Study Jump Game VI using the Pattern 10: Sliding Window - Monotonic Queue for Max/Min approach.",
    "has_content": false
  },
  {
    "id": "problem_1749",
    "number": 1749,
    "title": "Maximum Absolute Sum of Any Subarray",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray)",
    "url": "https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/",
    "difficulty": "hard",
    "content": "# Maximum Absolute Sum of Any Subarray\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Absolute Sum of Any Subarray](https://leetcode.com/problems/maximum-absolute-sum-of-any-subarray/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray)",
    "description": "Study Maximum Absolute Sum of Any Subarray using the Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray) approach.",
    "has_content": false
  },
  {
    "id": "problem_1756",
    "number": 1756,
    "title": "Design Most Recently Used Queue",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-most-recently-used-queue/",
    "difficulty": "hard",
    "content": "# Design Most Recently Used Queue\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design Most Recently Used Queue](https://leetcode.com/problems/design-most-recently-used-queue/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design Most Recently Used Queue using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_1760",
    "number": 1760,
    "title": "Minimum Limit of Balls in a Bag",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 55: Binary Search - On Answer / Condition Function",
    "url": "https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/",
    "difficulty": "hard",
    "content": "# Minimum Limit of Balls in a Bag\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Limit of Balls in a Bag](https://leetcode.com/problems/minimum-limit-of-balls-in-a-bag/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 55: Binary Search - On Answer / Condition Function",
    "description": "Study Minimum Limit of Balls in a Bag using the Pattern 55: Binary Search - On Answer / Condition Function approach.",
    "has_content": false
  },
  {
    "id": "problem_1792",
    "number": 1792,
    "title": "Maximum Average Pass Ratio",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "url": "https://leetcode.com/problems/maximum-average-pass-ratio/",
    "difficulty": "hard",
    "content": "# Maximum Average Pass Ratio\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Average Pass Ratio](https://leetcode.com/problems/maximum-average-pass-ratio/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "description": "Study Maximum Average Pass Ratio using the Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue) approach.",
    "has_content": false
  },
  {
    "id": "problem_1825",
    "number": 1825,
    "title": "Finding MK Average",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 38: Heap - Two Heaps for Median Finding",
    "url": "https://leetcode.com/problems/finding-mk-average/",
    "difficulty": "hard",
    "content": "# Finding MK Average\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Finding MK Average](https://leetcode.com/problems/finding-mk-average/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 38: Heap - Two Heaps for Median Finding",
    "description": "Study Finding MK Average using the Pattern 38: Heap - Two Heaps for Median Finding approach.",
    "has_content": false
  },
  {
    "id": "problem_1834",
    "number": 1834,
    "title": "Single-Threaded CPU",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "url": "https://leetcode.com/problems/single-threaded-cpu/",
    "difficulty": "hard",
    "content": "# Single-Threaded CPU\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Single-Threaded CPU](https://leetcode.com/problems/single-threaded-cpu/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "description": "Study Single-Threaded CPU using the Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue) approach.",
    "has_content": false
  },
  {
    "id": "problem_1838",
    "number": 1838,
    "title": "Frequency of the Most Frequent Element",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/frequency-of-the-most-frequent-element/",
    "difficulty": "hard",
    "content": "# Frequency of the Most Frequent Element\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Frequency of the Most Frequent Element](https://leetcode.com/problems/frequency-of-the-most-frequent-element/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Frequency of the Most Frequent Element using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_1857",
    "number": 1857,
    "title": "Largest Color Value in a Directed Graph",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "url": "https://leetcode.com/problems/largest-color-value-in-a-directed-graph/",
    "difficulty": "hard",
    "content": "# Largest Color Value in a Directed Graph\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Largest Color Value in a Directed Graph](https://leetcode.com/problems/largest-color-value-in-a-directed-graph/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "description": "Study Largest Color Value in a Directed Graph using the Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_1905",
    "number": 1905,
    "title": "Count Sub Islands",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 18: Graph DFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/count-sub-islands/",
    "difficulty": "hard",
    "content": "# Count Sub Islands\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Count Sub Islands](https://leetcode.com/problems/count-sub-islands/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 18: Graph DFS - Connected Components / Island Counting",
    "description": "Study Count Sub Islands using the Pattern 18: Graph DFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_1942",
    "number": 1942,
    "title": "The Number of the Smallest Unoccupied Chair",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "url": "https://leetcode.com/problems/the-number-of-the-smallest-unoccupied-chair/",
    "difficulty": "hard",
    "content": "# The Number of the Smallest Unoccupied Chair\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [The Number of the Smallest Unoccupied Chair](https://leetcode.com/problems/the-number-of-the-smallest-unoccupied-chair/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "description": "Study The Number of the Smallest Unoccupied Chair using the Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue) approach.",
    "has_content": false
  },
  {
    "id": "problem_1963",
    "number": 1963,
    "title": "Minimum Number of Swaps to Make the String Balanced",
    "category": "X. Stack Patterns",
    "pattern": "Pattern 58: Stack - Valid Parentheses Matching",
    "url": "https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/",
    "difficulty": "hard",
    "content": "# Minimum Number of Swaps to Make the String Balanced\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Number of Swaps to Make the String Balanced](https://leetcode.com/problems/minimum-number-of-swaps-to-make-the-string-balanced/)\n\n**Category:** X. Stack Patterns\n**Pattern:** Pattern 58: Stack - Valid Parentheses Matching",
    "description": "Study Minimum Number of Swaps to Make the String Balanced using the Pattern 58: Stack - Valid Parentheses Matching approach.",
    "has_content": false
  },
  {
    "id": "problem_1976",
    "number": 1976,
    "title": "Number of Ways to Arrive at Destination",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "url": "https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/",
    "difficulty": "hard",
    "content": "# Number of Ways to Arrive at Destination\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Number of Ways to Arrive at Destination](https://leetcode.com/problems/number-of-ways-to-arrive-at-destination/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "description": "Study Number of Ways to Arrive at Destination using the Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_2013",
    "number": 2013,
    "title": "Detect Squares",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/detect-squares/",
    "difficulty": "hard",
    "content": "# Detect Squares\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Detect Squares](https://leetcode.com/problems/detect-squares/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Detect Squares using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_2018",
    "number": 2018,
    "title": "Check if Word Can Be Placed In Crossword",
    "category": "VII. Backtracking Patterns",
    "pattern": "Pattern 45: Backtracking - Word Search / Path Finding in Grid",
    "url": "https://leetcode.com/problems/check-if-word-can-be-placed-in-crossword/",
    "difficulty": "hard",
    "content": "# Check if Word Can Be Placed In Crossword\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Check if Word Can Be Placed In Crossword](https://leetcode.com/problems/check-if-word-can-be-placed-in-crossword/)\n\n**Category:** VII. Backtracking Patterns\n**Pattern:** Pattern 45: Backtracking - Word Search / Path Finding in Grid",
    "description": "Study Check if Word Can Be Placed In Crossword using the Pattern 45: Backtracking - Word Search / Path Finding in Grid approach.",
    "has_content": false
  },
  {
    "id": "problem_2034",
    "number": 2034,
    "title": "Stock Price Fluctuation",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/stock-price-fluctuation/",
    "difficulty": "hard",
    "content": "# Stock Price Fluctuation\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Stock Price Fluctuation](https://leetcode.com/problems/stock-price-fluctuation/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Stock Price Fluctuation using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_2045",
    "number": 2045,
    "title": "Second Minimum Time to Reach Destination",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "url": "https://leetcode.com/problems/second-minimum-time-to-reach-destination/",
    "difficulty": "hard",
    "content": "# Second Minimum Time to Reach Destination\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Second Minimum Time to Reach Destination](https://leetcode.com/problems/second-minimum-time-to-reach-destination/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "description": "Study Second Minimum Time to Reach Destination using the Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_2050",
    "number": 2050,
    "title": "Parallel Courses III",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "url": "https://leetcode.com/problems/parallel-courses-iii/",
    "difficulty": "hard",
    "content": "# Parallel Courses III\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Parallel Courses III](https://leetcode.com/problems/parallel-courses-iii/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "description": "Study Parallel Courses III using the Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_2064",
    "number": 2064,
    "title": "Minimized Maximum of Products Distributed to Any Store",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 55: Binary Search - On Answer / Condition Function",
    "url": "https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/",
    "difficulty": "hard",
    "content": "# Minimized Maximum of Products Distributed to Any Store\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimized Maximum of Products Distributed to Any Store](https://leetcode.com/problems/minimized-maximum-of-products-distributed-to-any-store/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 55: Binary Search - On Answer / Condition Function",
    "description": "Study Minimized Maximum of Products Distributed to Any Store using the Pattern 55: Binary Search - On Answer / Condition Function approach.",
    "has_content": false
  },
  {
    "id": "problem_2095",
    "number": 2095,
    "title": "Delete the Middle Node of a Linked List",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 3: Two Pointers - Fixed Separation (Nth Node from End)",
    "url": "https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/",
    "difficulty": "hard",
    "content": "---\n### **2095. Delete the Middle Node of a Linked List**\n**Link to Problem:** [https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/](https://leetcode.com/problems/delete-the-middle-node-of-a-linked-list/)\n\n#### **1. Problem Statement**\nYou are given the `head` of a singly linked list. The task is to find the middle node of this list, delete it, and return the `head` of the modified list. The middle node is defined as the `floor(n / 2)`-th node from the beginning (0-indexed) where `n` is the total number of nodes.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to follow the definition directly. To find the middle node at index `floor(n/2)`, we first need to know the total number of nodes, `n`. This suggests a two-pass approach:\n\n1.  **First Pass:** Traverse the entire linked list from beginning to end, simply to count the total number of nodes, `n`.\n2.  **Second Pass:** Calculate the index of the node *before* the middle one (`middle_index - 1`). Traverse the list again from the `head`, stopping at this predecessor node.\n3.  **Deletion:** Once at the predecessor, update its `next` pointer to skip over the middle node, effectively deleting it from the list.\n\nA special case is a list with only one node, where deleting the middle node results in an empty list.\n\n**Python Code:**\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Edge Case: If the list is empty or has only one node,\n        # deleting the middle node results in an empty list.\n        if not head or not head.next:\n            return None\n\n        # --- First Pass: Count the total number of nodes ---\n        count = 0\n        current = head\n        while current:\n            count += 1\n            current = current.next\n\n        # --- Second Pass: Find the node *before* the middle ---\n        # The middle node is at index floor(count / 2).\n        # We need to stop at the node at index (middle - 1) to delete the middle.\n        middle_predecessor_index = (count // 2) - 1\n        \n        # Reset pointer to the head for the second traversal.\n        current = head\n        for _ in range(middle_predecessor_index):\n            current = current.next\n            \n        # --- Deletion ---\n        # `current` is now the node just before the middle node.\n        # We bypass the middle node by pointing `current.next` to the node after the middle.\n        current.next = current.next.next\n\n        return head\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** O(N). We traverse the list once to count the nodes (N steps) and then traverse it up to halfway again to find the predecessor (N/2 steps). O(N + N/2) simplifies to O(N).\n*   **Space Complexity:** O(1). We only use a few extra variables (`count`, `current`, etc.), so the space usage is constant.\n\n### **3. Optimized Approach: Two Pointers - Fixed Separation (Nth Node from End)**\n**Intuition:**\nThe brute-force approach requires two full or partial passes. We can optimize this to a single pass using the **Slow and Fast Pointer** technique, which is a classic application of this pattern.\n\nThe idea is to have two pointers, `slow` and `fast`, both starting at the `head`. The `fast` pointer moves two steps at a time, while the `slow` pointer moves one step at a time. By the time the `fast` pointer reaches the end of the list, the `slow` pointer will be positioned exactly at the middle node.\n\nWhy does this work? The `fast` pointer covers twice the distance of the `slow` pointer in the same amount of time. When `fast` has traversed the entire list (length `n`), `slow` will have traversed half the list (length `n/2`), landing it right on the middle node.\n\nTo *delete* the middle node, we need access to the node *before* it. We can achieve this by keeping a third pointer, `prev`, that always trails one step behind `slow`. When the loop terminates, `slow` is on the middle node, and `prev` is on the node right before it, ready for the deletion.\n\nLet's walk through `[1, 3, 4, 7, 1, 2, 6]`:\n- **Initial:** `prev = None`, `slow = 1`, `fast = 1`\n- **Step 1:** `fast` moves to `4`, `slow` moves to `3`, `prev` moves to `1`.\n- **Step 2:** `fast` moves to `1`, `slow` moves to `4`, `prev` moves to `3`.\n- **Step 3:** `fast` moves to `6`, `slow` moves to `7`, `prev` moves to `4`.\n- **End:** `fast.next` is now `None`. The loop stops. `slow` is at `7` (the middle), and `prev` is at `4` (the predecessor). We can now execute `prev.next = slow.next`.\n\n**Python Code:**\n```python\n# Definition for singly-linked list.\n# class ListNode:\n#     def __init__(self, val=0, next=None):\n#         self.val = val\n#         self.next = next\n\nclass Solution:\n    def deleteMiddle(self, head: Optional[ListNode]) -> Optional[ListNode]:\n        # Edge Case: An empty list or a list with one node becomes an empty list.\n        if not head or not head.next:\n            return None\n\n        # Initialize two pointers, slow and fast.\n        # Fast moves twice as fast as slow.\n        slow = head\n        fast = head\n        \n        # prev will point to the node right before the slow pointer.\n        # This is the node we need to modify for deletion.\n        prev = None\n\n        # --- Single Pass Traversal ---\n        while fast and fast.next:\n            # The fast pointer moves two steps.\n            fast = fast.next.next\n            \n            # Update prev to slow's current position *before* moving slow.\n            prev = slow\n            \n            # The slow pointer moves one step.\n            slow = slow.next\n            \n        # When the loop ends, `slow` is at the middle node.\n        # `prev` is at the node just before the middle.\n        \n        # Delete the middle node by linking the previous node to the next one.\n        prev.next = slow.next\n        \n        return head\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** O(N). Although we have two pointers, they both traverse the list in a single pass. The `fast` pointer determines the runtime, which is proportional to the list length, N.\n*   **Space Complexity:** O(1). We only use three pointer variables, regardless of the size of the list.\n\n### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers with Fixed (or Relative) Separation** pattern, specifically the \"Slow and Fast Pointer\" variation used for linked lists.\n\nThe signal for this pattern is any problem that requires finding a node at a relative position (like the middle, 1/3, etc.) or a fixed distance from the end of a list, without first knowing its size. The brute-force method's need for a preliminary \"counting\" pass is a strong indicator that a single-pass two-pointer solution exists.\n\nBy setting up a fixed relationship between the pointers' speeds (`fast` moves at 2x the speed of `slow`), we can find the halfway point in a single traversal. The core idea is that one pointer's journey across the entire structure gives us the exact location of another pointer at a fractional position. This elegant, single-pass solution is far more efficient than the two-pass brute-force approach, making it a crucial technique for linked list problems.",
    "description": "Study Delete the Middle Node of a Linked List using the Pattern 3: Two Pointers - Fixed Separation (Nth Node from End) approach.",
    "has_content": true
  },
  {
    "id": "problem_2101",
    "number": 2101,
    "title": "Detonate the Maximum Bombs",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 18: Graph DFS - Connected Components / Island Counting",
    "url": "https://leetcode.com/problems/detonate-the-maximum-bombs/",
    "difficulty": "hard",
    "content": "# Detonate the Maximum Bombs\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Detonate the Maximum Bombs](https://leetcode.com/problems/detonate-the-maximum-bombs/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 18: Graph DFS - Connected Components / Island Counting",
    "description": "Study Detonate the Maximum Bombs using the Pattern 18: Graph DFS - Connected Components / Island Counting approach.",
    "has_content": false
  },
  {
    "id": "problem_2115",
    "number": 2115,
    "title": "Find All Possible Recipes from Given Supplies",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "url": "https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/",
    "difficulty": "hard",
    "content": "# Find All Possible Recipes from Given Supplies\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find All Possible Recipes from Given Supplies](https://leetcode.com/problems/find-all-possible-recipes-from-given-supplies/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "description": "Study Find All Possible Recipes from Given Supplies using the Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_2203",
    "number": 2203,
    "title": "Minimum Weighted Subgraph With the Required Paths",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "url": "https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/",
    "difficulty": "hard",
    "content": "# Minimum Weighted Subgraph With the Required Paths\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Weighted Subgraph With the Required Paths](https://leetcode.com/problems/minimum-weighted-subgraph-with-the-required-paths/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "description": "Study Minimum Weighted Subgraph With the Required Paths using the Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_2226",
    "number": 2226,
    "title": "Maximum Candies Allocated to K Children",
    "category": "IX. Binary Search Patterns",
    "pattern": "Pattern 55: Binary Search - On Answer / Condition Function",
    "url": "https://leetcode.com/problems/maximum-candies-allocated-to-k-children/",
    "difficulty": "hard",
    "content": "# Maximum Candies Allocated to K Children\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Candies Allocated to K Children](https://leetcode.com/problems/maximum-candies-allocated-to-k-children/)\n\n**Category:** IX. Binary Search Patterns\n**Pattern:** Pattern 55: Binary Search - On Answer / Condition Function",
    "description": "Study Maximum Candies Allocated to K Children using the Pattern 55: Binary Search - On Answer / Condition Function approach.",
    "has_content": false
  },
  {
    "id": "problem_2290",
    "number": 2290,
    "title": "Minimum Obstacle Removal to Reach Corner",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "url": "https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/",
    "difficulty": "hard",
    "content": "# Minimum Obstacle Removal to Reach Corner\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Obstacle Removal to Reach Corner](https://leetcode.com/problems/minimum-obstacle-removal-to-reach-corner/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "description": "Study Minimum Obstacle Removal to Reach Corner using the Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_2296",
    "number": 2296,
    "title": "Design a Text Editor",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/design-a-text-editor/",
    "difficulty": "hard",
    "content": "# Design a Text Editor\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Design a Text Editor](https://leetcode.com/problems/design-a-text-editor/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Design a Text Editor using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_2321",
    "number": 2321,
    "title": "Maximum Score Of Spliced Array",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray)",
    "url": "https://leetcode.com/problems/maximum-score-of-spliced-array/",
    "difficulty": "hard",
    "content": "# Maximum Score Of Spliced Array\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Score Of Spliced Array](https://leetcode.com/problems/maximum-score-of-spliced-array/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray)",
    "description": "Study Maximum Score Of Spliced Array using the Pattern 27: DP - 1D Array (Kadane's Algorithm for Max/Min Subarray) approach.",
    "has_content": false
  },
  {
    "id": "problem_2326",
    "number": 2326,
    "title": "Spiral Matrix IV",
    "category": "XIII. Array/Matrix Manipulation Patterns",
    "pattern": "Pattern 75: Array/Matrix - Spiral Traversal",
    "url": "https://leetcode.com/problems/spiral-matrix-iv/",
    "difficulty": "hard",
    "content": "# Spiral Matrix IV\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Spiral Matrix IV](https://leetcode.com/problems/spiral-matrix-iv/)\n\n**Category:** XIII. Array/Matrix Manipulation Patterns\n**Pattern:** Pattern 75: Array/Matrix - Spiral Traversal",
    "description": "Study Spiral Matrix IV using the Pattern 75: Array/Matrix - Spiral Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_2336",
    "number": 2336,
    "title": "Smallest Number in Infinite Set",
    "category": "XV. Design Patterns",
    "pattern": "Pattern 89: Design (General/Specific)",
    "url": "https://leetcode.com/problems/smallest-number-in-infinite-set/",
    "difficulty": "hard",
    "content": "# Smallest Number in Infinite Set\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Smallest Number in Infinite Set](https://leetcode.com/problems/smallest-number-in-infinite-set/)\n\n**Category:** XV. Design Patterns\n**Pattern:** Pattern 89: Design (General/Specific)",
    "description": "Study Smallest Number in Infinite Set using the Pattern 89: Design (General/Specific) approach.",
    "has_content": false
  },
  {
    "id": "problem_2337",
    "number": 2337,
    "title": "Move Pieces to Obtain a String",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 4: Two Pointers - In-place Array Modification",
    "url": "https://leetcode.com/problems/move-pieces-to-obtain-a-string/",
    "difficulty": "hard",
    "content": "---\n### **2337. Move Pieces to Obtain a String**\n**Link to Problem:** [https://leetcode.com/problems/move-pieces-to-obtain-a-string/](https://leetcode.com/problems/move-pieces-to-obtain-a-string/)\n\n#### **1. Problem Statement**\nYou are given two strings, `start` and `target`, of equal length, consisting of characters 'L', 'R', and '_'. An 'L' can only move left into an empty space ('_'), and an 'R' can only move right into an empty space. The pieces can't jump over each other. Determine if it's possible to transform `start` into `target` by making any number of valid moves.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward idea is to first verify the fundamental invariants of the problem. Since pieces ('L' and 'R') cannot jump over each other, their relative order must be identical in both the `start` and `target` strings. For example, if `start` has the pieces \"LRL\" in that order, `target` must also have \"LRL\" as its sequence of pieces.\n\nA simple way to check this is to extract all non-`_` characters from both strings and see if the resulting sequences are identical. If they are, we then need to check if each individual move is valid. We can create a list of pieces and their original indices for both strings and then compare them one by one.\n\nThe logic is:\n1.  Filter out the '_' characters from `start` and `target` to get the sequences of pieces. If these sequences are not identical, return `False`.\n2.  If the sequences match, gather the index of each piece in `start` and `target`.\n3.  For each corresponding piece (e.g., the first 'L' in `start` and the first 'L' in `target`), check if the move is valid:\n    *   If the piece is 'L', its index in `start` must be greater than or equal to its index in `target`.\n    *   If the piece is 'R', its index in `start` must be less than or equal to its index in `target`.\n4.  If all corresponding pieces satisfy these conditions, return `True`.\n\n**Python Code:**\n```python\ndef canChange_brute_force(start: str, target: str) -> bool:\n    # Step 1: Check if the sequence of pieces is the same.\n    # By filtering out the '_' characters, we ensure the relative order of 'L' and 'R' is preserved.\n    if start.replace('_', '') != target.replace('_', ''):\n        return False\n\n    # Step 2: Gather indices for each piece in both strings.\n    start_L_indices = [i for i, char in enumerate(start) if char == 'L']\n    start_R_indices = [i for i, char in enumerate(start) if char == 'R']\n    \n    target_L_indices = [i for i, char in enumerate(target) if char == 'L']\n    target_R_indices = [i for i, char in enumerate(target) if char == 'R']\n\n    # Step 3: Check move validity for every 'L' piece.\n    # The k-th 'L' in start must correspond to the k-th 'L' in target.\n    # An 'L' can only move left, so its start index must be >= its target index.\n    for i in range(len(start_L_indices)):\n        if start_L_indices[i] < target_L_indices[i]:\n            return False\n            \n    # Step 4: Check move validity for every 'R' piece.\n    # An 'R' can only move right, so its start index must be <= its target index.\n    for i in range(len(start_R_indices)):\n        if start_R_indices[i] > target_R_indices[i]:\n            return False\n\n    # If all checks pass, the transformation is possible.\n    return True\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**, where N is the length of the strings. The `replace` operations take O(N), and the list comprehensions and loops each iterate through the strings or the derived lists once, resulting in a linear time complexity.\n*   **Space Complexity: O(N)**. In the worst case, the strings consist of only 'L's and 'R's, so the lists of indices (`start_L_indices`, etc.) would store up to N indices, leading to linear space usage.\n\n---\n### **3. Optimized Approach: Two Pointers - Corresponding Scan**\n**Intuition:**\nThe brute-force approach works, but it requires multiple passes over the string and uses extra space to store indices. We can optimize this by processing both strings in a single pass using two pointers. This avoids the need for intermediate data structures.\n\nLet's use one pointer, `p1`, for the `start` string and another, `p2`, for the `target` string. Our goal is to find the *k*-th piece in `start` and the *k*-th piece in `target` simultaneously and compare them.\n\nThe logic is as follows:\n1.  Initialize `p1 = 0` and `p2 = 0`.\n2.  Use a loop that continues as long as we have characters to process in either string.\n3.  Inside the loop, advance `p1` until it points to a non-`_` character in `start`.\n4.  Similarly, advance `p2` until it points to a non-`_` character in `target`.\n5.  Now, we have found a corresponding pair of pieces (or reached the end of one or both strings).\n    *   **Check Character Match:** The pieces must be the same (`start[p1] == target[p2]`). If not, the relative order is broken. Return `False`. (Note: This also handles the case where one string runs out of pieces before the other, as the characters being compared will be different).\n    *   **Check Move Validity:**\n        *   If the character is `'L'`, `p1` must be `>= p2`. An 'L' cannot move to the right.\n        *   If the character is `'R'`, `p1` must be `<= p2`. An 'R' cannot move to the left.\n    *   If any check fails, return `False`.\n6.  If the checks pass, we've successfully validated this pair of pieces. Move both pointers forward (`p1++`, `p2++`) to search for the next pair.\n7.  If the loop completes without returning `False`, it means all pieces were matched and all moves were valid. Return `True`.\n\n**Example:** `start = \"_L_R_\"` , `target = \"L__R_\"`\n- `p1=0`, `p2=0`\n- **Find first piece:** Advance `p1` to 1 (`start[1]=='L'`). `p2` is already at 0 (`target[0]=='L'`).\n- **Compare:** Pieces match ('L'). `p1(1) >= p2(0)` is true for 'L'. All good. Advance both. `p1=2, p2=1`.\n- **Find second piece:** Advance `p1` to 3 (`start[3]=='R'`). Advance `p2` to 3 (`target[3]=='R'`).\n- **Compare:** Pieces match ('R'). `p1(3) <= p2(3)` is true for 'R'. All good. Advance both. `p1=4, p2=4`.\n- **End:** Both pointers scan to the end of the strings. The loop finishes. Return `True`.\n\n**Python Code:**\n```python\ndef canChange(start: str, target: str) -> bool:\n    n = len(start)\n    p1, p2 = 0, 0\n\n    # The two pointers, p1 and p2, will scan through start and target respectively.\n    while p1 < n or p2 < n:\n        # Core of the two-pointer pattern: advance each pointer to the next meaningful element.\n        # Here, a meaningful element is a non-'_' character.\n        while p1 < n and start[p1] == '_':\n            p1 += 1\n        while p2 < n and target[p2] == '_':\n            p2 += 1\n\n        # If we've reached the end of both strings, all pieces matched successfully.\n        if p1 == n and p2 == n:\n            return True\n        # If one pointer reaches the end but the other hasn't, the number of pieces is different.\n        if p1 == n or p2 == n:\n            return False\n\n        # Check 1: The sequence of pieces must be the same.\n        # If the characters at the pointers don't match, the transformation is impossible.\n        if start[p1] != target[p2]:\n            return False\n\n        # Check 2: The move must be valid based on the piece type.\n        # For 'L', it can only move left.\n        if start[p1] == 'L':\n            if p1 < p2:\n                return False\n        # For 'R', it can only move right.\n        elif start[p1] == 'R':\n            if p1 > p2:\n                return False\n        \n        # This pair of pieces is valid, so move to the next ones.\n        p1 += 1\n        p2 += 1\n        \n    return True\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**. Each pointer, `p1` and `p2`, traverses its respective string exactly once from left to right. Therefore, the overall time complexity is linear.\n*   **Space Complexity: O(1)**. We only use a few variables (`p1`, `p2`, `n`) to store pointers and the length. No extra space proportional to the input size is used, which is a significant improvement over the previous approach.\n\n---\n#### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers** pattern, specifically for comparing or verifying properties between two sequences. The problem's constraints—that pieces cannot cross each other—imply that the *relative order* of the pieces must be conserved.\n\nThe key signal for this pattern is the need to check **corresponding elements** across two arrays or strings. The first 'L' in `start` must map to the first 'L' in `target`, the second 'R' to the second 'R', and so on. A naive approach might involve searching for each element, leading to inefficiency. The Two Pointers technique elegantly solves this by creating a synchronized, single-pass traversal. Pointers `p1` and `p2` effectively track the *k*-th piece in each string simultaneously, allowing for direct comparison of their types and positions in O(N) time and O(1) space. Whenever a problem requires you to verify that one sequence can be transformed into another while maintaining the relative order of key elements, the Two Pointers pattern should be your first thought.",
    "description": "Study Move Pieces to Obtain a String using the Pattern 4: Two Pointers - In-place Array Modification approach.",
    "has_content": true
  },
  {
    "id": "problem_2390",
    "number": 2390,
    "title": "Removing Stars From a String",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 5: Two Pointers - String Comparison",
    "url": "https://leetcode.com/problems/removing-stars-from-a-string/",
    "difficulty": "hard",
    "content": "---\n### **2390. Removing Stars From a String**\n**Link to Problem:** [https://leetcode.com/problems/removing-stars-from-a-string/](https://leetcode.com/problems/removing-stars-from-a-string/)\n\n#### **1. Problem Statement**\nYou are given a string `s` which contains lowercase English letters and stars (`*`). The task is to process the string by removing stars. Each star removes the closest non-star character to its immediate left. The final goal is to return the resulting string after all stars have been processed.\n\n#### **2. Brute Force Approach (Using a Stack)**\n**Intuition:**\nThe most straightforward way to think about this problem is to simulate the process directly. As we iterate through the string, we are essentially building a new, clean string. When we encounter a regular character, we add it to our result. When we see a star, it acts like a \"backspace\" command, deleting the last character we added.\n\nThis \"Last-In, First-Out\" (LIFO) behavior is a perfect use case for a stack. We can iterate through the input string `s`, character by character:\n1. If the character is a letter, we `push` it onto our stack.\n2. If the character is a star, we `pop` the last letter from the stack.\n\nAfter iterating through the entire string, the characters remaining in the stack, when joined together, will form our final string.\n\n**Python Code:**\n```python\nclass Solution:\n    def removeStars(self, s: str) -> str:\n        # A list in Python can be used as a stack.\n        # 'append' is our 'push' operation, and 'pop' is our 'pop' operation.\n        char_stack = []\n        \n        # Iterate through each character in the input string.\n        for char in s:\n            if char == '*':\n                # If it's a star and the stack is not empty, it means there's a character to its left to remove.\n                # The 'closest' one is the last one we added, which is at the top of the stack.\n                if char_stack:\n                    char_stack.pop()\n            else:\n                # If it's a regular character, add it to our result stack.\n                char_stack.append(char)\n        \n        # The stack now contains all the characters for the final string in the correct order.\n        # We join them to form the final output string.\n        return \"\".join(char_stack)\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    This is because we iterate through the input string `s` of length `N` exactly once. The `append` and `pop` operations on a Python list (used as a stack) are, on average, O(1).\n\n*   **Space Complexity: O(N)**\n    In the worst-case scenario (a string with no stars), our `char_stack` will grow to hold all `N` characters of the input string. Therefore, the space required is proportional to the input size.\n\n#### **3. Optimized Approach: Two Pointers - String Comparison**\n**Intuition:**\nWhile the stack-based approach is efficient in time, it requires extra space. We can optimize the space by using a **Two Pointer** technique, specifically the \"slow and fast pointer\" variant. This pattern is ideal for problems where you need to produce a \"compacted\" version of an array or string in-place.\n\nThe core idea is to use one pointer to read the string and another to write the result.\n1.  **`read_ptr` (Fast Pointer):** This pointer iterates through every character of the original string `s` from left to right. Its job is to inspect each character.\n2.  **`write_ptr` (Slow Pointer):** This pointer keeps track of the end of our \"valid\" result string. It only moves forward when we add a new character to the result.\n\nThe process works as follows: we create a character array from the input string (since Python strings are immutable). The `read_ptr` scans this array.\n*   When `s[read_ptr]` is a letter, we copy it to the position `s[write_ptr]` and then increment `write_ptr`.\n*   When `s[read_ptr]` is a star, it means we need to \"delete\" the last character we wrote. We accomplish this by simply moving the `write_ptr` back by one.\n\nLet's walk through an example: `s = \"le*t\"`\n`char_array = ['l', 'e', '*', 't']`\n`write_ptr = 0`\n\n1.  `read_ptr` sees 'l'. It's a letter.\n    *   `char_array[write_ptr]` becomes 'l'. (`char_array` is now `['l', ...]`)\n    *   Increment `write_ptr` to `1`.\n2.  `read_ptr` sees 'e'. It's a letter.\n    *   `char_array[write_ptr]` becomes 'e'. (`char_array` is now `['l', 'e', ...]`)\n    *   Increment `write_ptr` to `2`.\n3.  `read_ptr` sees '*'. It's a star.\n    *   Decrement `write_ptr` to `1`. This effectively \"erases\" the 'e' we just wrote.\n4.  `read_ptr` sees 't'. It's a letter.\n    *   `char_array[write_ptr]` becomes 't'. (`char_array` is now `['l', 't', ...]`)\n    *   Increment `write_ptr` to `2`.\n\nAfter the loop, the final string is the content of `char_array` up to the `write_ptr` position, which is `['l', 't']`. Result: \"lt\".\n\n**Python Code:**\n```python\nclass Solution:\n    def removeStars(self, s: str) -> str:\n        # Since strings are immutable in Python, we convert the string to a list of characters\n        # to perform in-place modifications.\n        res_chars = list(s)\n        \n        # The 'write_ptr' (slow pointer) tracks the position for the next valid character.\n        write_ptr = 0\n        \n        # The 'read_ptr' (fast pointer) iterates through the entire list.\n        for read_ptr in range(len(res_chars)):\n            # The 'comparison' is checking if the current character is a star or not.\n            if res_chars[read_ptr] != '*':\n                # If it's a letter, place it at the write_ptr's location.\n                res_chars[write_ptr] = res_chars[read_ptr]\n                # Move the write pointer forward to accept the next character.\n                write_ptr += 1\n            else:\n                # If it's a star, we effectively \"delete\" the last written character\n                # by moving the write pointer back.\n                # We also ensure it doesn't go negative if the string starts with a star.\n                if write_ptr > 0:\n                    write_ptr -= 1\n        \n        # The final string is the slice of the list from the beginning up to the write_ptr.\n        return \"\".join(res_chars[:write_ptr])\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(N)**\n    The `read_ptr` traverses the entire string of length `N` exactly once. All operations inside the loop are O(1).\n\n*   **Space Complexity: O(N)**\n    In Python, we must create a list of characters from the string, which takes O(N) space. However, the algorithm itself uses constant *auxiliary* space (just two integer pointers). In languages with mutable strings or character arrays (like C++ or Java), this approach would achieve **O(1) auxiliary space complexity**, which is the primary advantage over the stack method.\n\n#### **4. Pattern Connection**\nThis problem is a classic example of the **Two Pointers (Slow and Fast)** pattern applied to string/array processing. While the pattern name provided was \"String Comparison\", it's more accurately a \"String Modification\" or \"Compaction\" problem.\n\nThe key signals for this pattern are:\n1.  **Processing a single sequence:** The problem involves iterating through a single array or string.\n2.  **Producing a modified/filtered result:** The goal is to remove or change elements to create a \"compacted\" version of the original sequence.\n3.  **In-place potential:** The result is always guaranteed to be shorter than or equal to the original length. This allows the result to be built over the original input's memory space, as the `write_ptr` will never overtake the `read_ptr`.\n\nThe \"comparison\" in this context is the decision made at each step by the fast pointer: \"Is this character a star or a letter?\". Based on this comparison, the slow pointer either advances (to keep a character) or retreats (to remove one). This technique is fundamental and appears in many other problems, such as \"Remove Duplicates from Sorted Array\" and \"Move Zeroes\", where a slow pointer manages the final state of the array while a fast pointer explores it. Recognizing this structure is key to solving a wide range of array manipulation problems efficiently.",
    "description": "Study Removing Stars From a String using the Pattern 5: Two Pointers - String Comparison approach.",
    "has_content": true
  },
  {
    "id": "problem_2392",
    "number": 2392,
    "title": "Build a Matrix With Conditions",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "url": "https://leetcode.com/problems/build-a-matrix-with-conditions/",
    "difficulty": "hard",
    "content": "# Build a Matrix With Conditions\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Build a Matrix With Conditions](https://leetcode.com/problems/build-a-matrix-with-conditions/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm)",
    "description": "Study Build a Matrix With Conditions using the Pattern 21: Graph BFS - Topological Sort (Kahn's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_2402",
    "number": 2402,
    "title": "Meeting Rooms III",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "url": "https://leetcode.com/problems/meeting-rooms-iii/",
    "difficulty": "hard",
    "content": "# Meeting Rooms III\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Meeting Rooms III](https://leetcode.com/problems/meeting-rooms-iii/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue)",
    "description": "Study Meeting Rooms III using the Pattern 40: Heap - Scheduling / Minimum Cost (Greedy with Priority Queue) approach.",
    "has_content": false
  },
  {
    "id": "problem_2406",
    "number": 2406,
    "title": "Divide Intervals Into Minimum Number of Groups",
    "category": "VIII. Greedy Patterns",
    "pattern": "Pattern 48: Greedy - Interval Merging/Scheduling",
    "url": "https://leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/",
    "difficulty": "hard",
    "content": "# Divide Intervals Into Minimum Number of Groups\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Divide Intervals Into Minimum Number of Groups](https://leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/)\n\n**Category:** VIII. Greedy Patterns\n**Pattern:** Pattern 48: Greedy - Interval Merging/Scheduling",
    "description": "Study Divide Intervals Into Minimum Number of Groups using the Pattern 48: Greedy - Interval Merging/Scheduling approach.",
    "has_content": false
  },
  {
    "id": "problem_2407",
    "number": 2407,
    "title": "Longest Increasing Subsequence II",
    "category": "V. Dynamic Programming (DP) Patterns",
    "pattern": "Pattern 36: DP - Longest Increasing Subsequence (LIS)",
    "url": "https://leetcode.com/problems/longest-increasing-subsequence-ii/",
    "difficulty": "hard",
    "content": "# Longest Increasing Subsequence II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Longest Increasing Subsequence II](https://leetcode.com/problems/longest-increasing-subsequence-ii/)\n\n**Category:** V. Dynamic Programming (DP) Patterns\n**Pattern:** Pattern 36: DP - Longest Increasing Subsequence (LIS)",
    "description": "Study Longest Increasing Subsequence II using the Pattern 36: DP - Longest Increasing Subsequence (LIS) approach.",
    "has_content": false
  },
  {
    "id": "problem_2458",
    "number": 2458,
    "title": "Height of Binary Tree After Subtree Removal Queries",
    "category": "III. Tree Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "url": "https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/",
    "difficulty": "hard",
    "content": "# Height of Binary Tree After Subtree Removal Queries\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Height of Binary Tree After Subtree Removal Queries](https://leetcode.com/problems/height-of-binary-tree-after-subtree-removal-queries/)\n\n**Category:** III. Tree Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 15: Tree DFS - Recursive Postorder Traversal",
    "description": "Study Height of Binary Tree After Subtree Removal Queries using the Pattern 15: Tree DFS - Recursive Postorder Traversal approach.",
    "has_content": false
  },
  {
    "id": "problem_2461",
    "number": 2461,
    "title": "Maximum Sum of Distinct Subarrays With Length K",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/",
    "difficulty": "hard",
    "content": "# Maximum Sum of Distinct Subarrays With Length K\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Sum of Distinct Subarrays With Length K](https://leetcode.com/problems/maximum-sum-of-distinct-subarrays-with-length-k/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Maximum Sum of Distinct Subarrays With Length K using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_2516",
    "number": 2516,
    "title": "Take K of Each Character From Left and Right",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/",
    "difficulty": "hard",
    "content": "# Take K of Each Character From Left and Right\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Take K of Each Character From Left and Right](https://leetcode.com/problems/take-k-of-each-character-from-left-and-right/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Take K of Each Character From Left and Right using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_2558",
    "number": 2558,
    "title": "Take Gifts From the Richest Pile",
    "category": "VI. Heap (Priority Queue) Patterns",
    "pattern": "Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "url": "https://leetcode.com/problems/take-gifts-from-the-richest-pile/",
    "difficulty": "hard",
    "content": "# Take Gifts From the Richest Pile\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Take Gifts From the Richest Pile](https://leetcode.com/problems/take-gifts-from-the-richest-pile/)\n\n**Category:** VI. Heap (Priority Queue) Patterns\n**Pattern:** Pattern 37: Heap - Top K Elements (Selection/Frequency)",
    "description": "Study Take Gifts From the Richest Pile using the Pattern 37: Heap - Top K Elements (Selection/Frequency) approach.",
    "has_content": false
  },
  {
    "id": "problem_2577",
    "number": 2577,
    "title": "Minimum Time to Visit a Cell In a Grid",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "url": "https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/",
    "difficulty": "hard",
    "content": "# Minimum Time to Visit a Cell In a Grid\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Minimum Time to Visit a Cell In a Grid](https://leetcode.com/problems/minimum-time-to-visit-a-cell-in-a-grid/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "description": "Study Minimum Time to Visit a Cell In a Grid using the Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_2762",
    "number": 2762,
    "title": "Continuous Subarrays",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/continuous-subarrays/",
    "difficulty": "hard",
    "content": "# Continuous Subarrays\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Continuous Subarrays](https://leetcode.com/problems/continuous-subarrays/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Continuous Subarrays using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_2779",
    "number": 2779,
    "title": "Maximum Beauty of an Array After Applying Operation",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/maximum-beauty-of-an-array-after-applying-operation/",
    "difficulty": "hard",
    "content": "# Maximum Beauty of an Array After Applying Operation\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Beauty of an Array After Applying Operation](https://leetcode.com/problems/maximum-beauty-of-an-array-after-applying-operation/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Maximum Beauty of an Array After Applying Operation using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_2812",
    "number": 2812,
    "title": "Find the Safest Path in a Grid",
    "category": "IV. Graph Traversal Patterns (DFS & BFS)",
    "pattern": "Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "url": "https://leetcode.com/problems/find-the-safest-path-in-a-grid/",
    "difficulty": "hard",
    "content": "# Find the Safest Path in a Grid\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find the Safest Path in a Grid](https://leetcode.com/problems/find-the-safest-path-in-a-grid/)\n\n**Category:** IV. Graph Traversal Patterns (DFS & BFS)\n**Pattern:** Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm)",
    "description": "Study Find the Safest Path in a Grid using the Pattern 23: Graph - Shortest Path (Dijkstra's Algorithm) approach.",
    "has_content": false
  },
  {
    "id": "problem_2938",
    "number": 2938,
    "title": "Separate Black and White Balls",
    "category": "I. Two Pointer Patterns",
    "pattern": "Pattern 4: Two Pointers - In-place Array Modification",
    "url": "https://leetcode.com/problems/separate-black-and-white-balls/",
    "difficulty": "hard",
    "content": "---\n### **2938. Separate Black and White Balls**\n**Link to Problem:** [https://leetcode.com/problems/separate-black-and-white-balls/](https://leetcode.com/problems/separate-black-and-white-balls/)\n\n#### **1. Problem Statement**\nGiven a binary string `s` representing a row of balls where '0' is a white ball and '1' is a black ball, we need to find the minimum number of swaps between *adjacent* balls to group all white balls on the left and all black balls on the right.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to think about this is to consider the final, desired state. In the end, all '0's will be on the left, and all '1's on the right. This means that every black ball ('1') must eventually move to the right of every white ball ('0').\n\nThe number of swaps for a single ball to move past another is one. Therefore, for any given black ball, the number of swaps it must perform is equal to the number of white balls currently to its right. By summing this value for every black ball in the string, we can find the total minimum swaps.\n\nThe brute-force logic is as follows:\n1. Initialize a `total_swaps` counter to zero.\n2. Iterate through the string from left to right with a pointer `i`.\n3. If we find a black ball (`s[i] == '1'`):\n    a. We know this ball must move past all white balls to its right.\n    b. Start a second, nested loop with a pointer `j` from `i + 1` to the end of the string.\n    c. For each white ball we find (`s[j] == '0'`), increment `total_swaps`.\n4. After the loops complete, `total_swaps` will hold the minimum number of swaps.\n\n**Python Code:**\n```python\nclass Solution:\n    def minimumSteps(self, s: str) -> int:\n        \"\"\"\n        Brute-force solution to calculate minimum swaps.\n        \n        For each black ball ('1'), we count how many white balls ('0')\n        appear to its right. Each such white ball represents one\n        adjacent swap that the black ball must eventually make.\n        \"\"\"\n        n = len(s)\n        total_swaps = 0\n        \n        # Outer loop to find each black ball ('1')\n        for i in range(n):\n            if s[i] == '1':\n                # Inner loop to count white balls ('0') to the right\n                for j in range(i + 1, n):\n                    if s[j] == '0':\n                        # This '1' at index i must be swapped past the '0' at index j\n                        total_swaps += 1\n                        \n        return total_swaps\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(n²)**\n    This is due to the nested loops. In the worst-case scenario (a string like \"111...000...\"), the outer loop runs `n/2` times, and the inner loop also runs approximately `n/2` times for each of those, leading to a quadratic time complexity.\n\n*   **Space Complexity: O(1)**\n    We only use a few variables (`n`, `total_swaps`, `i`, `j`) for storage, which does not depend on the input size.\n\n### **3. Optimized Approach: Two Pointers - In-place Array Modification**\n**Intuition:**\nThe brute-force O(n²) approach is inefficient because for every black ball, we rescan a large portion of the string. We can optimize this by realizing we are essentially trying to partition the string into a `[whites, blacks]` configuration. This partitioning task is a classic signal for the **Two Pointers** pattern, specifically with pointers starting at opposite ends.\n\nLet's set up two pointers: `left` starting at index 0 and `right` starting at the last index.\n- The `left` pointer's job is to scan forward and find the first \"out-of-place\" black ball (`1`). An ideal left section should only contain white balls (`0`).\n- The `right` pointer's job is to scan backward and find the first \"out-of-place\" white ball (`0`). An ideal right section should only contain black balls (`1`).\n\nWhen `left` finds a `1` and `right` finds a `0` (and `left < right`), we've identified a pair that needs to be swapped. The crucial insight is calculating the swap cost. To move the white ball from `right` to the `left` position requires `right - left` adjacent swaps. After accounting for this cost, we can conceptually consider them swapped and move both pointers inward to find the next misplaced pair.\n\nLet's walk through an example: `s = \"10110\"`\n1.  Initialize `left = 0`, `right = 4`, `swaps = 0`.\n2.  `s[left]` is '1' (misplaced) and `s[right]` is '0' (misplaced).\n3.  We've found a pair to swap. The cost to move the '0' at index 4 to the '1's spot at index 0 is `right - left = 4 - 0 = 4`.\n4.  Add this cost: `swaps = 4`.\n5.  Move pointers inward: `left` becomes 1, `right` becomes 3.\n6.  Now, `s[left]` is '0'. This is a white ball where it should be. The `left` pointer's job is done for this position. Increment `left` to 2.\n7.  `s[left]` is now '1' (misplaced). `s[right]` is '1'. A black ball on the right is fine. Decrement `right` to 2.\n8.  Now `left = 2` and `right = 2`. The condition `left < right` is no longer true, so the loop terminates.\n9.  The final result is `4`.\n\nThis approach ensures that each element is visited only once by either the `left` or `right` pointer, leading to a linear time solution.\n\n**Python Code:**\n```python\nclass Solution:\n    def minimumSteps(self, s: str) -> int:\n        \"\"\"\n        Optimized solution using the Two Pointers pattern.\n        \n        We use two pointers, one at each end, to find misplaced balls.\n        `left` seeks a black ball ('1') from the start.\n        `right` seeks a white ball ('0') from the end.\n        \n        When a misplaced pair is found, we calculate the distance between them,\n        which represents the number of adjacent swaps needed to move the\n        white ball to the left pointer's position.\n        \"\"\"\n        left, right = 0, len(s) - 1\n        swaps = 0\n        \n        # Pointers move towards each other until they cross\n        while left < right:\n            # Find the first black ball from the left that is out of place\n            if s[left] == '0':\n                left += 1\n                continue\n            \n            # Find the first white ball from the right that is out of place\n            if s[right] == '1':\n                right -= 1\n                continue\n            \n            # At this point, s[left] == '1' and s[right] == '0'.\n            # This is a misplaced pair. We need to swap them.\n            # The number of adjacent swaps to move the '0' at `right`\n            # to the `left` position is their distance.\n            swaps += (right - left)\n            \n            # Move pointers inward after the conceptual swap\n            left += 1\n            right -= 1\n            \n        return swaps\n```\n**Complexity Analysis:**\n\n*   **Time Complexity: O(n)**\n    The `left` pointer only ever moves to the right, and the `right` pointer only ever moves to the left. In each step of the `while` loop, at least one pointer moves. Therefore, each element of the string is visited at most once, resulting in a linear time complexity.\n\n*   **Space Complexity: O(1)**\n    The algorithm uses a constant amount of extra space for the two pointers and the swap counter, regardless of the input string's size.\n\n### **4. Pattern Connection**\nThis problem is a quintessential example of the **Two Pointers - In-place Array Modification** pattern (also known as the partitioning pattern). The key characteristics that signal this pattern are:\n\n1.  **Partitioning Requirement:** The goal is to segregate elements into two distinct groups (white balls and black balls) in a contiguous manner.\n2.  **Opposite Ends:** The most efficient way to achieve this partitioning is by working from the outside in. One pointer (`left`) establishes the boundary of the first group, while the other (`right`) establishes the boundary of the second group.\n3.  **In-place Logic:** Although we don't physically modify the string, the logic simulates an in-place partitioning. The pointers find elements that violate their section's rule (`1` in the white section, `0` in the black section) and perform a \"swap\". In this specific problem, instead of a literal swap, we calculate the swap *cost*.\n\nWhenever you encounter a problem that requires reordering an array or string to group elements with a certain property together (e.g., move all zeroes to the end, sort an array of `0`s, `1`s, and `2`s), the two-pointers-from-opposite-ends technique should be one of the first patterns you consider. It provides an elegant and efficient O(n) solution by avoiding the redundant work inherent in nested-loop approaches.",
    "description": "Study Separate Black and White Balls using the Pattern 4: Two Pointers - In-place Array Modification approach.",
    "has_content": true
  },
  {
    "id": "problem_2981",
    "number": 2981,
    "title": "Find Longest Special Substring That Occurs Thrice I",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/",
    "difficulty": "hard",
    "content": "# Find Longest Special Substring That Occurs Thrice I\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find Longest Special Substring That Occurs Thrice I](https://leetcode.com/problems/find-longest-special-substring-that-occurs-thrice-i/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Find Longest Special Substring That Occurs Thrice I using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_2985",
    "number": 2985,
    "title": "Calculate Compressed Mean",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 8: Sliding Window - Fixed Size (Subarray Calculation)",
    "url": "https://leetcode.com/problems/calculate-compressed-mean/",
    "difficulty": "hard",
    "content": "---\n### **2985. Calculate Compressed Mean**\n**Link to Problem:** [https://leetcode.com/problems/calculate-compressed-mean/](https://leetcode.com/problems/calculate-compressed-mean/)\n\n#### **1. Problem Statement**\nGiven an array of integers `nums` and a window size `k`, the task is to calculate the \"compressed mean\" for every contiguous subarray of length `k`. The compressed mean is defined as the integer division of the subarray's sum by its length (`sum // k`). The final output should be an array containing these compressed means for each subarray.\n\n#### **2. Brute Force Approach**\n**Intuition:**\nThe most straightforward way to solve this is to follow the problem description literally. We can iterate through the array, and for each possible starting position of a subarray, we can generate that subarray, calculate its sum, compute the compressed mean, and store the result.\n\nThe process is as follows:\n1.  Initialize an empty list called `result` to store our answers.\n2.  Loop through the `nums` array with an index `i` from `0` up to the last possible starting point for a subarray of size `k` (which is `len(nums) - k`).\n3.  In each iteration, extract the subarray `nums[i : i+k]`.\n4.  Calculate the sum of this subarray.\n5.  Perform integer division of the sum by `k`.\n6.  Append this value to the `result` list.\n7.  After the loop finishes, return the `result` list.\n\n**Python Code:**\n```python\nfrom typing import List\n\nclass Solution:\n    def compressedMean(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        # The number of subarrays of size k is n - k + 1\n        num_subarrays = n - k + 1\n        \n        # If the array is too small to form a window of size k, return an empty list\n        if num_subarrays <= 0:\n            return []\n            \n        result = []\n        \n        # Iterate through each possible starting index of a subarray\n        for i in range(num_subarrays):\n            # For each starting index 'i', consider the subarray of length 'k'\n            # Slicing creates a new temporary list for the window\n            window = nums[i : i + k]\n            \n            # Calculate the sum of the current window from scratch\n            window_sum = sum(window)\n            \n            # Calculate the compressed mean and append to our results\n            compressed_mean = window_sum // k\n            result.append(compressed_mean)\n            \n        return result\n\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(n * k)`\n    This is because the outer loop runs `n - k + 1` times (which is `O(n)`). Inside the loop, `sum(window)` needs to iterate over `k` elements to calculate the sum. Therefore, the total time is proportional to `n * k`.\n\n*   **Space Complexity:** `O(n)`\n    We create a `result` array of size `n - k + 1`. In the worst case (e.g., `k=1`), this is `O(n)`. We are not counting the space used for the `window` slice inside the loop, which would be `O(k)`, as it is temporary and reused. The dominant factor is the output array.\n\n### **3. Optimized Approach: [Pattern 8: Sliding Window - Fixed Size (Subarray Calculation)]**\n**Intuition:**\nThe brute-force method is inefficient because it repeatedly calculates the sum of overlapping elements. For example, when calculating the sum for `nums[0:k]` and then `nums[1:k+1]`, we are re-summing `k-1` elements. The key insight of the sliding window pattern is to avoid this redundant work.\n\nWe can maintain a \"window\" of size `k` that slides across the array. Instead of re-calculating the sum of the entire window each time it moves, we can update the sum in constant time. When the window slides one position to the right:\n1.  The element at the far-left edge of the old window is removed.\n2.  The new element at the far-right edge of the new window is added.\n\nBy subtracting the outgoing element and adding the incoming element to our running sum, we get the sum of the new window in just two operations.\n\n**Example Walkthrough:** `nums = [2, 4, 6, 8]`, `k = 2`\n\n1.  **Initial Window:** `[2, 4]`.\n    *   Calculate the initial `current_sum = 2 + 4 = 6`.\n    *   `mean = 6 // 2 = 3`. Add `3` to `result`. `result = [3]`.\n2.  **Slide the Window:** The window moves from `[2, 4]` to `[4, 6]`.\n    *   The element `2` (at index 0) leaves the window.\n    *   The element `6` (at index 2) enters the window.\n    *   Update the sum: `current_sum = 6 - 2 + 6 = 10`.\n    *   `mean = 10 // 2 = 5`. Add `5` to `result`. `result = [3, 5]`.\n3.  **Slide Again:** The window moves from `[4, 6]` to `[6, 8]`.\n    *   The element `4` (at index 1) leaves the window.\n    *   The element `8` (at index 3) enters the window.\n    *   Update the sum: `current_sum = 10 - 4 + 8 = 14`.\n    *   `mean = 14 // 2 = 7`. Add `7` to `result`. `result = [3, 5, 7]`.\n4.  The loop finishes. Return `[3, 5, 7]`.\n\nThis approach processes each element of the array a constant number of times, leading to a linear time complexity.\n\n**Python Code:**\n```python\nfrom typing import List\n\nclass Solution:\n    def compressedMean(self, nums: List[int], k: int) -> List[int]:\n        n = len(nums)\n        \n        # Edge case: if the array is smaller than the window size, no subarrays can be formed.\n        if n < k:\n            return []\n            \n        result = []\n        \n        # --- Step 1: Initialize the first window ---\n        # Calculate the sum of the very first window of size k.\n        current_sum = sum(nums[0:k])\n        \n        # Calculate and store the compressed mean for this first window.\n        result.append(current_sum // k)\n        \n        # --- Step 2: Slide the window across the rest of the array ---\n        # We start the loop from the k-th element, as this is the first\n        # element that will \"enter\" our sliding window.\n        for i in range(k, n):\n            # The window slides one position to the right.\n            # `nums[i]` is the new element entering the window.\n            # `nums[i-k]` is the old element that's leaving the window from the left.\n            \n            # Update the sum in O(1) time.\n            current_sum = current_sum + nums[i] - nums[i - k]\n            \n            # Calculate and store the compressed mean for the new window position.\n            result.append(current_sum // k)\n            \n        return result\n```\n**Complexity Analysis:**\n\n*   **Time Complexity:** `O(n)`\n    We calculate the sum of the first window, which takes `O(k)`. Then, we loop from `k` to `n-1` (which is `n-k` iterations). Inside the loop, all operations (addition, subtraction, division) are `O(1)`. The total time complexity is `O(k + (n-k))`, which simplifies to `O(n)`. We traverse the array only once.\n\n*   **Space Complexity:** `O(n)`\n    The space required is dominated by the `result` array, which will have `n - k + 1` elements. This is `O(n)` in the worst case. If the output array is not considered, the space complexity is `O(1)` as we only use a few variables (`current_sum`, `i`, etc.).\n\n### **4. Pattern Connection**\nThis problem is a quintessential example of the **Fixed-Size Sliding Window** pattern. The defining characteristics that signal this pattern are:\n\n1.  **Fixed-Size Substructure:** The problem explicitly asks for a calculation on all contiguous subarrays of a *fixed size `k`*. This is the most prominent signal for this pattern. The \"window\" is our subarray, and its size never changes.\n2.  **Efficient State Update:** The calculation being performed (sum) allows for a highly efficient update. When the window slides, the sum of the new window can be derived from the sum of the previous window in constant time. If the calculation were something complex that required re-evaluating all `k` elements every time (e.g., finding the median of the window), this pattern would be less effective.\n\nThe brute-force solution's `O(n*k)` complexity arises from re-computing work. The sliding window pattern's core principle is to eliminate this redundancy by maintaining a running state (`current_sum`) and updating it incrementally as the window slides, thereby achieving an optimal `O(n)` time complexity.",
    "description": "Study Calculate Compressed Mean using the Pattern 8: Sliding Window - Fixed Size (Subarray Calculation) approach.",
    "has_content": true
  },
  {
    "id": "problem_3008",
    "number": 3008,
    "title": "Find Beautiful Indices in the Given Array II",
    "category": "XIV. String Manipulation Patterns",
    "pattern": "Pattern 87: String Matching - Naive / KMP / Rabin-Karp",
    "url": "https://leetcode.com/problems/find-beautiful-indices-in-the-given-array-ii/",
    "difficulty": "hard",
    "content": "# Find Beautiful Indices in the Given Array II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find Beautiful Indices in the Given Array II](https://leetcode.com/problems/find-beautiful-indices-in-the-given-array-ii/)\n\n**Category:** XIV. String Manipulation Patterns\n**Pattern:** Pattern 87: String Matching - Naive / KMP / Rabin-Karp",
    "description": "Study Find Beautiful Indices in the Given Array II using the Pattern 87: String Matching - Naive / KMP / Rabin-Karp approach.",
    "has_content": false
  },
  {
    "id": "problem_3026",
    "number": 3026,
    "title": "Maximum Good Subarray Sum",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/maximum-good-subarray-sum/",
    "difficulty": "hard",
    "content": "# Maximum Good Subarray Sum\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Good Subarray Sum](https://leetcode.com/problems/maximum-good-subarray-sum/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Maximum Good Subarray Sum using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_3254",
    "number": 3254,
    "title": "Find the Power of K-Size Subarrays I",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 8: Sliding Window - Fixed Size (Subarray Calculation)",
    "url": "https://leetcode.com/problems/find-the-power-of-k-size-subarrays-i/",
    "difficulty": "hard",
    "content": "# Find the Power of K-Size Subarrays I\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find the Power of K-Size Subarrays I](https://leetcode.com/problems/find-the-power-of-k-size-subarrays-i/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 8: Sliding Window - Fixed Size (Subarray Calculation)",
    "description": "Study Find the Power of K-Size Subarrays I using the Pattern 8: Sliding Window - Fixed Size (Subarray Calculation) approach.",
    "has_content": false
  },
  {
    "id": "problem_3318",
    "number": 3318,
    "title": "Find X-Sum of All K-Long Subarrays I",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 8: Sliding Window - Fixed Size (Subarray Calculation)",
    "url": "https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i/",
    "difficulty": "hard",
    "content": "# Find X-Sum of All K-Long Subarrays I\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Find X-Sum of All K-Long Subarrays I](https://leetcode.com/problems/find-x-sum-of-all-k-long-subarrays-i/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 8: Sliding Window - Fixed Size (Subarray Calculation)",
    "description": "Study Find X-Sum of All K-Long Subarrays I using the Pattern 8: Sliding Window - Fixed Size (Subarray Calculation) approach.",
    "has_content": false
  },
  {
    "id": "problem_3346",
    "number": 3346,
    "title": "Maximum Frequency of an Element After Performing Operations I",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/",
    "difficulty": "hard",
    "content": "# Maximum Frequency of an Element After Performing Operations I\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Frequency of an Element After Performing Operations I](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-i/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Maximum Frequency of an Element After Performing Operations I using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  },
  {
    "id": "problem_3347",
    "number": 3347,
    "title": "Maximum Frequency of an Element After Performing Operations II",
    "category": "II. Sliding Window Patterns",
    "pattern": "Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "url": "https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/",
    "difficulty": "hard",
    "content": "# Maximum Frequency of an Element After Performing Operations II\n\n## Content in Progress\n\nThis problem content is currently being developed. Please check back later for detailed explanations, solutions, and examples.\n\n**Problem Link:** [Maximum Frequency of an Element After Performing Operations II](https://leetcode.com/problems/maximum-frequency-of-an-element-after-performing-operations-ii/)\n\n**Category:** II. Sliding Window Patterns\n**Pattern:** Pattern 9: Sliding Window - Variable Size (Condition-Based)",
    "description": "Study Maximum Frequency of an Element After Performing Operations II using the Pattern 9: Sliding Window - Variable Size (Condition-Based) approach.",
    "has_content": false
  }
]