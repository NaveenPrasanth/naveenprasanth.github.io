---
### **15. 3Sum**
**Link to Problem:** [https://leetcode.com/problems/3sum/](https://leetcode.com/problems/3sum/)

#### **1. Problem Statement**
Given an integer array `nums`, the task is to find all unique triplets `[nums[i], nums[j], nums[k]]` such that `i`, `j`, and `k` are distinct indices and the sum of the three elements is equal to zero. The final output should not contain any duplicate triplets.

#### **2. Brute Force Approach**
**Intuition:**
The most straightforward way to solve this is to check every possible combination of three distinct numbers in the array. We can use three nested loops to iterate through all possible triplets. The first loop picks the first number, the second loop picks a second number after the first, and the third loop picks a third number after the second. Inside the innermost loop, we check if their sum is zero.

A key challenge is handling duplicate triplets (e.g., `[-1, 0, 1]` is the same as `[0, 1, -1]`). To solve this, we can sort each valid triplet before storing it. Using a `set` to store the sorted triplets ensures that we only keep the unique ones.

**Python Code:**
```python
def threeSum_brute_force(nums: list[int]) -> list[list[int]]:
    n = len(nums)
    if n < 3:
        return []
    
    # A set is used to automatically handle duplicate triplets.
    # We store tuples because lists are not hashable.
    result_set = set()

    # Three nested loops to check every possible combination of three numbers.
    for i in range(n - 2):
        for j in range(i + 1, n - 1):
            for k in range(j + 1, n):
                # Check if the sum is zero
                if nums[i] + nums[j] + nums[k] == 0:
                    # Sort the triplet to handle permutations as duplicates
                    # e.g., [-1, 0, 1] and [1, 0, -1] should be treated as the same.
                    triplet = tuple(sorted([nums[i], nums[j], nums[k]]))
                    result_set.add(triplet)
    
    # Convert the set of tuples back to a list of lists.
    return [list(triplet) for triplet in result_set]

```
**Complexity Analysis:**

*   **Time Complexity: O(N^3)**
    This is due to the three nested loops, each iterating through the array. For an array of size N, the number of triplet combinations is roughly N * N * N.

*   **Space Complexity: O(K)**
    Where K is the number of unique triplets found. In the worst case, the `result_set` could store a significant number of triplets, potentially proportional to O(N^2) in some edge cases.

### **3. Optimized Approach: Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)**
**Intuition:**
The O(N^3) complexity of the brute-force approach is too slow for typical constraints. We can improve this by reducing the problem to a familiar, simpler one. If we fix one number, `nums[i]`, our equation `a + b + c = 0` becomes `b + c = -a`. This is now the classic "2Sum" problem: find two numbers in the rest of the array that sum up to a specific target (`-nums[i]`).

The key to solving the 2Sum subproblem efficiently is to first **sort the array**. Once the array is sorted, we can use the **Converging Two Pointers** pattern.

Here's the step-by-step logic:
1.  **Sort the Input Array:** Sorting is crucial. It allows us to easily skip duplicate values and use the two-pointer technique.
2.  **Iterate with One Pointer:** Loop through the sorted array with a single index `i`. This `nums[i]` will be the first element of our potential triplet.
3.  **Handle Duplicates:** If `nums[i]` is the same as `nums[i-1]`, we've already processed all possible triplets starting with this value, so we can skip it to avoid duplicate results.
4.  **Set Up Two Pointers:** For each `nums[i]`, we define our target as `target = -nums[i]`. We then initialize a `left` pointer to `i + 1` and a `right` pointer to the end of the array (`n - 1`).
5.  **Converge Pointers:** We move the `left` and `right` pointers inward until they meet:
    *   If `nums[left] + nums[right] == target`, we have found a valid triplet: `[nums[i], nums[left], nums[right]]`. We add it to our results. Then, to avoid duplicates, we move the `left` pointer forward past any identical values and the `right` pointer backward past any identical values.
    *   If `nums[left] + nums[right] < target`, the sum is too small. To increase the sum, we must move the `left` pointer to the right (`left += 1`).
    *   If `nums[left] + nums[right] > target`, the sum is too large. To decrease the sum, we must move the `right` pointer to the left (`right -= 1`).

**Example:** `nums = [-1, 0, 1, 2, -1, -4]`
1.  **Sort:** `nums = [-4, -1, -1, 0, 1, 2]`
2.  **Outer loop `i = 0`**, `nums[i] = -4`. Target = 4.
    *   `left=1`, `right=5`. `nums[left]+nums[right] = -1+2 = 1`. Too small. `left++`.
    *   `left=2`, `right=5`. `nums[left]+nums[right] = -1+2 = 1`. Too small. `left++`.
    *   ...pointers converge, no solution found.
3.  **Outer loop `i = 1`**, `nums[i] = -1`. Target = 1.
    *   `left=2`, `right=5`. `nums[left]+nums[right] = -1+2 = 1`. **Found!** Result: `[[-1, -1, 2]]`.
    *   Move pointers past duplicates. `left` becomes 3, `right` becomes 4.
    *   `left=3`, `right=4`. `nums[left]+nums[right] = 0+1 = 1`. **Found!** Result: `[[-1, -1, 2], [-1, 0, 1]]`.
    *   Move pointers. They now cross. End inner loop.
4.  **Outer loop `i = 2`**, `nums[i] = -1`. This is a duplicate of `nums[i-1]`, so we `continue`.
5.  ...and so on.

**Python Code:**
```python
def threeSum(nums: list[int]) -> list[list[int]]:
    n = len(nums)
    result = []
    
    # Sorting the array is the key to using the two-pointer approach.
    nums.sort()
    
    # Outer loop fixes the first element of the triplet.
    for i in range(n - 2):
        # Optimization: If the current number is positive, the sum can't be zero
        # since the array is sorted and all subsequent numbers will also be positive.
        if nums[i] > 0:
            break
            
        # Skip duplicate values for the first element to avoid duplicate triplets.
        if i > 0 and nums[i] == nums[i - 1]:
            continue
            
        # Set up the two pointers for the rest of the array.
        left, right = i + 1, n - 1
        
        # This is the core of the Two Pointers pattern.
        while left < right:
            current_sum = nums[i] + nums[left] + nums[right]
            
            if current_sum == 0:
                # Found a valid triplet.
                result.append([nums[i], nums[left], nums[right]])
                
                # --- Handle Duplicates for the other two elements ---
                # Move left pointer forward as long as it's a duplicate.
                while left < right and nums[left] == nums[left + 1]:
                    left += 1
                # Move right pointer backward as long as it's a duplicate.
                while left < right and nums[right] == nums[right - 1]:
                    right -= 1
                    
                # Move pointers to the next unique elements.
                left += 1
                right -= 1
            elif current_sum < 0:
                # The sum is too small, so we need a larger number.
                # Move the left pointer inward.
                left += 1
            else: # current_sum > 0
                # The sum is too big, so we need a smaller number.
                # Move the right pointer inward.
                right -= 1
                
    return result

```
**Complexity Analysis:**

*   **Time Complexity: O(N^2)**
    The initial sort takes O(N log N). The main loop runs N times. Inside it, the two-pointer `while` loop traverses the remaining part of the array, which takes O(N) time in the worst case for each `i`. This gives us O(N log N + N^2), which simplifies to O(N^2) as it's the dominant term.

*   **Space Complexity: O(log N) to O(N)**
    This depends on the implementation of the sorting algorithm used. In Python, Timsort uses O(N) auxiliary space in the worst case. If we ignore the space required for the output list `result`, the space complexity is determined by the sort.

#### **4. Pattern Connection**
This problem is a quintessential example of the **Two Pointers - Converging** pattern, elevated by nesting it within a primary loop. The signals that point to this pattern are:

1.  **Sorted Array:** The pattern relies fundamentally on the array being sorted. The need to find combinations often implies that sorting can structure the search space, which is the first hint.
2.  **Target Sum:** The problem asks for a combination of elements (a triplet) that sum to a specific target (zero). This "find a sum" requirement is a classic use case for two pointers.
3.  **Efficient Search:** The brute-force O(N^3) is clearly inefficient. After sorting and fixing one element `a`, the converging pointers (`left` starting from the beginning and `right` from the end) provide an O(N) method to search for the remaining pair `b` and `c`. The logic is simple and powerful: if the current sum is too small, only increasing the `left` pointer can help; if it's too large, only decreasing the `right` pointer can help. This systematic elimination of the search space is the hallmark of the pattern.

By recognizing that `3Sum` can be broken down into `N` instances of the `2Sum on a Sorted Array` problem, you can immediately identify it as a prime candidate for the Two Pointers pattern.