---
### **18. 4Sum**
**Link to Problem:** [https://leetcode.com/problems/4sum/](https://leetcode.com/problems/4sum/)

#### **1. Problem Statement**
Given an array `nums` of `n` integers and a target integer `target`, the task is to find all unique quadruplets `[nums[a], nums[b], nums[c], nums[d]]` such that their sum equals the `target`. The solution set must not contain duplicate quadruplets.

#### **2. Brute Force Approach**
**Intuition:**
The most straightforward way to solve this is to test every possible combination of four distinct numbers from the array. We can achieve this by using four nested loops, where each loop iterates through the array to pick one number. The outer loop picks the first number, the second loop picks the second number from the remaining part of the array, and so on.

Inside the innermost loop, we check if the sum of the four selected numbers equals the `target`. A major challenge is handling duplicate quadruplets in the output. For example, if the input is `[2, 2, 2, 2, 2]` and the target is 8, `[2, 2, 2, 2]` is the only unique answer. To solve this, we can sort each valid quadruplet before adding it to a `set` data structure, which automatically handles uniqueness.

**Python Code:**
```python
def fourSum_brute_force(nums: list[int], target: int) -> list[list[int]]:
    n = len(nums)
    if n < 4:
        return []
    
    # Use a set of tuples to automatically handle uniqueness of quadruplets.
    result_set = set()
    
    # Four nested loops to check every combination of four numbers.
    for i in range(n):
        for j in range(i + 1, n):
            for k in range(j + 1, n):
                for l in range(k + 1, n):
                    # If the sum of the four numbers equals the target...
                    if nums[i] + nums[j] + nums[k] + nums[l] == target:
                        # ...create a quadruplet, sort it to handle permutation duplicates
                        # (e.g., [1, 2] and [2, 1] become the same),
                        # and add it to the set as a tuple.
                        quadruplet = sorted([nums[i], nums[j], nums[k], nums[l]])
                        result_set.add(tuple(quadruplet))
                        
    # Convert the set of tuples back to a list of lists.
    return [list(q) for q in result_set]

```
**Complexity Analysis:**

*   **Time Complexity: O(N⁴)**
    This is due to the four nested loops, each iterating up to `N` times, where `N` is the number of elements in `nums`. The sorting and set insertion inside the loop take negligible time compared to the nested loops.

*   **Space Complexity: O(M)**
    Where `M` is the number of unique quadruplets found. The space is used to store the `result_set`. In the worst case, the number of quadruplets can be large.

---
### **3. Optimized Approach: [Pattern 1: Two Pointers - Converging (Sorted Array Target Sum)]**
**Intuition:**
The O(N⁴) complexity of the brute-force approach is too slow for larger inputs. We can significantly improve this by reducing the problem's dimensionality. The core idea is to generalize the solution for 2Sum and 3Sum. We can fix two numbers with two outer loops and then use the **Two Pointers - Converging** pattern to find the remaining two numbers.

Here's the step-by-step logic:
1.  **Sort the Array:** First, sort the input array `nums`. This is a critical prerequisite for the two-pointer pattern to work and also makes it much easier to handle duplicates.
2.  **Outer Loops (Fixing Two Numbers):** Iterate through the array with a first loop for the first number (`i`) and a nested second loop for the second number (`j`).
3.  **Reduce to 2Sum:** For each pair `(nums[i], nums[j])`, our problem becomes finding two other numbers in the rest of the array that sum up to `new_target = target - nums[i] - nums[j]`. This is now a classic 2Sum problem on a sorted subarray.
4.  **Converging Pointers:** We apply the two-pointer pattern on the subarray starting from `j + 1`.
    *   Initialize a `left` pointer to `j + 1`.
    *   Initialize a `right` pointer to the end of the array, `n - 1`.
    *   While `left < right`, calculate `current_sum = nums[left] + nums[right]`.
        *   If `current_sum == new_target`, we've found a valid quadruplet: `[nums[i], nums[j], nums[left], nums[right]]`. We add it to our results.
        *   If `current_sum < new_target`, we need a larger sum. We move the `left` pointer one step to the right (`left += 1`) to include a larger number.
        *   If `current_sum > new_target`, we need a smaller sum. We move the `right` pointer one step to the left (`right -= 1`) to include a smaller number.
5.  **Skip Duplicates:** Since the array is sorted, duplicates are grouped together.
    *   To avoid duplicate quadruplets, if we find a valid solution, we must advance the `left` and `right` pointers past all identical subsequent elements.
    *   Similarly, in the outer loops, we must skip subsequent identical elements for `i` and `j` to avoid processing the same starting pairs.

**Example Walkthrough:**
`nums = [1, 0, -1, 0, -2, 2]`, `target = 0`
1.  **Sort:** `nums` becomes `[-2, -1, 0, 0, 1, 2]`.
2.  **Outer loop `i = 0`**, `nums[i] = -2`.
3.  **Inner loop `j = 1`**, `nums[j] = -1`. `new_target = 0 - (-2) - (-1) = 3`.
    *   We now need to find two numbers that sum to 3 in `[0, 0, 1, 2]`.
    *   `left = 2` (`nums[left] = 0`), `right = 5` (`nums[right] = 2`).
    *   `current_sum = 0 + 2 = 2`. Since `2 < 3`, we need a larger sum. `left++`.
    *   `left = 3` (`nums[left] = 0`), `right = 5` (`nums[right] = 2`).
    *   `current_sum = 0 + 2 = 2`. Since `2 < 3`, `left++`.
    *   `left = 4` (`nums[left] = 1`), `right = 5` (`nums[right] = 2`).
    *   `current_sum = 1 + 2 = 3`. This matches `new_target`. We found a quadruplet: `[-2, -1, 1, 2]`. Add to results.
    *   Increment `left` and decrement `right`. The pointers cross, so this inner 2Sum loop ends.
4.  The loops for `i` and `j` continue, skipping duplicates along the way, until all combinations are explored.

**Python Code:**
```python
def fourSum(nums: list[int], target: int) -> list[list[int]]:
    n = len(nums)
    if n < 4:
        return []
    
    # Step 1: Sort the array. This is crucial for the two-pointer approach and for skipping duplicates.
    nums.sort()
    
    result = []
    
    # Step 2: Outer loop to fix the first number of the quadruplet.
    for i in range(n - 3):
        # Skip duplicates for the first number.
        if i > 0 and nums[i] == nums[i-1]:
            continue
            
        # Step 3: Inner loop to fix the second number.
        for j in range(i + 1, n - 2):
            # Skip duplicates for the second number.
            if j > i + 1 and nums[j] == nums[j-1]:
                continue
            
            # Step 4: Reduce to a 2Sum problem and apply the converging two-pointer pattern.
            left = j + 1
            right = n - 1
            
            while left < right:
                current_sum = nums[i] + nums[j] + nums[left] + nums[right]
                
                if current_sum == target:
                    # Found a valid quadruplet.
                    result.append([nums[i], nums[j], nums[left], nums[right]])
                    
                    # Pointer moves inward to search for the next unique pair.
                    left += 1
                    right -= 1
                    
                    # Step 5: Skip any duplicates for the third and fourth numbers.
                    while left < right and nums[left] == nums[left - 1]:
                        left += 1
                    while left < right and nums[right] == nums[right + 1]:
                        right -= 1
                        
                elif current_sum < target:
                    # The sum is too small, we need a larger number.
                    # The left pointer moves inward (to the right).
                    left += 1
                else: # current_sum > target
                    # The sum is too large, we need a smaller number.
                    # The right pointer moves inward (to the left).
                    right -= 1
                    
    return result

```
**Complexity Analysis:**

*   **Time Complexity: O(N³)**
    The initial sort takes O(N log N). The main work is done in the nested loops. The outer loop runs `N` times, the second loop runs `N` times, and the inner `while` loop (the two-pointer part) runs in O(N) time. This results in a total complexity of O(N * N * N) = O(N³). The O(N³) term dominates the initial sort.

*   **Space Complexity: O(log N) to O(N)**
    This depends on the space used by the sorting algorithm. Python's Timsort can use up to O(N) space in the worst case. If we ignore the space required for the output list, the auxiliary space complexity is determined by the sort.

---
#### **4. Pattern Connection**
This problem is a classic extension of the `K-Sum` problem category and perfectly demonstrates how to chain simpler patterns to solve a more complex problem. The key to solving `4Sum` efficiently lies in reducing it to a `2Sum` problem, which is the canonical use case for the **Two Pointers - Converging** pattern.

The signals that point to this pattern are:
1.  **Target Sum:** The problem asks for a combination of elements that sum up to a specific target value.
2.  **Sorted Array:** The pattern requires a sorted array to work. While the input isn't sorted, sorting it is a valid and necessary first step that enables the linear-time two-pointer scan.
3.  **High-Complexity Brute Force:** A brute-force solution with many nested loops (O(N⁴)) is too slow, signaling the need for a more optimized approach like reducing the problem's dimensionality.

By fixing the first two numbers, we create a subproblem: "find two numbers in a sorted subarray that sum to a value." This is the exact scenario where the converging two-pointer technique shines. It systematically explores all possible pairs in the subarray in a single O(N) pass by starting at opposite ends and moving inwards, efficiently closing the search window based on whether the current sum is too small or too large. Mastering this K-Sum to 2-Sum reduction is fundamental to solving many similar problems.